{\rtf1\ansi\ansicpg1252\cocoartf1265\cocoasubrtf210
{\fonttbl\f0\fmodern\fcharset0 CourierNewPSMT;\f1\fmodern\fcharset0 CourierNewPS-ItalicMT;\f2\fmodern\fcharset0 CourierNewPS-BoldMT;
}
{\colortbl;\red255\green255\blue255;\red176\green126\blue0;\red131\green129\blue131;\red191\green3\blue3;
\red1\green1\blue129;\red0\green87\blue174;\red255\green0\blue255;}
\paperw11900\paperh16840\margl1134\margr1134\margb1134\margt1134\vieww28600\viewh15520\viewkind0
\deftab720
\pard\pardeftab720

\f0\fs20 \cf0 Bloody hell! Perl!\
\
     \cf2 1\cf0 	
\f1\i \cf3 #!/usr/bin/perl
\f0\i0 \cf0 \
\
These two libraries are in ..
\f2\b /tps_example/
\f0\b0 \
\
     \cf2 2\cf0 	
\f2\b use
\f0\b0  lib \cf4 "/home/prokin01/modules-4"\cf0 ;\
\
angle.pm\
    
\f2\b sub
\f0\b0  \cf5 d_ang_set_times\cf0 () \{ \cf6 $Btime\cf0  = \cf5 shift\cf0 ; \cf6 $Etime\cf0  = shift \}\
    
\f2\b sub
\f0\b0  \cf5 d_ang_set_files\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 d_ang_set_gromacs_path\cf0 ()\{ \cf6 $GR\cf0  = &\cf5 SL\cf0 ( shift ) 
\f2\b if
\f0\b0  \cf6 @_\cf0  && \cf6 $_\cf0 [\cf2 0\cf0 ] \}\
    
\f2\b sub
\f0\b0  \cf5 d_ang_print_info\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 d_ang_calc_data_file\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 d_ang_get_at_frame\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 d_ang_get_at_time\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 d_ang_clean_temp_files\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 d_ang_last_time\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 d_ang_make_dat_file\cf0 ()\
ca_based.pm\
    
\f2\b sub
\f0\b0  \cf5 ca_set_files\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 ca_init_calc\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 ca_frames\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 ca_clean\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 ca_print_info\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 ca_get_ncr_at_frame\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 ca_get_ncr_at_time\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 ca_native_contacts\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 ca_sum_matrix\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 ca_calc_native_ctm\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 ca_conv_cagro_to_ctm\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 ca_calc_contact_matrices\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 ca_extract_gros\cf0 ()\
conf.pm\
    
\f2\b sub
\f0\b0  \cf5 G\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 trjcat\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 trjconv\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 grompp\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 mdrun\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 g_gyrate\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 g_energy\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 g_rms\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 g_saltbr\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 test_input_CONF_keys\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 get_CONF_key_type\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 print_CONF\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 init_CONF_from_file\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 value\cf0 ()\
d_aXY.pm\
    
\f2\b sub
\f0\b0  \cf5 daXY_set_times\cf0 () \{ \cf6 $Btime\cf0  = \cf5 shift\cf0 ; \cf6 $Etime\cf0  = shift \}\
    
\f2\b sub
\f0\b0  \cf5 daXY_set_files\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 daXY_set_gromacs_path\cf0 ()\{ \cf6 $GR\cf0  = &\cf5 SL\cf0 ( shift ) 
\f2\b if
\f0\b0  \cf6 @_\cf0  && \cf6 $_\cf0 [\cf2 0\cf0 ] \}\
    
\f2\b sub
\f0\b0  \cf5 daXY_print_info\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 daXY_calc_data_file\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 daXY_get_at_frame\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 daXY_get_at_time\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 daXY_clean_temp_files\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 daXY_last_time\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 daXY_make_dat_file\cf0 ()\
d_gXY.pm\
    
\f2\b sub
\f0\b0  \cf5 d_gXY_set_times\cf0 () \{ \cf6 $Btime\cf0  = \cf5 shift\cf0 ; \cf6 $Etime\cf0  = shift \}\
    
\f2\b sub
\f0\b0  \cf5 d_gXY_set_files\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 d_gXY_set_gromacs_path\cf0 ()\{ \cf6 $GR\cf0  = &\cf5 SL\cf0 ( shift ) 
\f2\b if
\f0\b0  \cf6 @_\cf0  && \cf6 $_\cf0 [\cf2 0\cf0 ] \}\
    
\f2\b sub
\f0\b0  \cf5 d_gXY_print_info\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 d_gXY_calc_data_file\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 d_gXY_get_at_frame\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 d_gXY_get_at_time\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 d_gXY_clean_temp_files\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 d_gXY_last_time\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 d_gXY_make_dat_file\cf0 ()\
dih.pm\
    
\f2\b sub
\f0\b0  \cf5 dih_set_times\cf0 () \{ \cf6 $Btime\cf0  = \cf5 shift\cf0 ; \cf6 $Etime\cf0  = shift \}\
    
\f2\b sub
\f0\b0  \cf5 dih_set_files\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 dih_set_gromacs_path\cf0 ()\{ \cf6 $GR\cf0  = &\cf5 SL\cf0 ( shift ) 
\f2\b if
\f0\b0  \cf6 @_\cf0  && \cf6 $_\cf0 [\cf2 0\cf0 ] \}\
    
\f2\b sub
\f0\b0  \cf5 dih_print_info\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 dih_calc_data_file\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 dih_last_time\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 dih_clean_temp_files\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 dih_make_dat_file\cf0 ()\
dist.pm\
    
\f2\b sub
\f0\b0  \cf5 dist_set_times\cf0 () \{ \cf6 $Btime\cf0  = \cf5 shift\cf0 ; \cf6 $Etime\cf0  = shift \}\
    
\f2\b sub
\f0\b0  \cf5 dist_set_files\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 dist_set_gromacs_path\cf0 ()\{ \cf6 $GR\cf0  = &\cf5 SL\cf0 ( shift ) 
\f2\b if
\f0\b0  \cf6 @_\cf0  && \cf6 $_\cf0 [\cf2 0\cf0 ] \}\
    
\f2\b sub
\f0\b0  \cf5 dist_set_groups\cf0 () \{ \cf6 $GROUP1\cf0  = \cf5 shift\cf0 ; \cf6 $GROUP2\cf0  = \cf5 shift\cf0 ; \}\
    
\f2\b sub
\f0\b0  \cf5 dist_print_info\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 dist_calc_data_file\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 dist_get_at_frame\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 dist_get_at_time\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 dist_clean_temp_files\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 dist_last_time\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 dist_make_dat_file\cf0 ()\
dmin.pm\
    
\f2\b sub
\f0\b0  \cf5 dmin_set_times\cf0 () \{ \cf6 $Btime\cf0  = \cf5 shift\cf0 ; \cf6 $Etime\cf0  = shift \}\
    
\f2\b sub
\f0\b0  \cf5 dmin_set_files\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 dmin_set_gromacs_path\cf0 ()\{ \cf6 $GR\cf0  = &\cf5 SL\cf0 ( shift ) 
\f2\b if
\f0\b0  \cf6 @_\cf0  && \cf6 $_\cf0 [\cf2 0\cf0 ] \}\
    
\f2\b sub
\f0\b0  \cf5 dmin_print_info\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 dmin_calc_data_file\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 dmin_get_at_frame\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 dmin_get_at_time\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 dmin_clean_temp_files\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 dmin_last_time\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 dmin_make_dat_file\cf0 ()\
dmin_xY.pm\
    
\f2\b sub
\f0\b0  \cf5 dminxY_set_times\cf0 () \{ \cf6 $Btime\cf0  = \cf5 shift\cf0 ; \cf6 $Etime\cf0  = shift \}\
    
\f2\b sub
\f0\b0  \cf5 dminxY_set_files\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 dminxY_set_gromacs_path\cf0 ()\{ \cf6 $GR\cf0  = &\cf5 SL\cf0 ( shift ) 
\f2\b if
\f0\b0  \cf6 @_\cf0  && \cf6 $_\cf0 [\cf2 0\cf0 ] \}\
    
\f2\b sub
\f0\b0  \cf5 dminxY_print_info\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 dminxY_calc_data_file\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 dminxY_get_at_frame\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 dminxY_get_at_time\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 dminxY_clean_temp_files\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 dminxY_last_time\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 dminxY_make_dat_file\cf0 ()\
d_WP.pm\
    
\f2\b sub
\f0\b0  \cf5 dWP_set_times\cf0 () \{ \cf6 $Btime\cf0  = \cf5 shift\cf0 ; \cf6 $Etime\cf0  = shift \}\
    
\f2\b sub
\f0\b0  \cf5 dWP_set_files\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 dWP_set_gromacs_path\cf0 ()\{ \cf6 $GR\cf0  = &\cf5 SL\cf0 ( shift ) 
\f2\b if
\f0\b0  \cf6 @_\cf0  && \cf6 $_\cf0 [\cf2 0\cf0 ] \}\
    
\f2\b sub
\f0\b0  \cf5 dWP_print_info\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 dWP_calc_data_file\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 dWP_get_at_frame\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 dWP_get_at_time\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 dWP_clean_temp_files\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 dWP_last_time\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 dWP_make_dat_file\cf0 ()\
d_XY.pm\
    
\f2\b sub
\f0\b0  \cf5 dXY_set_times\cf0 () \{ \cf6 $Btime\cf0  = \cf5 shift\cf0 ; \cf6 $Etime\cf0  = shift \}\
    
\f2\b sub
\f0\b0  \cf5 dXY_set_files\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 dXY_set_gromacs_path\cf0 ()\{ \cf6 $GR\cf0  = &\cf5 SL\cf0 ( shift ) 
\f2\b if
\f0\b0  \cf6 @_\cf0  && \cf6 $_\cf0 [\cf2 0\cf0 ] \}\
    
\f2\b sub
\f0\b0  \cf5 dXY_print_info\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 dXY_calc_data_file\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 dXY_get_at_frame\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 dXY_get_at_time\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 dXY_clean_temp_files\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 dXY_last_time\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 dXY_make_dat_file\cf0 ()\
geom.pm\
    
\f2\b sub
\f0\b0  point_in_poly_arr\
    
\f2\b sub
\f0\b0  point_in_poly_file \
grotools.pm\
    
\f2\b sub
\f0\b0  \cf5 set_gro_time\cf0 () 
\f1\i \cf3 #file, time
\f0\i0 \cf0 \
    
\f2\b sub
\f0\b0  gro_scale_velocities 
\f1\i \cf3 #grofile, factor, accuracy
\f0\i0 \cf0 \
    
\f2\b sub
\f0\b0  get_energy_from_gro 
\f1\i \cf3 #grofile/trr, time, file hash, path hash
\f0\i0 \cf0 \
    
\f2\b sub
\f0\b0  get_energy_at_time 
\f1\i \cf3 #edrfile, time, tempdir, gromacspth
\f0\i0 \cf0 \
    
\f2\b sub
\f0\b0  get_number_of_ndx_groups\
    
\f2\b sub
\f0\b0  get_group_ndx_number\
    
\f2\b sub
\f0\b0  \cf5 get_mdp_value\cf0 () 
\f1\i \cf3 # input ---> file , key
\f0\i0 \cf0 \
    
\f2\b sub
\f0\b0  \cf5 set_mdp_value\cf0 () 
\f1\i \cf3 #input ---> file, key, value
\f0\i0 \cf0 \
    
\f2\b sub
\f0\b0  \cf5 get_gro_time\cf0 () 
\f1\i \cf3 # input ---> gro file
\f0\i0 \cf0 \
    
\f2\b sub
\f0\b0  \cf5 get_last_log_time\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 check_sim_dir\cf0 ()\
hb.pm\
    
\f2\b sub
\f0\b0  \cf5 hb_set_times\cf0 () \{ \cf6 $Btime\cf0  = \cf5 shift\cf0 ; \cf6 $Etime\cf0  = shift \}\
    
\f2\b sub
\f0\b0  \cf5 hb_set_files\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 hb_set_gromacs_path\cf0 ()\{ \cf6 $GR\cf0  = &\cf5 SL\cf0 ( shift ) 
\f2\b if
\f0\b0  \cf6 @_\cf0  && \cf6 $_\cf0 [\cf2 0\cf0 ] \}\
    
\f2\b sub
\f0\b0  hb_set_type     \{ \cf6 $TYPE1\cf0   = shift 
\f2\b if
\f0\b0  \cf6 @_\cf0 ; \cf6 $TYPE2\cf0  = shift 
\f2\b if
\f0\b0  \cf6 @_\cf0  \}\
    
\f2\b sub
\f0\b0  \cf5 hb_print_info\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 hb_calc_data_file\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 hb_get_at_frame\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 hb_get_at_time\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 hb_get_type_name\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 hb_clean_temp_files\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 hb_last_time\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 no_hb\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 hb_update_data\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 hb_make_dat_file\cf0 ()\
hx_rmsd.pm\
    
\f2\b sub
\f0\b0  \cf5 hxrmsd_set_times\cf0 () \{ \cf6 $Btime\cf0  = \cf5 shift\cf0 ; \cf6 $Etime\cf0  = shift \}\
    
\f2\b sub
\f0\b0  \cf5 hxrmsd_set_range\cf0 () \{ \cf6 $RES_START\cf0  = \cf5 shift\cf0 ; \cf6 $RES_END\cf0  = \cf5 shift\cf0 ; \}\
    
\f2\b sub
\f0\b0  \cf5 hxrmsd_set_files\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 hxrmsd_set_gromacs_path\cf0 ()\{ \cf6 $GR\cf0  = &\cf5 SL\cf0 ( shift ) 
\f2\b if
\f0\b0  \cf6 @_\cf0  && \cf6 $_\cf0 [\cf2 0\cf0 ] \}\
    
\f2\b sub
\f0\b0  \cf5 hxrmsd_print_info\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 hxrmsd_calc_data_file\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 hxrmsd_get_at_frame\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 hxrmsd_get_at_time\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 hxrmsd_last_time\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 hxrmsd_clean_temp_files\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 hxrmsd_make_dat_file\cf0 ()\
nc_2.pm\
    
\f2\b sub
\f0\b0  nc2_set_times() \{ \cf6 $Btime\cf0  = \cf5 shift\cf0 ; \cf6 $Etime\cf0  = shift \}\
    
\f2\b sub
\f0\b0  nc2_set_files()\
    
\f2\b sub
\f0\b0  nc2_set_gromacs_path()\{ \cf6 $GR\cf0  = &\cf5 SL\cf0 ( shift ) 
\f2\b if
\f0\b0  \cf6 @_\cf0  && \cf6 $_\cf0 [\cf2 0\cf0 ] \}\
    
\f2\b sub
\f0\b0  nc2_print_info()\
    
\f2\b sub
\f0\b0  nc2_get_norm()\{ 
\f2\b return
\f0\b0  \cf6 $NC\cf0  \}\
    
\f2\b sub
\f0\b0  nc2_get_at_frame()\
    
\f2\b sub
\f0\b0  nc2_get_at_time()\
    
\f2\b sub
\f0\b0  nc2_clean_temp_files()\
    
\f2\b sub
\f0\b0  nc2_last_time()\
    
\f2\b sub
\f0\b0  nc2_make_dat_file()\
    
\f2\b sub
\f0\b0  nc2_calc_data_file()\
    
\f2\b sub
\f0\b0  nc2_extract_gros()\
    
\f2\b sub
\f0\b0  ca2_calc_contact_matrices()\
    
\f2\b sub
\f0\b0  nc2_conv_cagro_to_ctm() 
\f1\i \cf3 #cagro ctm
\f0\i0 \cf0 \
    
\f2\b sub
\f0\b0  sum2_matrix()\
    
\f2\b sub
\f0\b0  nc2_native_contacts()\
nc_mod.pm\
    
\f2\b sub
\f0\b0  \cf5 nc_mod_set_times\cf0 () \{ \cf6 $Btime\cf0  = \cf5 shift\cf0 ; \cf6 $Etime\cf0  = shift \}\
    
\f2\b sub
\f0\b0  \cf5 nc_mod_set_files\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 nc_mod_set_gromacs_path\cf0 ()\{ \cf6 $GR\cf0  = &\cf5 SL\cf0 ( shift ) 
\f2\b if
\f0\b0  \cf6 @_\cf0  && \cf6 $_\cf0 [\cf2 0\cf0 ] \}\
    
\f2\b sub
\f0\b0  \cf5 nc_mod_print_info\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 nc_mod_get_norm\cf0 ()\{ 
\f2\b return
\f0\b0  \cf6 $NC\cf0  \}\
    
\f2\b sub
\f0\b0  \cf5 nc_mod_get_at_frame\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 nc_mod_get_at_time\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 nc_mod_clean_temp_files\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 nc_mod_last_time\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 nc_mod_make_dat_file\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 nc_mod_calc_data_file\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 nc_mod_extract_gros\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 nc_mod_calc_contact_matrices\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 nc_mod_conv_cagro_to_ctm\cf0 () 
\f1\i \cf3 #cagro ctm
\f0\i0 \cf0 \
    
\f2\b sub
\f0\b0  \cf5 nc_mod_sum_matrix\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 nc_mod_native_contacts\cf0 ()\
nc.pm\
    
\f2\b sub
\f0\b0  \cf5 nc_set_times\cf0 () \{ \cf6 $Btime\cf0  = \cf5 shift\cf0 ; \cf6 $Etime\cf0  = shift \}\
    
\f2\b sub
\f0\b0  \cf5 nc_set_files\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 nc_set_gromacs_path\cf0 ()\{ \cf6 $GR\cf0  = &\cf5 SL\cf0 ( shift ) 
\f2\b if
\f0\b0  \cf6 @_\cf0  && \cf6 $_\cf0 [\cf2 0\cf0 ] \}\
    
\f2\b sub
\f0\b0  \cf5 nc_print_info\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 nc_get_norm\cf0 ()\{ 
\f2\b return
\f0\b0  \cf6 $NC\cf0  \}\
    
\f2\b sub
\f0\b0  \cf5 nc_get_at_frame\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 nc_get_at_time\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 nc_clean_temp_files\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 nc_last_time\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 nc_make_dat_file\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 nc_calc_data_file\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 nc_extract_gros\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 ca_calc_contact_matrices\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 nc_conv_cagro_to_ctm\cf0 () 
\f1\i \cf3 #cagro ctm
\f0\i0 \cf0 \
    
\f2\b sub
\f0\b0  \cf5 sum_matrix\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 nc_native_contacts\cf0 ()\
nc_sch.pm\
    
\f2\b sub
\f0\b0  \cf5 ncsch_set_times\cf0 () \{ \cf6 $Btime\cf0  = \cf5 shift\cf0 ; \cf6 $Etime\cf0  = shift \}\
    
\f2\b sub
\f0\b0  \cf5 ncsch_set_files\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 ncsch_set_gromacs_path\cf0 ()\{ \cf6 $GR\cf0  = &\cf5 SL\cf0 ( shift ) 
\f2\b if
\f0\b0  \cf6 @_\cf0  && \cf6 $_\cf0 [\cf2 0\cf0 ] \}\
    
\f2\b sub
\f0\b0  \cf5 ncsch_print_info\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 ncsch_get_norm\cf0 ()\{ 
\f2\b return
\f0\b0  \cf6 $NC\cf0  \}\
    
\f2\b sub
\f0\b0  \cf5 ncsch_get_at_frame\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 ncsch_get_at_time\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 ncsch_clean_temp_files\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 ncsch_last_time\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 ncsch_make_dat_file\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 ncsch_calc_data_file\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 ncsch_extract_gros\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 sch_calc_contact_matrices\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 ncsch_conv_cagro_to_ctm\cf0 () 
\f1\i \cf3 #cagro ctm
\f0\i0 \cf0 \
    
\f2\b sub
\f0\b0  \cf5 sum_matrix\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 ncsch_native_contacts\cf0 ()\
nc_wei.pm\
    
\f2\b sub
\f0\b0  \cf5 nc_wei_set_times\cf0 () \{ \cf6 $Btime\cf0  = \cf5 shift\cf0 ; \cf6 $Etime\cf0  = shift \}\
    
\f2\b sub
\f0\b0  \cf5 nc_wei_set_files\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 nc_wei_set_gromacs_path\cf0 ()\{ \cf6 $GR\cf0  = &\cf5 SL\cf0 ( shift ) 
\f2\b if
\f0\b0  \cf6 @_\cf0  && \cf6 $_\cf0 [\cf2 0\cf0 ] \}\
    
\f2\b sub
\f0\b0  \cf5 nc_wei_print_info\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 nc_wei_get_norm\cf0 ()\{ 
\f2\b return
\f0\b0  \cf6 $NC\cf0  \}\
    
\f2\b sub
\f0\b0  \cf5 nc_wei_get_at_frame\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 nc_wei_get_at_time\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 nc_wei_clean_temp_files\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 nc_wei_last_time\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 nc_wei_make_dat_file\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 nc_wei_calc_data_file\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 nc_wei_extract_gros\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 ca_wei_calc_contact_matrices\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 nc_wei_conv_cagro_to_ctm\cf0 () 
\f1\i \cf3 #cagro ctm
\f0\i0 \cf0 \
    
\f2\b sub
\f0\b0  \cf5 sum_wei_matrix\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 nc_wei_native_contacts\cf0 ()\
nw_tr3.pm\
    
\f2\b sub
\f0\b0  nwtr3_set_times() \{ \cf6 $Btime\cf0  = \cf5 shift\cf0 ; \cf6 $Etime\cf0  = shift \}\
    
\f2\b sub
\f0\b0  nwtr3_set_files()\
    
\f2\b sub
\f0\b0  nwtr3_set_gromacs_path()\{ \cf6 $GR\cf0  = &\cf5 SL\cf0 ( shift ) 
\f2\b if
\f0\b0  \cf6 @_\cf0  && \cf6 $_\cf0 [\cf2 0\cf0 ] \}\
    
\f2\b sub
\f0\b0  nwtr3_set_type     \{ \cf6 $TYPE\cf0   = shift 
\f2\b if
\f0\b0  \cf6 @_\cf0  \}\
    
\f2\b sub
\f0\b0  nwtr3_print_info()\
    
\f2\b sub
\f0\b0  nwtr3_get_at_frame()\
    
\f2\b sub
\f0\b0  nwtr3_get_at_time()\
    
\f2\b sub
\f0\b0  nwtr3_clean_temp_files()\
    
\f2\b sub
\f0\b0  nwtr3_last_time()\
    
\f2\b sub
\f0\b0  nwtr3_update_data()\
    
\f2\b sub
\f0\b0   nwtr3_make_dat_file()\
    
\f2\b sub
\f0\b0  nwtr3_get_type_name() 
\f1\i \cf3 #number, index
\f0\i0 \cf0 \
    
\f2\b sub
\f0\b0  nwtr3_calc_data_file()\
    
\f2\b sub
\f0\b0  measure\
    
\f2\b sub
\f0\b0  indexing\
    
\f2\b sub
\f0\b0  \cf5 sqr\cf0 ()\{ 
\f2\b my
\f0\b0  \cf6 $x\cf0  = \cf5 shift\cf0 ;  
\f2\b return
\f0\b0  \cf6 $x\cf0 *\cf6 $x\cf0  \}\
nw_X.pm\
    
\f2\b sub
\f0\b0  \cf5 nwX_set_times\cf0 () \{ \cf6 $Btime\cf0  = \cf5 shift\cf0 ; \cf6 $Etime\cf0  = shift \}\
    
\f2\b sub
\f0\b0  \cf5 nwX_set_files\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 nwX_set_gromacs_path\cf0 ()\{ \cf6 $GR\cf0  = &\cf5 SL\cf0 ( shift ) 
\f2\b if
\f0\b0  \cf6 @_\cf0  && \cf6 $_\cf0 [\cf2 0\cf0 ] \}\
    
\f2\b sub
\f0\b0  \cf5 nwX_print_info\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 nwX_calc_data_file\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 nwX_get_at_frame\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 nwX_get_at_time\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 nwX_clean_temp_files\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 nwX_last_time\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 nwX_make_dat_file\cf0 ()\
PostScript\
PostScript007\
rg.pm\
    
\f2\b sub
\f0\b0  \cf5 rg_set_times\cf0 () \{ \cf6 $Btime\cf0  = \cf5 shift\cf0 ; \cf6 $Etime\cf0  = shift \}\
    
\f2\b sub
\f0\b0  \cf5 rg_set_files\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 rg_set_gromacs_path\cf0 ()\{ \cf6 $GR\cf0  = &\cf5 SL\cf0 ( shift ) 
\f2\b if
\f0\b0  \cf6 @_\cf0  && \cf6 $_\cf0 [\cf2 0\cf0 ] \}\
    
\f2\b sub
\f0\b0  rg_set_type     \{ \cf6 $RGTYPE\cf0   = shift 
\f2\b if
\f0\b0  \cf6 @_\cf0  \}\
    
\f2\b sub
\f0\b0  \cf5 rg_print_info\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 rg_calc_data_file\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 rg_get_at_frame\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 rg_get_at_time\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 rg_get_type_name\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 rg_clean_temp_files\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 rg_last_time\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 rg_update_data\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 rg_make_dat_file\cf0 ()\
rmsd.pm\
    
\f2\b sub
\f0\b0  \cf5 rmsd_set_times\cf0 () \{ \cf6 $Btime\cf0  = \cf5 shift\cf0 ; \cf6 $Etime\cf0  = shift \}\
    
\f2\b sub
\f0\b0  \cf5 rmsd_set_files\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 rmsd_set_gromacs_path\cf0 ()\{ \cf6 $GR\cf0  = &\cf5 SL\cf0 ( shift ) 
\f2\b if
\f0\b0  \cf6 @_\cf0  && \cf6 $_\cf0 [\cf2 0\cf0 ] \}\
    
\f2\b sub
\f0\b0  rmsd_set_type     \{ \cf6 $RMSDTYPE\cf0   = \cf6 $_\cf0 [\cf2 0\cf0 ]; \cf6 $RMSDFIT\cf0  = \cf6 $_\cf0 [\cf2 1\cf0 ] 
\f2\b if
\f0\b0  \cf6 @_\cf0 >\cf2 1\cf0 ; \}\
    
\f2\b sub
\f0\b0  \cf5 rmsd_print_info\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 rmsd_calc_data_file\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 rmsd_get_at_frame\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 rmsd_get_at_time\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 rmsd_get_type_name\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 rmsd_last_time\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 rmsd_clean_temp_files\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 rmsd_make_dat_file\cf0 ()\
sas.pm\
    
\f2\b sub
\f0\b0  \cf5 sas_set_times\cf0 () \{ \cf6 $Btime\cf0  = \cf5 shift\cf0 ; \cf6 $Etime\cf0  = shift \}\
    
\f2\b sub
\f0\b0  \cf5 sas_set_files\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 sas_set_gromacs_path\cf0 ()\{ \cf6 $GR\cf0  = &\cf5 SL\cf0 ( shift ) 
\f2\b if
\f0\b0  \cf6 @_\cf0  && \cf6 $_\cf0 [\cf2 0\cf0 ] \}\
    
\f2\b sub
\f0\b0  sas_set_type  \{ \cf6 $SAS_TYPE1\cf0  = shift 
\f2\b if
\f0\b0  \cf6 @_\cf0 ; \cf6 $SAS_TYPE2\cf0  = shift 
\f2\b if
\f0\b0  \cf6 @_\cf0 ;\}\
    
\f2\b sub
\f0\b0  \cf5 sas_print_info\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 sas_calc_data_file\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 sas_get_at_frame\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 sas_get_at_time\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 sas_get_type_name\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 sas_clean_temp_files\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 sas_last_time\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 sas_update_data\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 sas_make_dat_file\cf0 ()\
tools.pm\
    
\f2\b sub
\f0\b0  \cf5 wherewhen\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 read_col_from_file_to_array\cf0 () 
\f1\i \cf3 #file, 0-basedcol, arr_ref
\f0\i0 \cf0 \
    
\f2\b sub
\f0\b0  \cf5 read_file_to_array\cf0 () 
\f1\i \cf3 #file arrref
\f0\i0 \cf0 \
    
\f2\b sub
\f0\b0  \cf5 make_path_global\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 min\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 max\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 make_temp_dir_in\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 getrandarr\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 getsize\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 numtostr\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 clormakdi\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 tesexi\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 read_word\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 print_hash\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 get_upper_path\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 dvline\cf0 () \
    
\f2\b sub
\f0\b0  \cf5 file_count\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 line_count\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 get_deepest_folder\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 create_number_file\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 add_slash\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 SL\cf0 () \
    
\f2\b sub
\f0\b0  \cf5 xvg_to_dat\cf0 () 
\f1\i \cf3 #xvgfile, datfile,
\f0\i0 \cf0 \
    
\f2\b sub
\f0\b0  \cf5 dot\cf0 ()\{ 
\f2\b print
\f0\b0  \cf4 "."\cf0  \}\
    
\f2\b sub
\f0\b0  \cf5 test_folder\cf0 ()\
xvg.pm\
    
\f2\b sub
\f0\b0  \cf5 xvg_clean_buffers\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 xvg_save_as\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 get_first_point\cf0 () 
\f1\i \cf3 #parfile, xcol, ycol
\f0\i0 \cf0 \
    
\f2\b sub
\f0\b0  \cf5 get_last_point\cf0 () 
\f1\i \cf3 #parfile, xcol, ycol
\f0\i0 \cf0 \
    
\f2\b sub
\f0\b0  \cf5 add_point\cf0 () 
\f1\i \cf3 #x,y, index, hash
\f0\i0 \cf0 \
    
\f2\b sub
\f0\b0  \cf5 add_par_file\cf0 () 
\f1\i \cf3 #file, index, hash, colx, coly
\f0\i0 \cf0 \
    
\f2\b sub
\f0\b0  \cf5 add_xy_file\cf0 () 
\f1\i \cf3 #file(x,y), index, hash
\f0\i0 \cf0 \
    
\f2\b sub
\f0\b0  \cf5 copy_header\cf0 () 
\f1\i \cf3 #file, prop_hash
\f0\i0 \cf0 \
    
\f2\b sub
\f0\b0  \cf5 add_all_sets_from_xvg\cf0 () 
\f1\i \cf3 #file,start_ind, prop_hash
\f0\i0 \cf0 \
    
\f2\b sub
\f0\b0  \cf5 add_set_properties\cf0 () 
\f1\i \cf3 #set num, property_hash
\f0\i0 \cf0 \
    
\f2\b sub
\f0\b0  \cf5 get_x_maxmin_from_xvg\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 get_y_maxmin_from_xvg\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 reverse_x_in_set\cf0 ()\
xvg_prop.dat\
\
     \cf2 3\cf0 	
\f2\b use
\f0\b0  lib \cf4 "/home/prokin01/modules-tis"\cf0 ;\
\
tis_state.pm:\
    
\f2\b sub
\f0\b0  \cf5 reverse_path\cf0 () 
\f1\i \cf3 #path
\f0\i0 \cf0 \
    
\f2\b sub
\f0\b0  belongs_2_ensemble() 
\f1\i \cf3 #path, \\@anchor_beg \\@anchor_end 
\f0\i0 \cf0 \
    
\f2\b sub
\f0\b0  \cf5 get_state_arrival_time\cf0 () 
\f1\i \cf3 #parfile \\%STATE \\%PARAM
\f0\i0 \cf0 \
    
\f2\b sub
\f0\b0  \cf5 get_all_frames_as_states\cf0 () 
\f1\i \cf3 #parfile %PARAM
\f0\i0 \cf0 \
    
\f2\b sub
\f0\b0  \cf5 get_state_str\cf0 () 
\f1\i \cf3 #back xyf, forw xyf, %PARAM, backsign, forwsign
\f0\i0 \cf0 \
    
\f2\b sub
\f0\b0  \cf5 get_rex_path\cf0 () 
\f1\i \cf3 #file, interface, %PARAM
\f0\i0 \cf0 \
    
\f2\b sub
\f0\b0  \cf5 get_lambda\cf0 () 
\f1\i \cf3 #param line !, %PARAM 
\f0\i0 \cf0 \
    
\f2\b sub
\f0\b0  \cf5 get_par_path\cf0 () 
\f1\i \cf3 #file,  %PARAM, connector
\f0\i0 \cf0 \
    
\f2\b sub
\f0\b0  \cf5 get_state\cf0 () 
\f1\i \cf3 #param line !, %PARAM 
\f0\i0 \cf0 \
    
\f2\b sub
\f0\b0  \cf5 read_param_hash\cf0 () 
\f1\i \cf3 #CONFfile
\f0\i0 \cf0 \
    
\f2\b sub
\f0\b0  \cf5 get_path_first_trans\cf0 () 
\f1\i \cf3 #file, %STATE, %PARAM
\f0\i0 \cf0 \
    
\f2\b sub
\f0\b0  \cf5 reached_fin_ini_state\cf0 () 
\f1\i \cf3 #parfile, %STATE, %PARAM
\f0\i0 \cf0 \
    
\f2\b sub
\f0\b0  \cf5 get_essential_path\cf0 () 
\f1\i \cf3 #path, \\@recrossing_rules 
\f0\i0 \cf0 \
    
\f2\b sub
\f0\b0  \cf5 get_anchor_times\cf0 () 
\f1\i \cf3 #fullpath, @anchor_beg, @anchor_end
\f0\i0 \cf0 \
    
\f2\b sub
\f0\b0  \cf5 get_state_types\cf0 ()
\f1\i \cf3 #state, %STATE
\f0\i0 \cf0 \
    
\f2\b sub
\f0\b0  \cf5 get_state_old\cf0 () 
\f1\i \cf3 #param line ! 
\f0\i0 \cf0 \
    
\f2\b sub
\f0\b0  \cf5 get_par_path_old\cf0 () 
\f1\i \cf3 #file, connectorsign
\f0\i0 \cf0 \
    
\f2\b sub
\f0\b0  \cf5 get_state_str_old\cf0 () 
\f1\i \cf3 #back xyf, forw xyf, backsign, forwsign
\f0\i0 \cf0 \
    
\f2\b sub
\f0\b0  \cf5 get_transition_time\cf0 () 
\f1\i \cf3 #transtype state_str
\f0\i0 \cf0 \
    
\f2\b sub
\f0\b0  \cf5 state_init_conf\cf0 () \
    
\f2\b sub
\f0\b0  \cf5 read_areas\cf0 () 
\f1\i \cf3 # @states?
\f0\i0 \cf0 \
    
\f2\b sub
\f0\b0  \cf5 get_number_of_params\cf0 ()\
\
tps_tools.pm:\
    
\f2\b sub
\f0\b0  \cf5 stop_running_folder\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 get_ord_pars\cf0 () 
\f1\i \cf3 #par file
\f0\i0 \cf0 \
    
\f2\b sub
\f0\b0  \cf5 get_last_trr\cf0 () 
\f1\i \cf3 #OPATH\{TRR\}
\f0\i0 \cf0 \
    
\f2\b sub
\f0\b0  \cf5 get_last_zos\cf0 () 
\f1\i \cf3 #PATH\{ZOS\}
\f0\i0 \cf0 \
    
\f2\b sub
\f0\b0  \cf5 stopped\cf0 () 
\f1\i \cf3 #run_folder
\f0\i0 \cf0 \
    
\f2\b sub
\f0\b0  \cf5 get_folder_psid\cf0 () 
\f1\i \cf3 #run_folder
\f0\i0 \cf0 \
    
\f2\b sub
\f0\b0  bf_01()\
    
\f2\b sub
\f0\b0  \cf5 oppo\cf0 ()\
    
\f2\b sub
\f0\b0  \cf5 make_zos_file\cf0 () 
\f1\i \cf3 # path/name, num0, num1
\f0\i0 \cf0 \
\
     \cf2 4\cf0 	\
     \cf2 5\cf0 	
\f2\b use
\f0\b0  Term::\cf5 ANSIColor\cf0 ;\
     \cf2 6\cf0 	
\f2\b use
\f0\b0  Term::ANSIColor \cf5 qw\cf0 (:constants);\
     \cf2 7\cf0 	\
     \cf2 8\cf0 	
\f2\b use
\f0\b0  \cf5 strict\cf0 ;\
     \cf2 9\cf0 	
\f2\b use
\f0\b0  \cf5 tools\cf0 ; \
    \cf2 10\cf0 	
\f2\b use
\f0\b0  \cf5 grotools\cf0 ;\
    \cf2 11\cf0 	
\f2\b use
\f0\b0  \cf5 conf\cf0 ;  \
    \cf2 12\cf0 	
\f2\b use
\f0\b0  \cf5 tps_tools\cf0 ;\
    \cf2 13\cf0 	
\f2\b use
\f0\b0  \cf5 tis_state\cf0 ;\
    \cf2 14\cf0 	\
    \cf2 15\cf0 	\cf5 srand\cf0 ;\
    \cf2 16\cf0 	\
    \cf2 17\cf0 	\
    \cf2 18\cf0 	\
    \cf2 19\cf0 	\
    \cf2 20\cf0 	
\f1\i \cf3 ##############################################################################
\f0\i0 \cf0 \
    \cf2 21\cf0 	
\f1\i \cf3 #                                                                            #
\f0\i0 \cf0 \
    \cf2 22\cf0 	
\f1\i \cf3 #                      PATHS/FILES/SCRIPTS                                   #
\f0\i0 \cf0 \
    \cf2 23\cf0 	
\f1\i \cf3 #                                                                            #
\f0\i0 \cf0 \
    \cf2 24\cf0 	
\f1\i \cf3 ##############################################################################
\f0\i0 \cf0 \
    \cf2 25\cf0 	
\f2\b my
\f0\b0  \cf6 %OPATH\cf0 ;   
\f1\i \cf3 #<<< store all output folders here 
\f0\i0 \cf0 \
    \cf2 26\cf0 	
\f2\b my
\f0\b0  \cf6 %PATH\cf0 ;    
\f1\i \cf3 #<<< store all other folders in this hash 
\f0\i0 \cf0 \
    \cf2 27\cf0 	
\f2\b my
\f0\b0  \cf6 %FILE\cf0 ;    
\f1\i \cf3 #<<< store all file paths here 
\f0\i0 \cf0 \
    \cf2 28\cf0 	
\f2\b my
\f0\b0  \cf6 %SCRIPT\cf0 ;  
\f1\i \cf3 #<<< store script locations here
\f0\i0 \cf0 \
    \cf2 29\cf0 	\
    \cf2 30\cf0 	\cf6 $PATH\cf0 \{MAIN\} = &\cf5 SL\cf0 (`pwd`);\
    \cf2 31\cf0 	\cf6 $FILE\cf0 \{CONF\} = \cf6 $PATH\cf0 \{MAIN\}.\cf4 "CONF"\cf0 ;\
    \cf2 32\cf0 	&\cf5 init_CONF_from_file\cf0 (\cf6 $FILE\cf0 \{CONF\});\
\
ROUTINE from modules-\cf2 4\cf0 /conf.pm\
 \
  \cf4 "key = value"\cf0  -> CONF[key] = value\
\
FILE:\
\
\pard\pardeftab720

\f1\i \cf3 ############################################################
\f0\i0 \cf0 \

\f1\i \cf3 #paths######################################################
\f0\i0 \cf0 \
mode                    = check|cont\
gromacs.path    	= 
\f2\b /hpc/
\f0\b0 sw
\f2\b /gromacs-4.5.5-sp/
\f0\b0 bin/\
path.gromacs            = 
\f2\b /hpc/
\f0\b0 sw
\f2\b /gromacs-4.5.5-sp/
\f0\b0 bin/\
gromacs.ff		= \cf2 1\cf0 \
mdrun.file              = mdrun_mpi\
mdrun.standard          = mdrun\
script.update           = update_baseroll\
max.simult.updates      = \cf2 100\cf0  \
curr.upd.folder         = 
\f2\b /home/
\f0\b0 prokin01
\f2\b /tps_baseroll/
\f0\b0 current_updates/\
update.interval         = \cf2 600\cf0 \
trj.max.frames          = \cf2 2000\cf0 \
gro.ndec                = \cf2 8\cf0 \
\
t.coupl                 = \cf2 0.2\cf0 \
mdp.dt                  = \cf2 0.002\cf0 \
mdp.nstxout             = \cf2 2500\cf0 \
mdp.nstenergy           = \cf2 2500\cf0 \
mdp.nstlist             = \cf2 10\cf0 \
mdp.rlist               = \cf2 0.8\cf0 \
mdp.coulombtype         = PME\
mdp.rcoulomb-
\f2\b switch
\f0\b0      = \cf2 0\cf0 \
mdp.rcoulomb            = \cf2 0.8\cf0 \
mdp.vdw-type            = Cut-off\
mdp.rvdw-
\f2\b switch
\f0\b0          = \cf2 0\cf0 \
mdp.rvdw                = \cf2 0.8\cf0 \
\
folder.protein  	= dna.baseroll/\
file.tpr        	= topol.tpr\
file.top                = topol.top\
file.topA               = topol_DNA_chain_A.itp\
file.topB               = topol_DNA_chain_B.itp\
folder.topincl		= \
file.mdp                = input/run.mdp\
file.gro                = conf.gro\
\
folder.temp      = \
folder.outputpar = output.par/ \
folder.outputedr = output.edr/\
folder.outputtrr = output.trr/\
folder.outputzos = output.zos/\
folder.outputrej = output.rej/\
folder.outputlog = output.log/\
\
\
STATES = [A,B,I]\
interface.param = \cf2 1\cf0 \
\
A.type        = STATE\
A.definedby   = [\cf2 3\cf0 ,\cf2 4\cf0 ]\
\
A.param3.min  = \cf2 0\cf0 \
A.param3.max  = \cf2 0.35\cf0 \
A.param4.min  = \cf2 0\cf0 \
A.param4.max  = \cf2 0.35\cf0 \
\
I.type        = STATE\
I.definedby   = [\cf2 1\cf0 ]\
\
I.param1.min  = \cf2 0.35\cf0 \
I.param1.max  = \cf2 8\cf0 \
\
B.type        = STATE\
B.definedby   = [\cf2 3\cf0 ,\cf2 5\cf0 ]\
\
B.param3.min  = \cf2 0\cf0 \
B.param3.max  = \cf2 0.35\cf0 \
B.param5.min  = \cf2 0\cf0 \
B.param5.max  = \cf2 0.35\cf0 \
\
%% These are defined in modules-\cf2 4\cf0 ?\
\
param\cf2 .1\cf0   = dist\
param\cf2 .2\cf0   = angle\
param\cf2 .3\cf0   = bp\
param\cf2 .4\cf0   = wc\
param\cf2 .5\cf0   = hg\
\
\
%% state A = (bp > \cf2 0\cf0  && bp < \cf2 0.35\cf0 ) && (wc > \cf2 0\cf0  && wc < \cf2 0.35\cf0 )\
%% state I = (dist > \cf2 0\cf0  && dist < \cf2 8\cf0 )\
%% state B = (bp > \cf2 0\cf0  && bp < \cf2 0.35\cf0 ) && (hg > \cf2 0\cf0  && hg < \cf2 0.35\cf0 )\
\
\
    \cf2 33\cf0 	&\cf5 print_CONF\cf0 ();\
    \cf2 34\cf0 	\
\
Required parameters:\
\
    \cf2 35\cf0 	
\f2\b my
\f0\b0  \cf6 @NECKEY\cf0  = qw/ \
    \cf2 36\cf0 	    update.interval\
    \cf2 37\cf0 	    gromacs.path  \
    \cf2 38\cf0 	    mdrun.file\
    \cf2 39\cf0 	    mdrun.standard\
    \cf2 40\cf0 	    script.update\
    \cf2 41\cf0 	    max.simult.updates\
    \cf2 42\cf0 	    curr.upd.folder\
    \cf2 43\cf0 	    update.interval\
    \cf2 44\cf0 	    folder.protein\
    \cf2 45\cf0 	    file.tpr\
    \cf2 46\cf0 	    file.top\
    \cf2 47\cf0 	    STATES\
    \cf2 48\cf0 	    interface.param\
    \cf2 49\cf0 	    mdp.dt            \
    \cf2 50\cf0 	    mdp.nstxout\
    \cf2 51\cf0 	    mdp.nstlist\
    \cf2 52\cf0 	    mdp.rlist               \
    \cf2 53\cf0 	    mdp.coulombtype         \
    \cf2 54\cf0 	    mdp.rcoulomb-
\f2\b switch
\f0\b0   \
    \cf2 55\cf0 	    mdp.rcoulomb\
    \cf2 56\cf0 	    mdp.vdw-type\
    \cf2 57\cf0 	    mdp.rvdw-
\f2\b switch
\f0\b0 \
    \cf2 58\cf0 	    mdp.rvdw/;\
    \cf2 59\cf0 	
\f2\b my
\f0\b0  \cf6 $extest\cf0  = &\cf5 test_input_CONF_keys\cf0 (\\\cf6 @NECKEY\cf0 );\
    \cf2 60\cf0 	die \cf6 $extest\cf0  
\f2\b if
\f0\b0  \cf6 $extest\cf0  !~ 
\f2\b /OK/
\f0\b0 ; \
    \cf2 61\cf0 	\
    \cf2 62\cf0 	\
\
Set folders 
\f2\b and
\f0\b0  filenames\
\
    \cf2 63\cf0 	\
    \cf2 64\cf0 	
\f1\i \cf3 ###temporary folders stuff###################################
\f0\i0 \cf0 \
    \cf2 65\cf0 	\cf6 $PATH\cf0 \{MAIN\}=~
\f2\b /\\/
\f0\b0 ((tps)_.*)\\
\f2\b /run_(\\d+)/
\f0\b0 ;\
    \cf2 66\cf0 	
\f2\b my
\f0\b0  \cf6 $uniqname\cf0  = \cf6 $1\cf0 .\cf4 "_run"\cf0 .\cf6 $3\cf0 ;\
    \cf2 67\cf0 	\
    \cf2 68\cf0 	
\f1\i \cf3 #change for huygens 
\f0\i0 \cf0 \
    \cf2 69\cf0 	
\f2\b my
\f0\b0  \cf6 $TMPDIR\cf0  = `echo \\\cf6 $TMPDIR\cf0 `; chomp \cf6 $TMPDIR\cf0 ;	\
    \cf2 70\cf0 	
\f2\b print
\f0\b0  \cf4 "$TMPDIR\cf7 \\n\cf4 "\cf0 ;\
    \cf2 71\cf0 	\
    \cf2 72\cf0 	\cf6 $PATH\cf0 \{MAINTEMP\} = &\cf5 SL\cf0 ( \cf6 $TMPDIR\cf0  );\
    \cf2 73\cf0 	exit 
\f2\b if
\f0\b0  !-e \cf6 $PATH\cf0 \{MAINTEMP\};\
    \cf2 74\cf0 	\
    \cf2 75\cf0 	\cf6 $PATH\cf0 \{TEMP\}=\cf6 $PATH\cf0 \{MAINTEMP\}.\cf4 "/$uniqname/"\cf0 ;\
    \cf2 76\cf0 	
\f2\b print
\f0\b0  \cf4 "$PATH\{TEMP\}\cf7 \\n\cf4 "\cf0 ;\
    \cf2 77\cf0 	mkdir \cf6 $PATH\cf0 \{TEMP\};\
    \cf2 78\cf0 	exit 
\f2\b if
\f0\b0  !-e \cf6 $PATH\cf0 \{TEMP\};\
    \cf2 79\cf0 	
\f1\i \cf3 ##############################################################
\f0\i0 \cf0 \
    \cf2 80\cf0 	\
    \cf2 81\cf0 	\
    \cf2 82\cf0 	\
    \cf2 83\cf0 	\cf6 $PATH\cf0 \{PREV_GROS\} = \cf6 $PATH\cf0 \{TEMP\}.\cf4 "PREV_GROS/"\cf0 ;\
    \cf2 84\cf0 	\cf6 $PATH\cf0 \{CURR_GROS\} = \cf6 $PATH\cf0 \{TEMP\}.\cf4 "CURR_GROS/"\cf0 ;\
    \cf2 85\cf0 	\
    \cf2 86\cf0 	\cf6 $OPATH\cf0 \{XY\}   = &\cf5 SL\cf0 ( \cf6 $PATH\cf0 \{MAIN\}.&\cf5 value\cf0 (\cf4 "folder.outputpar"\cf0 ) );\
    \cf2 87\cf0 	\cf6 $OPATH\cf0 \{PAR\}  = &\cf5 SL\cf0 ( \cf6 $PATH\cf0 \{MAIN\}.&\cf5 value\cf0 (\cf4 "folder.outputpar"\cf0 ) );   
\f1\i \cf3 #replace XY by PAR...
\f0\i0 \cf0 \
    \cf2 88\cf0 	\
    \cf2 89\cf0 	\cf6 $OPATH\cf0 \{EDR\} = &\cf5 SL\cf0 ( \cf6 $PATH\cf0 \{MAIN\}.&\cf5 value\cf0 (\cf4 "folder.outputedr"\cf0 ) );\
    \cf2 90\cf0 	\cf6 $OPATH\cf0 \{TRR\} = &\cf5 SL\cf0 ( \cf6 $PATH\cf0 \{MAIN\}.&\cf5 value\cf0 (\cf4 "folder.outputtrr"\cf0 ) );\
    \cf2 91\cf0 	\cf6 $OPATH\cf0 \{ZOS\} = &\cf5 SL\cf0 ( \cf6 $PATH\cf0 \{MAIN\}.&\cf5 value\cf0 (\cf4 "folder.outputzos"\cf0 ) );\
    \cf2 92\cf0 	\cf6 $OPATH\cf0 \{REJ\} = &\cf5 SL\cf0 ( \cf6 $PATH\cf0 \{MAIN\}.&\cf5 value\cf0 (\cf4 "folder.outputrej"\cf0 ) );\
    \cf2 93\cf0 	\cf6 $OPATH\cf0 \{LOG\} = &\cf5 SL\cf0 ( \cf6 $PATH\cf0 \{MAIN\}.&\cf5 value\cf0 (\cf4 "folder.outputlog"\cf0 ) );\
    \cf2 94\cf0 	\
    \cf2 95\cf0 	\
    \cf2 96\cf0 	\
    \cf2 97\cf0 	\cf6 $PATH\cf0 \{PROT\} = \cf6 $TMPDIR\cf0 .\cf4 "/"\cf0 .&\cf5 value\cf0 (\cf4 "folder.protein"\cf0 );\
    \cf2 98\cf0 	
\f1\i \cf3 #$PATH\{PROT\} = &SL( &value("folder.protein") );
\f0\i0 \cf0 \
    \cf2 99\cf0 	\
   \cf2 100\cf0 	\cf6 $PATH\cf0 \{TPSDIR\}  = &\cf5 SL\cf0 ( \cf6 $PATH\cf0 \{MAINTEMP\}.\cf4 "/$uniqname"."_mds/"\cf0  );\
   \cf2 101\cf0 	system \cf4 "rm -r $PATH\{TPSDIR\}"\cf0  
\f2\b if
\f0\b0  -e \cf6 $PATH\cf0 \{TPSDIR\};\
   \cf2 102\cf0 	mkdir \cf6 $PATH\cf0 \{TPSDIR\} 
\f2\b if
\f0\b0  !-e \cf6 $PATH\cf0 \{TPSDIR\};\
   \cf2 103\cf0 	\
   \cf2 104\cf0 	\cf6 $PATH\cf0 \{TPSRUNF\} = &\cf5 SL\cf0 ( \cf6 $PATH\cf0 \{TPSDIR\}.\cf4 "run_forw"\cf0  );\
   \cf2 105\cf0 	\cf6 $PATH\cf0 \{TPSRUNB\} = &\cf5 SL\cf0 ( \cf6 $PATH\cf0 \{TPSDIR\}.\cf4 "run_back"\cf0  );\
   \cf2 106\cf0 	\cf6 $FILE\cf0 \{TPR\}      = \cf6 $PATH\cf0 \{PROT\}.&\cf5 value\cf0 (\cf4 "file.tpr"\cf0 );\
   \cf2 107\cf0 	\
   \cf2 108\cf0 	\cf6 $FILE\cf0 \{MDP\}      = \cf6 $PATH\cf0 \{MAIN\}.&\cf5 value\cf0 (\cf4 "file.mdp"\cf0 );\
   \cf2 109\cf0 	 \
   \cf2 110\cf0 	\
   \cf2 111\cf0 	\cf6 $FILE\cf0 \{TOP\}      = \cf6 $PATH\cf0 \{PROT\}.&\cf5 value\cf0 (\cf4 "file.top"\cf0 );\
   \cf2 112\cf0 	\cf6 $FILE\cf0 \{TOPA\}     = \cf6 $PATH\cf0 \{PROT\}.&\cf5 value\cf0 (\cf4 "file.topA"\cf0 ) 
\f2\b if
\f0\b0  &\cf5 value\cf0 (\cf4 "file.topA"\cf0 );\
   \cf2 113\cf0 	\cf6 $FILE\cf0 \{TOPB\}     = \cf6 $PATH\cf0 \{PROT\}.&\cf5 value\cf0 (\cf4 "file.topB"\cf0 ) 
\f2\b if
\f0\b0  &\cf5 value\cf0 (\cf4 "file.topB"\cf0 );\
   \cf2 114\cf0 	\cf6 $FILE\cf0 \{NDX\}      = \cf6 $PATH\cf0 \{PROT\}.&\cf5 value\cf0 (\cf4 "file.ndx"\cf0 );\
   \cf2 115\cf0 	\
   \cf2 116\cf0 	\cf6 $PATH\cf0 \{TOPINCL\}  = \cf6 $PATH\cf0 \{PROT\}.&\cf5 value\cf0 (\cf4 "folder.topincl"\cf0 ) 
\f2\b if
\f0\b0  &\cf5 value\cf0 (\cf4 "folder.topincl"\cf0 );\
   \cf2 117\cf0 	\
   \cf2 118\cf0 	\cf6 $SCRIPT\cf0 \{UPDATE_XY\}  = \cf6 $PATH\cf0 \{MAIN\}.&\cf5 value\cf0 (\cf4 "script.update"\cf0 );\
   \cf2 119\cf0 	\cf6 $SCRIPT\cf0 \{REV_GRO\}    = \cf6 $PATH\cf0 \{MAIN\}.\cf4 "toolz/revgro.perl"\cf0 ;\
   \cf2 120\cf0 	\cf6 $SCRIPT\cf0 \{COMB_GRO\}   = \cf6 $PATH\cf0 \{MAIN\}.\cf4 "toolz/combgro.perl"\cf0 ;\
   \cf2 121\cf0 	\cf6 $SCRIPT\cf0 \{CNT_TRR_FR\} = \cf6 $PATH\cf0 \{MAIN\}.\cf4 "toolz/count.trr.frames"\cf0 ;\
   \cf2 122\cf0 	\
   \cf2 123\cf0 	\cf6 $FILE\cf0 \{STAT_TIME\} = \cf6 $PATH\cf0 \{MAIN\}.\cf4 "output.dat/times.dat"\cf0 ;\
   \cf2 124\cf0 	\cf6 $FILE\cf0 \{STAT_ACC\}  = \cf6 $PATH\cf0 \{MAIN\}.\cf4 "output.dat/accep.dat"\cf0 ;\
   \cf2 125\cf0 	\cf6 $FILE\cf0 \{ZOSINF\}    = \cf6 $PATH\cf0 \{MAIN\}.\cf4 "output.dat/zosinf.dat"\cf0 ;\
   \cf2 126\cf0 	\cf6 $FILE\cf0 \{PARPATH\}   = \cf6 $PATH\cf0 \{MAIN\}.\cf4 "output.dat/parpath.dat"\cf0 ;\
   \cf2 127\cf0 	\cf6 $FILE\cf0 \{STEP_SUMUP\}= \cf6 $PATH\cf0 \{MAIN\}.\cf4 "output.dat/step_sumup.dat"\cf0 ;\
   \cf2 128\cf0 	\cf6 $FILE\cf0 \{MOVES\}     = \cf6 $PATH\cf0 \{MAIN\}.\cf4 "output.dat/moves.dat"\cf0 ;\
   \cf2 129\cf0 	\cf6 $FILE\cf0 \{UPD_BREAKS\}= \cf6 $PATH\cf0 \{MAIN\}.\cf4 "output.dat/upd_breaks.dat"\cf0 ;\
   \cf2 130\cf0 	\
   \cf2 131\cf0 	
\f1\i \cf3 #$PATH\{GROMACS\}         = $TMPDIR."/".&value("gromacs.path");
\f0\i0 \cf0 \
   \cf2 132\cf0 	\cf6 $PATH\cf0 \{GROMACS\}         = &\cf5 value\cf0 (\cf4 "gromacs.path"\cf0 ); \
   \cf2 133\cf0 	\cf6 $FILE\cf0 \{MDRUN\}           = \cf6 $PATH\cf0 \{GROMACS\}.\cf4 "/"\cf0 .&\cf5 value\cf0 (\cf4 "mdrun.file"\cf0 );\
   \cf2 134\cf0 	\cf6 $FILE\cf0 \{MDRUN_STANDARD\}  = \cf6 $PATH\cf0 \{GROMACS\}.\cf4 "/"\cf0 .&\cf5 value\cf0 (\cf4 "mdrun.standard"\cf0 );\
   \cf2 135\cf0 	\
   \cf2 136\cf0 	&\cf5 dvline\cf0 (\cf4 "PATHS"\cf0 );   &\cf5 print_hash\cf0 (\\\cf6 %PATH\cf0 );\
   \cf2 137\cf0 	&\cf5 dvline\cf0 (\cf4 "OPATHS"\cf0 );  &\cf5 print_hash\cf0 (\\\cf6 %OPATH\cf0 );\
   \cf2 138\cf0 	&\cf5 dvline\cf0 (\cf4 "FILES"\cf0 );   &\cf5 print_hash\cf0 (\\\cf6 %FILE\cf0 );\
   \cf2 139\cf0 	&\cf5 dvline\cf0 (\cf4 "SCRIPTS"\cf0 ); &\cf5 print_hash\cf0 (\\\cf6 %SCRIPT\cf0 );\
   \cf2 140\cf0 	
\f2\b print
\f0\b0  \cf4 "\cf7 \\n\cf4 "\cf0 ;\
   \cf2 141\cf0 	\
   \cf2 142\cf0 	\
   \cf2 143\cf0 	\
\
Done setting files\
Setting some global parameters\
\
   \cf2 146\cf0 	\
   \cf2 147\cf0 	\
   \cf2 148\cf0 	
\f1\i \cf3 ##############################################################################
\f0\i0 \cf0 \
   \cf2 149\cf0 	
\f1\i \cf3 #                                                                            #
\f0\i0 \cf0 \
   \cf2 150\cf0 	
\f1\i \cf3 #                      GLOBALS - CONST                                       #
\f0\i0 \cf0 \
   \cf2 151\cf0 	
\f1\i \cf3 #                                                                            #
\f0\i0 \cf0 \
   \cf2 152\cf0 	
\f1\i \cf3 ##############################################################################
\f0\i0 \cf0 \
   \cf2 153\cf0 	
\f2\b my
\f0\b0  \cf6 $DEBUG_ON\cf0            =    \cf2 0\cf0 ;\
   \cf2 154\cf0 	
\f2\b my
\f0\b0  \cf6 $NULL\cf0                =    \cf4 "/dev/null"\cf0 ;\
   \cf2 155\cf0 	
\f2\b my
\f0\b0  \cf6 $MODE\cf0                =    &\cf5 value\cf0 (\cf4 "mode"\cf0 );\
   \cf2 156\cf0 	
\f2\b my
\f0\b0  \cf6 $UPD\cf0                 =    &\cf5 value\cf0 (\cf4 "update.interval"\cf0 );\
   \cf2 157\cf0 	
\f2\b my
\f0\b0  \cf6 $MAX_SIMULT_UPDATES\cf0  =    &\cf5 value\cf0 (\cf4 "max.simult.updates"\cf0 );\
   \cf2 158\cf0 	
\f2\b my
\f0\b0  \cf6 $CURR_UPD_FOLDER\cf0     =    &\cf5 value\cf0 (\cf4 "curr.upd.folder"\cf0 );\
   \cf2 159\cf0 	
\f2\b my
\f0\b0  \cf6 $TRR_STEP\cf0            =    &\cf5 value\cf0 (\cf4 "mdp.dt"\cf0 )*&\cf5 value\cf0 (\cf4 "mdp.nstxout"\cf0 );\
   \cf2 160\cf0 	
\f2\b my
\f0\b0  \cf6 $TIMESTEP\cf0            =    \cf6 $TRR_STEP\cf0 ;      \
   \cf2 161\cf0 	
\f2\b my
\f0\b0  \cf6 $MAX_LEN_FR\cf0          =    &\cf5 value\cf0 (\cf4 "trj.max.frames"\cf0 );       \
   \cf2 162\cf0 	
\f2\b my
\f0\b0  \cf6 $GRO_PREC\cf0            =    &\cf5 value\cf0 (\cf4 "gro.ndec"\cf0 ); \
   \cf2 163\cf0 	\
   \cf2 164\cf0 	\
   \cf2 165\cf0 	\
   \cf2 166\cf0 	\
   \cf2 167\cf0 	\
   \cf2 168\cf0 	
\f1\i \cf3 # STEP GLOBALS
\f0\i0 \cf0 \
   \cf2 169\cf0 	
\f2\b my
\f0\b0  \cf6 $CUT_G\cf0 ;                                            
\f1\i \cf3 #init in prepare_new_run
\f0\i0 \cf0 \
   \cf2 170\cf0 	
\f2\b my
\f0\b0  \cf6 $INIT_FORW_BACK\cf0 ;                                   
\f1\i \cf3 #0-started with the backward frame, 1-forward
\f0\i0 \cf0 \
   \cf2 171\cf0 	
\f2\b my
\f0\b0  \cf6 $STEP\cf0                =    &\cf5 get_last_trr_number\cf0 () + \cf2 1\cf0 ;      \
   \cf2 172\cf0 	
\f2\b my
\f0\b0  \cf6 $N_0\cf0 ;\
   \cf2 173\cf0 	
\f2\b my
\f0\b0  \cf6 $SW_0\cf0 ;\
   \cf2 174\cf0 	
\f2\b my
\f0\b0  \cf6 $STEP6\cf0 ;\
   \cf2 175\cf0 	
\f2\b my
\f0\b0  \cf6 %RES\cf0 ; \cf6 $RES\cf0 \{F\} =\cf4 "f"\cf0 ; \cf6 $RES\cf0 \{B\}=\cf4 "f"\cf0 ;                   
\f1\i \cf3 #init along updating process
\f0\i0 \cf0 \
   \cf2 176\cf0 	
\f2\b my
\f0\b0  \cf6 $T_START_CYCLE\cf0 ;                                    
\f1\i \cf3 #init at the beg of cycle
\f0\i0 \cf0 \
   \cf2 177\cf0 	
\f2\b my
\f0\b0  \cf6 $NMAX\cf0 ;\
   \cf2 178\cf0 	
\f2\b my
\f0\b0  \cf6 $SW_MAX\cf0 ;\
   \cf2 179\cf0 	
\f2\b my
\f0\b0  \cf6 $ACCEPTED\cf0            = \cf4 ""\cf0 ;\
   \cf2 180\cf0 	
\f2\b my
\f0\b0  \cf6 $STORED\cf0              = \cf2 0\cf0 ;\
   \cf2 181\cf0 	\
   \cf2 182\cf0 	
\f1\i \cf3 ##########################
\f0\i0 \cf0 \
   \cf2 183\cf0 	
\f2\b my
\f0\b0  \cf6 $CHANGE_BOX_SIZE_FLAG\cf0    =  \cf2 0\cf0 ;                      
\f1\i \cf3 #<<<IMPORTANT!!!
\f0\i0 \cf0 \
   \cf2 184\cf0 	
\f1\i \cf3 ##########################
\f0\i0 \cf0 \
   \cf2 185\cf0 	\
   \cf2 186\cf0 	
\f2\b my
\f0\b0  \cf6 $CURR_TIME_DIRECT\cf0    = \cf2 1\cf0 ;\
   \cf2 187\cf0 	
\f2\b my
\f0\b0  \cf6 $STORED_TIME_DIRECT\cf0  = \cf2 1\cf0 ;                             \
   \cf2 188\cf0 	
\f2\b my
\f0\b0  \cf6 $SHOOT_FROM_STATE\cf0    = \cf4 ""\cf0 ;\
   \cf2 189\cf0 	\
   \cf2 190\cf0 	\
   \cf2 191\cf0 	\
\
Done setting global parameters\
\
   \cf2 192\cf0 	\
   \cf2 193\cf0 	\
   \cf2 194\cf0 	
\f1\i \cf3 ##############################################################################
\f0\i0 \cf0 \
   \cf2 195\cf0 	
\f1\i \cf3 #                                                                            #
\f0\i0 \cf0 \
   \cf2 196\cf0 	
\f1\i \cf3 #                      TPS definitions                                       #
\f0\i0 \cf0 \
   \cf2 197\cf0 	
\f1\i \cf3 #                                                                            #
\f0\i0 \cf0 \
   \cf2 198\cf0 	
\f1\i \cf3 ##############################################################################
\f0\i0 \cf0 \
   \cf2 199\cf0 	
\f2\b my
\f0\b0  \cf6 @STATE\cf0  = split \cf4 ","\cf0 , (&\cf5 value\cf0 (\cf4 "STATES"\cf0 )=~
\f2\b /\\[(.+)\\]/
\f0\b0 g)[\cf2 0\cf0 ];\
   \cf2 200\cf0 	
\f2\b print
\f0\b0  \cf4 "\\@STATE = ["\cf0 .\cf5 join\cf0 (\cf4 ","\cf0 ,\cf6 @STATE\cf0 ).\cf4 "]\cf7 \\n\cf4 "\cf0 ;\
\
Read state definitions 
\f2\b and
\f0\b0  parameters\
\
   \cf2 201\cf0 	
\f2\b my
\f0\b0  \cf6 %PARAM\cf0  = &\cf5 read_param_hash\cf0 ( \cf6 $FILE\cf0 \{CONF\} );  
\f1\i \cf3 #<<<< STATES in CONF  have to agree with the following!
\f0\i0 \cf0 \
   \cf2 202\cf0 	\
\
Hardcoded definitions of states 
\f2\b for
\f0\b0  ending 
\f2\b or
\f0\b0  continuing?\
\
   \cf2 203\cf0 	\
   \cf2 204\cf0 	
\f2\b my
\f0\b0  \cf6 %STATE\cf0 ;\
   \cf2 205\cf0 	
\f1\i \cf3 #script will stop after getting here#
\f0\i0 \cf0 \
   \cf2 206\cf0 	\cf6 $STATE\cf0 \{FIN\}\{\cf2 0\cf0 \}   = \cf4 "B"\cf0 ;\
   \cf2 207\cf0 	\cf6 $STATE\cf0 \{INI\}\{\cf2 0\cf0 \}   = \cf4 "A"\cf0 ;\
   \cf2 208\cf0 	
\f1\i \cf3 #script will continue if passing through here
\f0\i0 \cf0 \
   \cf2 209\cf0 	\cf6 $STATE\cf0 \{INT\}\{\cf2 0\cf0 \}   = \cf4 "I"\cf0 ;  
\f1\i \cf3 #interfacial area 1
\f0\i0 \cf0 \
   \cf2 210\cf0 	\
\
This is a dictionary.\
So, we have paths like\
\
\pard\pardeftab720
\cf4 "^(I->A->I->)*A->(I->A->)*(I->)*(B->I->)*B(->I)*$"\cf0 \
\
   \cf2 211\cf0 	\
   \cf2 212\cf0 	
\f1\i \cf3 #recrossing rules and cuts allow to get the essential 
\f0\i0 \cf0 \
   \cf2 213\cf0 	
\f1\i \cf3 #pathway from any possible pathway
\f0\i0 \cf0 \
   \cf2 214\cf0 	
\f2\b my
\f0\b0  \cf6 @RECROSSING_RULES\cf0     = (\cf4 "A->I->A->I"\cf0 ,   \cf4 "A->I"\cf0 ,\
   \cf2 215\cf0 	                           \cf4 "I->A->I->A"\cf0 ,   \cf4 "I->A"\cf0 ,\
   \cf2 216\cf0 	                           \cf4 "B->I->B->I"\cf0 ,   \cf4 "B->I"\cf0 ,\
   \cf2 217\cf0 	                           \cf4 "I->B->I->B"\cf0 ,   \cf4 "I->B"\cf0 ,\
   \cf2 218\cf0 	                           \cf4 "^I->A"\cf0 ,        \cf4 "A"\cf0 ,        
\f1\i \cf3 #caps
\f0\i0 \cf0 \
   \cf2 219\cf0 	                           \cf4 "B->I\\$"\cf0 ,       \cf4 "B"\cf0 ,\
   \cf2 220\cf0 	                           \cf4 "A->I\\$"\cf0 ,       \cf4 "A"\cf0 ,\
   \cf2 221\cf0 	                          );\
   \cf2 222\cf0 	\
\
\
   \cf2 223\cf0 	
\f1\i \cf3 #anchors identify beginning or end in any pathway,
\f0\i0 \cf0 \
   \cf2 224\cf0 	
\f1\i \cf3 #could later be build from the possible acceptable essential pathways
\f0\i0 \cf0 \
   \cf2 225\cf0 	
\f2\b my
\f0\b0  \cf6 @ANCHOR_BEG\cf0  = (\cf4 "A->I"\cf0 );\
   \cf2 226\cf0 	
\f2\b my
\f0\b0  \cf6 @ANCHOR_END\cf0  = (\cf4 "I->B"\cf0 );\
   \cf2 227\cf0 	\
   \cf2 228\cf0 	
\f1\i \cf3 #all possible acceptable essential pathways
\f0\i0 \cf0 \
   \cf2 229\cf0 	
\f2\b my
\f0\b0  \cf6 @ACCEPTED_PATHS\cf0       = (\cf4 "A->I->B"\cf0 ); \
   \cf2 230\cf0 	\
\
This means a trajectory that was in A 
\f2\b and
\f0\b0  went through I to get to B is accepted, \
regardless of the number of recrossings.\
\
So, 
\f2\b for
\f0\b0  a trajectory that started from A, we set\
\
    -stop B\
\
And 
\f2\b for
\f0\b0  a trajectory that started from B\
\
    -stop A\
\
If we have more states we could have, starting from A\
\
    -stop \cf4 "B || C"\cf0 \
\
\
   \cf2 231\cf0 	\
   \cf2 232\cf0 	
\f2\b my
\f0\b0  \cf6 %TPS\cf0 ;\
   \cf2 233\cf0 	\
   \cf2 234\cf0 	
\f1\i \cf3 #make this work 
\f0\i0 \cf0 \
   \cf2 235\cf0 	\
   \cf2 236\cf0 	
\f1\i \cf3 #gaussian bias parameters
\f0\i0 \cf0 \
   \cf2 237\cf0 	
\f2\b my
\f0\b0  \cf6 %BIAS\cf0 ;\
   \cf2 238\cf0 	\cf6 $BIAS\cf0 \{PAR\}        =  &\cf5 value\cf0 (\cf4 "interface.param"\cf0 );\
   \cf2 239\cf0 	\cf6 $BIAS\cf0 \{MAXAT\}      =  \cf2 0\cf0 ;\
   \cf2 240\cf0 	\cf6 $BIAS\cf0 \{SIGMA\}      =  \cf2 0\cf0 ;\
   \cf2 241\cf0 	\
   \cf2 242\cf0 	\
   \cf2 243\cf0 	\cf6 $TPS\cf0 \{SHOOTING\}\{TYPE\}                =  \cf4 ""\cf0 ;          
\f1\i \cf3 #set at the beginning of each cycle
\f0\i0 \cf0 \
   \cf2 244\cf0 	                                                    
\f1\i \cf3 #used in CURRENT_LENGTH, start_runs, ACCEPTED
\f0\i0 \cf0 \
   \cf2 245\cf0 	                                                    
\f1\i \cf3 #CURRENT TPS SHOOTING TYPE. MAY CHANGE EVERY STEP!
\f0\i0 \cf0 \
   \cf2 246\cf0 	                                                    
\f1\i \cf3 #DEPENDING ON $TPS\{SHOOTING\}\{PROB2WAYS\}
\f0\i0 \cf0 \
   \cf2 247\cf0 	\cf6 $TPS\cf0 \{SHOOTING\}\{PROB2WAYS\}           =  \cf2 0.0\cf0 ;          
\f1\i \cf3 #probability of making a 2way shooting move 
\f0\i0 \cf0 \
   \cf2 248\cf0 	\cf6 $TPS\cf0 \{MOVES\}\{TIME_REVERSAL\}          =  \cf4 "NO"\cf0 ;        
\f1\i \cf3 #implemented
\f0\i0 \cf0 \
   \cf2 249\cf0 	\cf6 $TPS\cf0 \{STORE\}\{REJECTED\}\{PAR\}          =  \cf4 "YES"\cf0 ;              \
   \cf2 250\cf0 	\cf6 $TPS\cf0 \{STORE\}\{REJECTED\}\{XTC\}          =  \cf4 "YES"\cf0 ;         \
   \cf2 251\cf0 	\cf6 $TPS\cf0 \{SHOOT\}\{INI\}\{VEL\}\{_1WAY\}        =  \cf4 "RANDOM"\cf0 ;\
   \cf2 252\cf0 	\cf6 $TPS\cf0 \{SHOOT\}\{INI\}\{VEL\}\{_2WAY\}        =  \cf4 "RANDOM"\cf0 ;\
   \cf2 253\cf0 	\cf6 $TPS\cf0 \{BIAS\}\{TYPE\}                    =  \cf4 "UNIFORM"\cf0 ;  
\f1\i \cf3 #UNIFORM, GAUSSIAN
\f0\i0 \cf0 \
   \cf2 254\cf0 	\
   \cf2 255\cf0 	\
   \cf2 256\cf0 	\
   \cf2 257\cf0 	\
   \cf2 258\cf0 	\
   \cf2 259\cf0 	
\f1\i \cf3 ##############################################################################
\f0\i0 \cf0 \
   \cf2 260\cf0 	
\f1\i \cf3 #                                                                            #
\f0\i0 \cf0 \
   \cf2 261\cf0 	
\f1\i \cf3 #                     Initialisations                                        #
\f0\i0 \cf0 \
   \cf2 262\cf0 	
\f1\i \cf3 #                                                                            #
\f0\i0 \cf0 \
   \cf2 263\cf0 	
\f1\i \cf3 ##############################################################################
\f0\i0 \cf0 \
\
Set run parameter values according to CONF file\
\
   \cf2 264\cf0 	&\cf5 init_mdp_file\cf0 (\cf6 $FILE\cf0 \{MDP\});                         
\f1\i \cf3 #changes init/run.mdp which is next copied to run folders 
\f0\i0 \cf0 \
  \cf2 2141\cf0 	
\f2\b sub
\f0\b0  \cf5 init_mdp_file\cf0 () 
\f1\i \cf3 #mdpfile
\f0\i0 \cf0 \
  \cf2 2142\cf0 	\{\
  \cf2 2143\cf0 	\
  \cf2 2144\cf0 	\
  \cf2 2145\cf0 	
\f1\i \cf3 #THIS IS DONE ONLY ONCE AT THE INITIALISATION, NOT REPETED IN THE STEP CYCLE.
\f0\i0 \cf0 \
  \cf2 2146\cf0 	    
\f2\b print
\f0\b0  BLUE, \cf4 "\cf7 \\n\cf4 >>>>>>>>>>>>>>>>>> init_mdp_file: BEGIN <<<<<<<<<<<<<<<<<<\cf7 \\n\cf4 "\cf0 , RESET 
\f2\b if
\f0\b0  \cf6 $DEBUG_ON\cf0 ;    \
  \cf2 2147\cf0 	    
\f2\b my
\f0\b0  \cf6 $mdp\cf0  = \cf5 shift\cf0 ;\
  \cf2 2148\cf0 	    &\cf5 set_mdp_value\cf0 (\cf6 $mdp\cf0 ,\cf4 "dt"\cf0 ,     &\cf5 value\cf0 (\cf4 "mdp.dt"\cf0 ));\
  \cf2 2149\cf0 	    &\cf5 set_mdp_value\cf0 (\cf6 $mdp\cf0 ,\cf4 "nstxout"\cf0 ,&\cf5 value\cf0 (\cf4 "mdp.nstxout"\cf0 ));\
  \cf2 2150\cf0 	    &\cf5 set_mdp_value\cf0 (\cf6 $mdp\cf0 ,\cf4 "nstvout"\cf0 ,&\cf5 value\cf0 (\cf4 "mdp.nstxout"\cf0 ));\
  \cf2 2151\cf0 	    &\cf5 set_mdp_value\cf0 (\cf6 $mdp\cf0 ,\cf4 "nstlog"\cf0 , &\cf5 value\cf0 (\cf4 "mdp.nstxout"\cf0 ));\
  \cf2 2152\cf0 	    &\cf5 set_mdp_value\cf0 (\cf6 $mdp\cf0 ,\cf4 "nstenergy"\cf0 , &\cf5 value\cf0 (\cf4 "mdp.nstenergy"\cf0 ));\
  \cf2 2153\cf0 	\
  \cf2 2154\cf0 	    &\cf5 set_mdp_value\cf0 (\cf6 $mdp\cf0 ,\cf4 "nstlist"\cf0 ,      &\cf5 value\cf0 (\cf4 "mdp.nstlist"\cf0 ));\
  \cf2 2155\cf0 	    &\cf5 set_mdp_value\cf0 (\cf6 $mdp\cf0 ,\cf4 "rlist"\cf0 ,        &\cf5 value\cf0 (\cf4 "mdp.rlist"\cf0 ));\
  \cf2 2156\cf0 	    &\cf5 set_mdp_value\cf0 (\cf6 $mdp\cf0 ,\cf4 "coulombtype"\cf0 ,  &\cf5 value\cf0 (\cf4 "mdp.coulombtype"\cf0 ));\
  \cf2 2157\cf0 	    &\cf5 set_mdp_value\cf0 (\cf6 $mdp\cf0 ,\cf4 "rcoulomb-switch"\cf0 ,  &\cf5 value\cf0 (\cf4 "mdp.rcoulomb-switch"\cf0 ));\
  \cf2 2158\cf0 	    &\cf5 set_mdp_value\cf0 (\cf6 $mdp\cf0 ,\cf4 "rcoulomb"\cf0 ,     &\cf5 value\cf0 (\cf4 "mdp.rcoulomb"\cf0 ));\
  \cf2 2159\cf0 	    &\cf5 set_mdp_value\cf0 (\cf6 $mdp\cf0 ,\cf4 "vdw-type"\cf0 ,     &\cf5 value\cf0 (\cf4 "mdp.vdw-type"\cf0 ));\
  \cf2 2160\cf0 	    &\cf5 set_mdp_value\cf0 (\cf6 $mdp\cf0 ,\cf4 "rvdw-switch"\cf0 ,  &\cf5 value\cf0 (\cf4 "mdp.rvdw-switch"\cf0 ));\
  \cf2 2161\cf0 	    &\cf5 set_mdp_value\cf0 (\cf6 $mdp\cf0 ,\cf4 "rvdw"\cf0 ,         &\cf5 value\cf0 (\cf4 "mdp.rvdw"\cf0 ));\
  \cf2 2162\cf0 	\
  \cf2 2163\cf0 	
\f1\i \cf3 #REMOVED BECAUSE INI VEL HAS TO BE SET EVERY STEP DEPENDING ON TYPE OF SHOOTING
\f0\i0 \cf0 \
  \cf2 2164\cf0 	
\f1\i \cf3 #    if( $TPS\{SHOOTING\}\{INITIAL\}\{VELOCITIES\}=~/RANDOM/ )
\f0\i0 \cf0 \
  \cf2 2165\cf0 	
\f1\i \cf3 #    \{
\f0\i0 \cf0 \
  \cf2 2166\cf0 	
\f1\i \cf3 #	&set_mdp_value($mdp,"gen_vel",      "yes");
\f0\i0 \cf0 \
  \cf2 2167\cf0 	
\f1\i \cf3 #	&set_mdp_value($mdp,"gen_seed",     "-1" );
\f0\i0 \cf0 \
  \cf2 2168\cf0 	
\f1\i \cf3 #    \}
\f0\i0 \cf0 \
  \cf2 2169\cf0 	
\f1\i \cf3 #    if( $TPS\{SHOOTING\}\{INITIAL\}\{VELOCITIES\}=~/UNCHANGED/ )
\f0\i0 \cf0 \
  \cf2 2170\cf0 	
\f1\i \cf3 #    \{
\f0\i0 \cf0 \
  \cf2 2171\cf0 	
\f1\i \cf3 #	&set_mdp_value($mdp,"gen_vel",      "no");
\f0\i0 \cf0 \
  \cf2 2172\cf0 	
\f1\i \cf3 #	&set_mdp_value($mdp,"gen_seed",     "0" );
\f0\i0 \cf0 \
  \cf2 2173\cf0 	
\f1\i \cf3 #    \}
\f0\i0 \cf0 \
  \cf2 2174\cf0 	\
  \cf2 2175\cf0 	
\f1\i \cf3 #    if( &value("mdrun.file")=~/ander/ )
\f0\i0 \cf0 \
  \cf2 2176\cf0 	
\f1\i \cf3 #    \{
\f0\i0 \cf0 \
  \cf2 2177\cf0 		
\f2\b print
\f0\b0  \cf4 "V-rescale thermostat settings..."\cf0 ;\
  \cf2 2178\cf0 		
\f2\b my
\f0\b0  \cf6 $tcoupl\cf0  = &\cf5 value\cf0 (\cf4 "t.coupl"\cf0 );\
  \cf2 2179\cf0 		&\cf5 set_mdp_value\cf0 (\cf6 $mdp\cf0 ,\cf4 "Tcoupl"\cf0 ,\cf4 "v-rescale"\cf0 );\
  \cf2 2180\cf0 		&\cf5 set_mdp_value\cf0 (\cf6 $mdp\cf0 ,\cf4 "tau_t"\cf0 ,\cf4 "$tcoupl $tcoupl"\cf0 );\
  \cf2 2181\cf0 	
\f1\i \cf3 #    \}
\f0\i0 \cf0 \
  \cf2 2182\cf0 	\
  \cf2 2183\cf0 	    
\f2\b print
\f0\b0  BLUE, \cf4 ">>>>>>>>>>>>>>>>>> init_mdp_file: END <<<<<<<<<<<<<<<<<<\cf7 \\n\cf4 "\cf0 , RESET 
\f2\b if
\f0\b0  \cf6 $DEBUG_ON\cf0 ;    \
  \cf2 2184\cf0 	\}\
\
\
   \cf2 265\cf0 	&\cf5 init_tps_folder\cf0 ();\
  \cf2 2110\cf0 	
\f2\b sub
\f0\b0  \cf5 init_tps_folder\cf0 ()\
  \cf2 2111\cf0 	\{\
  \cf2 2112\cf0 	    
\f2\b print
\f0\b0  BLUE, \cf4 "\cf7 \\n\cf4 >>>>>>>>>>>>>>>>>> init_tps_folder: BEGIN <<<<<<<<<<<<<<<<<<\cf7 \\n\cf4 "\cf0 , RESET 
\f2\b if
\f0\b0  \cf6 $DEBUG_ON\cf0 ;    \
  \cf2 2113\cf0 	    
\f1\i \cf3 #create directory################################
\f0\i0 \cf0 \
  \cf2 2114\cf0 	    
\f2\b print
\f0\b0  \cf4 "initialising tps folders...\cf0  \cf7 \\n\cf4 "\cf0 ;\
  \cf2 2115\cf0 	    `rm \cf6 $PATH\cf0 \{TPSDIR\} -r` 
\f2\b if
\f0\b0  -e \cf6 $PATH\cf0 \{TPSDIR\};\
  \cf2 2116\cf0 	    mkdir \cf6 $PATH\cf0 \{TPSDIR\};\
  \cf2 2117\cf0 	    mkdir \cf6 $PATH\cf0 \{TPSRUNF\};\
  \cf2 2118\cf0 	    mkdir \cf6 $PATH\cf0 \{TPSRUNB\};\
  \cf2 2119\cf0 	 \
  \cf2 2120\cf0 	    
\f1\i \cf3 #files copied once###############################
\f0\i0 \cf0 \
  \cf2 2121\cf0 	    
\f2\b my
\f0\b0  \cf6 @list\cf0  = (\cf6 $FILE\cf0 \{TOP\},\cf6 $FILE\cf0 \{NDX\},\cf6 $FILE\cf0 \{MDP\},\cf6 $PATH\cf0 \{TOPINCL\});\
  \cf2 2122\cf0 	    push \cf6 @list\cf0 , \cf6 $PATH\cf0 \{TOPINCL\} 
\f2\b if
\f0\b0  \cf6 $PATH\cf0 \{TOPINCL\};\
  \cf2 2123\cf0 	    push \cf6 @list\cf0 , \cf6 $FILE\cf0 \{TOPA\} 
\f2\b if
\f0\b0  \cf6 $FILE\cf0 \{TOPA\};\
  \cf2 2124\cf0 	    push \cf6 @list\cf0 , \cf6 $FILE\cf0 \{TOPB\} 
\f2\b if
\f0\b0  \cf6 $FILE\cf0 \{TOPB\};\
  \cf2 2125\cf0 	    
\f2\b my
\f0\b0  \cf6 $list\cf0  = join \cf4 " "\cf0 , \cf6 @list\cf0 ;\
  \cf2 2126\cf0 	        \
  \cf2 2127\cf0 	    `cp -r \cf6 $list $PATH\cf0 \{TPSRUNF\}`;\
  \cf2 2128\cf0 	    `cp -r \cf6 $list $PATH\cf0 \{TPSRUNB\}`;\
  \cf2 2129\cf0 	\
  \cf2 2130\cf0 	    
\f1\i \cf3 #MODIFY BACK AND FORW MDPS
\f0\i0 \cf0 \
  \cf2 2131\cf0 	    
\f1\i \cf3 #$FILE\{MDP\} =~ /\\/([a-zA-Z0-9_]+\\.mdp)$/;
\f0\i0 \cf0 \
  \cf2 2132\cf0 	    
\f1\i \cf3 #my $mdp = $1;
\f0\i0 \cf0 \
  \cf2 2133\cf0 	    
\f1\i \cf3 #$PATH\{TPSRUNF\}.$mdp
\f0\i0 \cf0 \
  \cf2 2134\cf0 	    
\f1\i \cf3 #$PATH\{TPSRUNB\}.$mdp
\f0\i0 \cf0 \
  \cf2 2135\cf0 	   \
  \cf2 2136\cf0 	    \
  \cf2 2137\cf0 	    
\f2\b print
\f0\b0  BLUE, \cf4 "\cf7 \\n\cf4 >>>>>>>>>>>>>>>>>> init_tps_folder: END <<<<<<<<<<<<<<<<<<\cf7 \\n\cf4 "\cf0 , RESET 
\f2\b if
\f0\b0  \cf6 $DEBUG_ON\cf0 ;    \
  \cf2 2138\cf0 	\}\
  \cf2 2139\cf0 	\
  \cf2 2140\cf0 	\
\
\
   \cf2 266\cf0 	&\cf5 check_output_folders\cf0 () 
\f2\b if
\f0\b0  \cf6 $MODE\cf0 =~
\f2\b /check/
\f0\b0 ;      \
  \cf2 2320\cf0 	
\f2\b sub
\f0\b0  \cf5 check_output_folders\cf0 ()  
\f1\i \cf3 # %OPATH %FILE %PATH %SCRIPT
\f0\i0 \cf0 \
  \cf2 2321\cf0 	\{\
  \cf2 2322\cf0 	    
\f2\b print
\f0\b0  RED, \cf4 ">>>>check_output_folders: BEGIN (DEBUG)<<<<<<<<<\cf7 \\n\cf4 "\cf0 , RESET 
\f2\b if
\f0\b0  \cf6 $DEBUG_ON\cf0 ;\
  \cf2 2323\cf0 	    
\f1\i \cf3 #####################################
\f0\i0 \cf0 \
  \cf2 2324\cf0 	    
\f1\i \cf3 #my $ref1 = shift; my $ref2 = shift; 
\f0\i0 \cf0 \
  \cf2 2325\cf0 	    
\f1\i \cf3 #my $ref3 = shift; my $ref4 = shift;
\f0\i0 \cf0 \
  \cf2 2326\cf0 	    
\f1\i \cf3 #my %OPATH  = %$ref1;
\f0\i0 \cf0 \
  \cf2 2327\cf0 	    
\f1\i \cf3 #my %FILE   = %$ref2;
\f0\i0 \cf0 \
  \cf2 2328\cf0 	    
\f1\i \cf3 #my %PATH   = %$ref3;
\f0\i0 \cf0 \
  \cf2 2329\cf0 	    
\f1\i \cf3 #my %SCRIPT = %$ref4;
\f0\i0 \cf0 \
  \cf2 2330\cf0 	    
\f1\i \cf3 #my $NULL   = "/dev/null";
\f0\i0 \cf0 \
  \cf2 2331\cf0 	    
\f1\i \cf3 ####################################
\f0\i0 \cf0 \
  \cf2 2332\cf0 	    \
  \cf2 2333\cf0 	\
  \cf2 2334\cf0 	    &\cf5 dvline\cf0 (\cf4 "output check"\cf0 );\
  \cf2 2335\cf0 	    
\f1\i \cf3 #check wether trrs have their zos and right length
\f0\i0 \cf0 \
  \cf2 2336\cf0 	    
\f2\b my
\f0\b0  \cf6 @trr\cf0  = split \cf4 "\cf7 \\n\cf4 "\cf0 , `ls -\cf2 1\cf0  \cf6 $OPATH\cf0 \{TRR\} | grep trr`;\
  \cf2 2337\cf0 	      \
  \cf2 2338\cf0 	    printf \cf4 "%-10s      %s %s %s\cf7 \\n\cf4 "\cf0 ,\cf4 "trr file"\cf0 ,\cf4 "FRS"\cf0 ,\cf4 "ZOS"\cf0 ,\cf4 "PAR"\cf0 ;\
  \cf2 2339\cf0 	    
\f2\b my
\f0\b0  \cf6 %TMP\cf0 ; \cf6 $TMP\cf0 \{\cf2 0\cf0 \} = &\cf5 make_temp_dir_in\cf0 (\cf6 $PATH\cf0 \{TEMP\});\
  \cf2 2340\cf0 	    
\f2\b for
\f0\b0 (
\f2\b my
\f0\b0  \cf6 $i\cf0 =\cf2 0\cf0 ; \cf6 $i\cf0 <\cf6 @trr\cf0 ; \cf6 $i\cf0 ++)\
  \cf2 2341\cf0 	    \{\
  \cf2 2342\cf0 		\cf6 $trr\cf0 [\cf6 $i\cf0 ] =~ 
\f2\b /(\\d+)/
\f0\b0 ;\
  \cf2 2343\cf0 		
\f2\b my
\f0\b0  \cf6 $trr\cf0  = \cf4 "$OPATH\{TRR\}$trr[$i]"\cf0 ;\
  \cf2 2344\cf0 		
\f2\b my
\f0\b0  \cf6 $num\cf0  = \cf6 $1\cf0 ;\
  \cf2 2345\cf0 		
\f2\b my
\f0\b0  \cf6 $num6\cf0  = &\cf5 numtostr\cf0 (\cf6 $1\cf0 ,\cf2 6\cf0 );\
  \cf2 2346\cf0 		
\f2\b print
\f0\b0  \cf4 "$trr[$i] --> "\cf0 ;\
  \cf2 2347\cf0 		
\f2\b if
\f0\b0 ( !-e \cf4 "$OPATH\{ZOS\}$num6.zos"\cf0  )\
  \cf2 2348\cf0 		\{\
  \cf2 2349\cf0 		    
\f2\b print
\f0\b0  \cf4 "no zos! exit"\cf0 ;\
  \cf2 2350\cf0 		    \cf5 exit\cf0 ;\
  \cf2 2351\cf0 		\}\
  \cf2 2352\cf0 		
\f2\b my
\f0\b0  \cf6 $frs\cf0  = `\cf6 $SCRIPT\cf0 \{CNT_TRR_FR\} \cf6 $trr $FILE\cf0 \{TPR\} \cf6 $TMP\cf0 \{\cf2 0\cf0 \}`;\
  \cf2 2353\cf0 		printf \cf4 "\{%3d,"\cf0 ,\cf6 $frs\cf0 ;\
  \cf2 2354\cf0 	\
  \cf2 2355\cf0 		
\f2\b my
\f0\b0  \cf6 $par_l\cf0  = `wc -l  \cf6 $OPATH\cf0 \{PAR\}\cf6 $num6\cf0 .par`; \
  \cf2 2356\cf0 		\cf6 $par_l\cf0  -= \cf2 1\cf0 ; 
\f1\i \cf3 #header line
\f0\i0 \cf0 \
  \cf2 2357\cf0 	\
  \cf2 2358\cf0 	
\f1\i \cf3 #DIRTY HACK!!!!!	
\f0\i0 \cf0 \
  \cf2 2359\cf0 		\cf6 $frs\cf0  = \cf6 $par_l\cf0 ;\
  \cf2 2360\cf0 	\
  \cf2 2361\cf0 		printf \cf4 "%3d"\cf0 ,\cf6 $par_l\cf0 ;\
  \cf2 2362\cf0 		\
  \cf2 2363\cf0 	\
  \cf2 2364\cf0 		
\f1\i \cf3 ##############################
\f0\i0 \cf0 \
  \cf2 2365\cf0 	
\f1\i \cf3 #	$N_0 = $frs if $i == 0; 
\f0\i0 \cf0 \
  \cf2 2366\cf0 		
\f1\i \cf3 ##############################
\f0\i0 \cf0 \
  \cf2 2367\cf0 	\
  \cf2 2368\cf0 		
\f2\b my
\f0\b0  \cf6 @zos\cf0  = split \cf4 ""\cf0 , `head -n1 \cf6 $OPATH\cf0 \{ZOS\}\cf6 $num6\cf0 .zos`;\
  \cf2 2369\cf0 		printf \cf4 "%3d,"\cf0 ,\cf5 scalar\cf0 (\cf6 @zos\cf0 );\
  \cf2 2370\cf0 		
\f2\b if
\f0\b0 (\cf6 @zos\cf0  != \cf6 $frs\cf0 ) \
  \cf2 2371\cf0 		\{\
  \cf2 2372\cf0 		    
\f2\b print
\f0\b0  \cf4 "ERROR"\cf0 ;\
  \cf2 2373\cf0 	
\f1\i \cf3 #	    exit;
\f0\i0 \cf0 \
  \cf2 2374\cf0 		\} \
  \cf2 2375\cf0 		\
  \cf2 2376\cf0 		\
  \cf2 2377\cf0 		
\f2\b my
\f0\b0  \cf6 $str\cf0  = ( &\cf5 get_par_path\cf0 (\cf6 $OPATH\cf0 \{PAR\}.\cf6 $num6\cf0 .\cf4 ".par"\cf0 ,\\\cf6 %PARAM\cf0  ) =~ 
\f2\b /\\[.+\\]/
\f0\b0 g)[\cf2 0\cf0 ];\
  \cf2 2378\cf0 		
\f2\b print
\f0\b0  \cf6 $str\cf0 .\cf4 "\cf7 \\n\cf4 "\cf0 ;\
  \cf2 2379\cf0 	    \}\
  \cf2 2380\cf0 	    
\f2\b print
\f0\b0  \cf4 "output folders check ---> OK\cf7 \\n\cf4 "\cf0 ;\
  \cf2 2381\cf0 	    \
  \cf2 2382\cf0 	    
\f1\i \cf3 #check also xy and edr folders....
\f0\i0 \cf0 \
  \cf2 2383\cf0 	\
  \cf2 2384\cf0 	    `rm -r \cf6 $TMP\cf0 \{\cf2 0\cf0 \}`;\
  \cf2 2385\cf0 	    &\cf5 dvline\cf0 ();\
  \cf2 2386\cf0 	    
\f2\b print
\f0\b0  RED, \cf4 ">>>>check_output_folders: END (DEBUG)<<<<<<<<<\cf7 \\n\cf4 "\cf0 , RESET 
\f2\b if
\f0\b0  \cf6 $DEBUG_ON\cf0 ;\
  \cf2 2387\cf0 	\}\
\
   \cf2 267\cf0 	exit 
\f2\b if
\f0\b0  \cf6 $MODE\cf0 !~
\f2\b /cont/
\f0\b0 ;                              
\f1\i \cf3 #<<<unknown mode then
\f0\i0 \cf0 \
\
   \cf2 268\cf0 	\
   \cf2 269\cf0 	&\cf5 init_tmp_gro_dir\cf0 ();\
  \cf2 2054\cf0 	
\f2\b sub
\f0\b0  \cf5 init_tmp_gro_dir\cf0 ()\
  \cf2 2055\cf0 	\{\
  \cf2 2056\cf0 	    
\f2\b print
\f0\b0  RED, \cf4 ">>>>init_tmp_gro_dir: BEGIN (DEBUG)<<<<<<<<<\cf7 \\n\cf4 "\cf0 , RESET 
\f2\b if
\f0\b0  \cf6 $DEBUG_ON\cf0 ;\
  \cf2 2057\cf0 	    
\f1\i \cf3 #export gros from the last trr to tmp gro folder
\f0\i0 \cf0 \
  \cf2 2058\cf0 	    mkdir \cf6 $PATH\cf0 \{PREV_GROS\} 
\f2\b if
\f0\b0  !-e \cf6 $PATH\cf0 \{PREV_GROS\};\
  \cf2 2059\cf0 	    mkdir \cf6 $PATH\cf0 \{CURR_GROS\} 
\f2\b if
\f0\b0  !-e \cf6 $PATH\cf0 \{CURR_GROS\};\
  \cf2 2060\cf0 	    `rm \cf6 $PATH\cf0 \{PREV_GROS\}* \cf2 1\cf0 > \cf6 $NULL\cf0  \cf2 2\cf0 >\cf6 $NULL\cf0 `;\
  \cf2 2061\cf0 	    `rm \cf6 $PATH\cf0 \{CURR_GROS\}* \cf2 1\cf0 > \cf6 $NULL\cf0  \cf2 2\cf0 >\cf6 $NULL\cf0 `; \
  \cf2 2062\cf0 	    \
\
Split TRR to GRO files\
  \cf2 2063\cf0 	    
\f2\b my
\f0\b0  \cf6 $trr\cf0  = &\cf5 get_last_trr\cf0 (\cf6 $OPATH\cf0 \{TRR\});\
  \cf2 2064\cf0 	    \cf6 $trr\cf0  =~ 
\f2\b /(\\d+)\\.trr/
\f0\b0 ;\
  \cf2 2065\cf0 	    
\f2\b my
\f0\b0  \cf6 $num6\cf0  = \cf6 $1\cf0 ;\
  \cf2 2066\cf0 	    
\f2\b print
\f0\b0  \cf4 "extracting gros to temp folder from $num6.trr... "\cf0 ;\
  \cf2 2067\cf0 	    
\f2\b my
\f0\b0  \cf6 $input\cf0   = \cf4 "-s $FILE\{TPR\} -f $trr -ndec $GRO_PREC -sep"\cf0 ;\
  \cf2 2068\cf0 	    
\f2\b my
\f0\b0  \cf6 $output\cf0  = \cf4 "-o $PATH\{PREV_GROS\}.gro"\cf0 ;\
  \cf2 2069\cf0 	    
\f2\b my
\f0\b0  \cf6 $stream\cf0  = \cf4 "1>$PATH\{PREV_GROS\}trjconv.out 2>$PATH\{PREV_GROS\}trjconv.err"\cf0 ;  \
  \cf2 2070\cf0 	    \cf5 open\cf0 (TRJ, \cf4 "|$PATH\{GROMACS\}/trjconv $input $output $stream"\cf0 );\
  \cf2 2071\cf0 	    
\f2\b print
\f0\b0  TRJ \cf4 "0\cf7 \\n\cf4 "\cf0 ;\
  \cf2 2072\cf0 	    \cf5 close\cf0 (TRJ);\
  \cf2 2073\cf0 	    
\f1\i \cf3 #system "$PATH\{GROMACS\}/trjconv $input $output $stream"." <<EOF\\n 0\\n EOF";
\f0\i0 \cf0 \
  \cf2 2074\cf0 	    
\f2\b print
\f0\b0  \cf4 "done\cf7 \\n\cf4 "\cf0 ;\
  \cf2 2075\cf0 	\
  \cf2 2076\cf0 	    
\f1\i \cf3 #system "cp $PATH\{PREV_GROS\}trjconv.err $PATH\{MAIN\}";
\f0\i0 \cf0 \
  \cf2 2077\cf0 	    \
\
The ZOS is a line of \cf2 0\cf0 /\cf2 1\cf0 s which should match the TRR\
  \cf2 2078\cf0 	    
\f2\b print
\f0\b0  \cf4 "checking zos compatibility... "\cf0 ;\
  \cf2 2079\cf0 	    
\f2\b my
\f0\b0  \cf6 @gros\cf0  = split 
\f2\b /\\n/
\f0\b0 , `ls -\cf2 1\cf0  \cf6 $PATH\cf0 \{PREV_GROS\} | grep gro`;\
  \cf2 2080\cf0 	    
\f2\b my
\f0\b0  \cf6 $zos\cf0  = \cf4 "$OPATH\{ZOS\}$num6.zos"\cf0 ;\
  \cf2 2081\cf0 	    die \cf4 "no $zos fnd"\cf0  
\f2\b if
\f0\b0  !-e \cf6 $zos\cf0 ; \
  \cf2 2082\cf0 	    
\f2\b my
\f0\b0  \cf6 @zos\cf0  = split \cf4 ""\cf0 , `head -n1 \cf6 $zos\cf0 `;\
  \cf2 2083\cf0 	    die \cf4 "incompatible zos and trr\cf0  \cf7 \\n\cf4 $#zos  $#gros\cf7 \\n\cf4 "\cf0  
\f2\b if
\f0\b0  \cf6 @zos\cf0  != \cf6 @gros\cf0 ;\
  \cf2 2084\cf0 	    
\f2\b print
\f0\b0  \cf4 "done\cf7 \\n\cf4 "\cf0 ;\
  \cf2 2085\cf0 	    \
\
\pard\pardeftab720
\cf2 0\cf0  -> backward frame\
\cf2 1\cf0  -> forward frame\
These should be flagged in the TRR file\
\
  \cf2 2086\cf0 	    
\f2\b print
\f0\b0  \cf4 "renaming gro frames in PREV_GROS... "\cf0 ;\
  \cf2 2087\cf0 	    
\f2\b for
\f0\b0 (
\f2\b my
\f0\b0  \cf6 $i\cf0 =\cf2 0\cf0 ; \cf6 $i\cf0 <\cf6 @gros\cf0 ; \cf6 $i\cf0 ++)\
  \cf2 2088\cf0 	    \{\
  \cf2 2089\cf0 		\cf6 $gros\cf0 [\cf6 $i\cf0 ] =~ 
\f2\b /(\\d+)/
\f0\b0 ;\
  \cf2 2090\cf0 		
\f2\b my
\f0\b0  \cf6 $gnum\cf0   = \cf6 $1\cf0 ;\
  \cf2 2091\cf0 		
\f2\b my
\f0\b0  \cf6 $gnum6\cf0  = &\cf5 numtostr\cf0 (\cf6 $gnum\cf0 ,\cf2 6\cf0 );\
  \cf2 2092\cf0 		
\f1\i \cf3 #print $gnum." --->  $zos[$gnum]\\n";
\f0\i0 \cf0 \
  \cf2 2093\cf0 		`mv \cf6 $PATH\cf0 \{PREV_GROS\}\cf6 $gros\cf0 [\cf6 $i\cf0 ] \cf6 $PATH\cf0 \{PREV_GROS\}b\cf6 $gnum6\cf0 .gro`\
  \cf2 2094\cf0 		    
\f2\b if
\f0\b0  \cf6 $zos\cf0 [\cf6 $gnum\cf0 ] == \cf2 0\cf0 ;\
  \cf2 2095\cf0 		`mv \cf6 $PATH\cf0 \{PREV_GROS\}\cf6 $gros\cf0 [\cf6 $i\cf0 ] \cf6 $PATH\cf0 \{PREV_GROS\}f\cf6 $gnum6\cf0 .gro`\
  \cf2 2096\cf0 		    
\f2\b if
\f0\b0  \cf6 $zos\cf0 [\cf6 $gnum\cf0 ] == \cf2 1\cf0 ;\
  \cf2 2097\cf0 	    \}\
  \cf2 2098\cf0 	    
\f2\b print
\f0\b0  \cf4 "done\cf7 \\n\cf4 "\cf0 ;\
  \cf2 2099\cf0 	    
\f2\b print
\f0\b0  RED, \cf4 ">>>>init_tmp_gro_dir: END (DEBUG)<<<<<<<<<\cf7 \\n\cf4 "\cf0 , RESET 
\f2\b if
\f0\b0  \cf6 $DEBUG_ON\cf0 ;\
  \cf2 2100\cf0 	\}\
\
   \cf2 270\cf0 	\
   \cf2 271\cf0 	open FILE_MOVES, \cf4 ">>"\cf0 .\cf6 $FILE\cf0 \{MOVES\};\
\cf2 000010\cf0   \cf5 shooting\cf0 (\cf2 1\cf0 WAY)  accepted        A->I->B\
\cf2 000011\cf0   \cf5 shooting\cf0 (\cf2 1\cf0 WAY)  rejected        A->I->A\
\cf2 000011\cf0   \cf5 shooting\cf0 (\cf2 1\cf0 WAY)  rejected        A->I->A\
\cf2 000011\cf0   \cf5 shooting\cf0 (\cf2 1\cf0 WAY)  rejected        B->I->B->\cf2 0\cf0 ->I->B\
\cf2 000011\cf0   \cf5 shooting\cf0 (\cf2 1\cf0 WAY)  rejected        B->I->B\
\cf2 000011\cf0   \cf5 shooting\cf0 (\cf2 1\cf0 WAY)  rejected        B->I->B\
\cf2 000011\cf0   \cf5 shooting\cf0 (\cf2 1\cf0 WAY)  accepted        A->I->B\
\cf2 000012\cf0   \cf5 shooting\cf0 (\cf2 1\cf0 WAY)  rejected        A->I->A\
\cf2 000012\cf0   \cf5 shooting\cf0 (\cf2 1\cf0 WAY)  accepted        A->I->B\
\cf2 000013\cf0   \cf5 shooting\cf0 (\cf2 1\cf0 WAY)  rejected        A->I->A\
\cf2 000013\cf0   \cf5 shooting\cf0 (\cf2 1\cf0 WAY)  accepted        A->I->B\
\
\
   \cf2 272\cf0 	    \
   \cf2 273\cf0 	\
   \cf2 274\cf0 	\
   \cf2 275\cf0 	
\f1\i \cf3 ##############################################################################
\f0\i0 \cf0 \
   \cf2 276\cf0 	
\f1\i \cf3 #                                                                            #
\f0\i0 \cf0 \
   \cf2 277\cf0 	
\f1\i \cf3 #                     Main LOOP                                              #
\f0\i0 \cf0 \
   \cf2 278\cf0 	
\f1\i \cf3 #                                                                            #
\f0\i0 \cf0 \
   \cf2 279\cf0 	
\f1\i \cf3 ##############################################################################
\f0\i0 \cf0 \
\
Coming back here from line \cf2 509\cf0 \
\
   \cf2 280\cf0 	BEG:\
   \cf2 281\cf0 	\
   \cf2 282\cf0 	
\f2\b print
\f0\b0  \cf4 "\cf7 \\n\cf4 /////////////////////////////////////////////////////////////////////////////////////////////////////\cf7 \\n\cf4 "\cf0 ;\
   \cf2 283\cf0 	
\f2\b print
\f0\b0  \cf4 "/////////////////////////////////////////////////////////////////////////////////////////////////////\cf7 \\n\cf4 "\cf0 ;\
   \cf2 284\cf0 	
\f2\b print
\f0\b0  \cf4 "/////////////////////////////////////////////////////////////////////////////////////////////////////\cf7 \\n\cf4 "\cf0 ;\
\
Get the number of the 
\f2\b last
\f0\b0  TRR\
\
   \cf2 289\cf0 	\cf6 $STEP\cf0   = &\cf5 get_last_trr_number\cf0 () + \cf2 1\cf0 ;                  
\f1\i \cf3 #<<< set new step number 
\f0\i0 \cf0 \
  \cf2 1950\cf0 	
\f2\b sub
\f0\b0  \cf5 get_last_trr_number\cf0 ()\
  \cf2 1951\cf0 	\{\
  \cf2 1952\cf0 	    
\f1\i \cf3 #read the current step from the trr folder#
\f0\i0 \cf0 \
  \cf2 1953\cf0 	    
\f2\b my
\f0\b0  \cf6 @trrs\cf0  = split 
\f2\b /\\n/
\f0\b0 , `ls -\cf2 1\cf0  \cf6 $OPATH\cf0 \{TRR\}`;\
  \cf2 1954\cf0 	    
\f2\b my
\f0\b0  \cf6 $max_num\cf0  = \cf2 0\cf0 ;\
  \cf2 1955\cf0 	    
\f2\b for
\f0\b0 (
\f2\b my
\f0\b0  \cf6 $i\cf0  = \cf2 0\cf0 ; \cf6 $i\cf0 <\cf6 @trrs\cf0 ; \cf6 $i\cf0 ++)\
  \cf2 1956\cf0 	    \{\
  \cf2 1957\cf0 		\cf6 $trrs\cf0 [\cf6 $i\cf0 ] =~ 
\f2\b /(\\d+)/
\f0\b0 ;\
  \cf2 1958\cf0 		\cf6 $max_num\cf0  = \cf6 $1\cf0  
\f2\b if
\f0\b0  \cf6 $1\cf0  > \cf6 $max_num\cf0 ;\
  \cf2 1959\cf0 	    \}\
  \cf2 1960\cf0 	    \
  \cf2 1961\cf0 	    
\f2\b return
\f0\b0  \cf6 $max_num\cf0 ;\
  \cf2 1962\cf0 	\}\
\
\
Pad the number with zeroes\
\
   \cf2 290\cf0 	\cf6 $STEP6\cf0  = &\cf5 numtostr\cf0 (\cf6 $STEP\cf0 ,\cf2 6\cf0 );\
\
Read the configuration \cf5 file\cf0  (again)\
The CONF file may be updated on the fly...\
\
   \cf2 291\cf0 	&\cf5 init_CONF_from_file\cf0 (\cf6 $FILE\cf0 \{CONF\});                    
\f1\i \cf3 #<<< read configuration every step in case of some adjustements
\f0\i0 \cf0 \
\
\
   \cf2 294\cf0 	\
   \cf2 295\cf0 	
\f1\i \cf3 #-----------------------------------------------------------------------------------------------------------------------
\f0\i0 \cf0 \
   \cf2 296\cf0 	\
   \cf2 297\cf0 	
\f2\b print
\f0\b0  RED, \cf4 "TIME REVERSAL MOVES = $TPS\{MOVES\}\{TIME_REVERSAL\}\cf7 \\n\cf4 "\cf0 , \cf5 RESET\cf0 ;\
   \cf2 298\cf0 	\
   \cf2 299\cf0 	TIME_REVERSAL:\
   \cf2 300\cf0 	
\f1\i \cf3 #check if the trj is Initial->Interfaces->Initial
\f0\i0 \cf0 \
   \cf2 301\cf0 	
\f1\i \cf3 #than if rand>0.5 REVERSE and $CURR_TIME_DIRECT*=-1
\f0\i0 \cf0 \
   \cf2 302\cf0 	
\f1\i \cf3 #zos and gros reversed when the CURR_TIME_DIRECT != STOR_TIME_DIRECT and SHOOTING STARTS
\f0\i0 \cf0 \
   \cf2 303\cf0 	\
\
Noooo! a GOTO? --> line \cf2 333\cf0 \
\
   \cf2 304\cf0 	
\f2\b goto
\f0\b0  SHOOTING 
\f2\b if
\f0\b0  (\cf6 $TPS\cf0 \{MOVES\}\{TIME_REVERSAL\}=~
\f2\b /NO/
\f0\b0 );\
\
\pard\pardeftab720

\f2\b \cf0 if
\f0\b0  TIME_REVERSAL == True:\
\{\
   \cf2 305\cf0 	
\f2\b my
\f0\b0  \cf6 $roll\cf0  = \cf5 rand\cf0 (); \
   \cf2 306\cf0 	
\f2\b if
\f0\b0 (\cf6 $roll\cf0  > \cf2 0.5\cf0 ) \{ 
\f2\b print
\f0\b0  \cf4 "\cf7 \\n\cf4 "\cf0 ; 
\f2\b goto
\f0\b0  \cf5 SHOOTING\cf0 ; \}\
   \cf2 307\cf0 	\
   \cf2 308\cf0 	
\f2\b print
\f0\b0  \cf4 "TIME REVERSAL: "\cf0 ;\
   \cf2 309\cf0 	
\f1\i \cf3 #WRONG _ ERROR 
\f0\i0 \cf0 \
   \cf2 310\cf0 	
\f2\b my
\f0\b0  \cf6 $path\cf0  = ( &\cf5 get_par_path\cf0 (\cf6 $OPATH\cf0 \{PAR\}.&\cf5 numtostr\cf0 (\cf6 $STEP\cf0 -\cf2 1\cf0 ,\cf2 6\cf0 ).\cf4 ".par"\cf0 ,\\\cf6 %PARAM\cf0 ) =~ 
\f2\b /\\[(.+)\\]/
\f0\b0 g )[\cf2 0\cf0 ];\
   \cf2 311\cf0 	
\f2\b my
\f0\b0  \cf6 $ess_path\cf0  = &\cf5 get_essential_path\cf0 (\cf6 $path\cf0 ,\\\cf6 @RECROSSING_RULES\cf0 );\
   \cf2 312\cf0 	\
   \cf2 313\cf0 	
\f2\b my
\f0\b0  \cf6 $rev_ess_path\cf0  = &\cf5 reverse_path\cf0 (\cf6 $ess_path\cf0 );\
   \cf2 314\cf0 	
\f2\b print
\f0\b0  \cf4 "REV[ $ess_path ] = $rev_ess_path"\cf0 ;\
   \cf2 315\cf0 	\
   \cf2 316\cf0 	
\f2\b if
\f0\b0 ( &belongs_2_ensemble(\cf6 $rev_ess_path\cf0 ,\\\cf6 @ANCHOR_BEG\cf0 , \\\cf6 @ANCHOR_END\cf0 ) ) \
   \cf2 317\cf0 	\{\
   \cf2 318\cf0 	    
\f2\b print
\f0\b0  \cf4 " --> ACCEPTED\cf7 \\n\cf4 "\cf0 ;\
   \cf2 319\cf0 	    \cf6 $CURR_TIME_DIRECT\cf0  *= -\cf2 1\cf0 ;\
   \cf2 320\cf0 	    \cf6 $ess_path\cf0  = \cf6 $rev_ess_path\cf0 ;\
   \cf2 321\cf0 	    
\f2\b print
\f0\b0  FILE_MOVES \cf4 "$STEP6\cf7 \\t\cf4 time_rev\cf7 \\t\cf4 accepted\cf7 \\t\cf4 $ess_path\cf7 \\n\cf4 "\cf0 ;\
\
Go to line \cf2 299\cf0 \
\
   \cf2 322\cf0 	    
\f2\b goto
\f0\b0  \cf5 TIME_REVERSAL\cf0 ;\
   \cf2 323\cf0 	\}\
   \cf2 324\cf0 	
\f2\b else
\f0\b0 \
   \cf2 325\cf0 	\{\
   \cf2 326\cf0 	    
\f2\b print
\f0\b0  \cf4 " --> REJECTED\cf7 \\n\cf4 "\cf0 ;\
   \cf2 327\cf0 	    
\f2\b print
\f0\b0  FILE_MOVES \cf4 "$STEP6\cf7 \\t\cf4 time_rev\cf7 \\t\cf4 rejected\cf7 \\t\cf4 $ess_path\cf7 \\n\cf4 "\cf0 ;\
\
Go to line \cf2 299\cf0 \
\
   \cf2 328\cf0 	    
\f2\b goto
\f0\b0  \cf5 TIME_REVERSAL\cf0 ;\
   \cf2 329\cf0 	\}\
   \cf2 330\cf0 	\
\}\
 \
\
   \cf2 331\cf0 	
\f1\i \cf3 #----------------------------------------------------------------------------------------------------------------------------
\f0\i0 \cf0 \
   \cf2 332\cf0 	\
   \cf2 333\cf0 	SHOOTING: \
   \cf2 334\cf0 	\
   \cf2 335\cf0 	
\f2\b my
\f0\b0  \cf6 $rnd\cf0  = \cf5 rand\cf0 ();\
   \cf2 336\cf0 	\cf6 $TPS\cf0 \{SHOOTING\}\{TYPE\}=\cf4 "2WAY"\cf0  
\f2\b if
\f0\b0  \cf6 $rnd\cf0  <  \cf6 $TPS\cf0 \{SHOOTING\}\{PROB2WAYS\};\
   \cf2 337\cf0 	\cf6 $TPS\cf0 \{SHOOTING\}\{TYPE\}=\cf4 "1WAY"\cf0  
\f2\b if
\f0\b0  \cf6 $rnd\cf0  >= \cf6 $TPS\cf0 \{SHOOTING\}\{PROB2WAYS\};\
   \cf2 338\cf0 	
\f2\b print
\f0\b0  RED, \cf4 "SHOOTING TYPE THIS STEP = $TPS\{SHOOTING\}\{TYPE\}\cf7 \\n\cf4 "\cf0 , \cf5 RESET\cf0 ; \
   \cf2 339\cf0 	    \
   \cf2 340\cf0 	\
   \cf2 341\cf0 	&\cf5 move_gro_frames\cf0 ();                                   
\f1\i \cf3 #<<< move gro frames from CURR to PREV_GROS  
\f0\i0 \cf0 \
   \cf2 342\cf0 	
\f2\b if
\f0\b0 ( \cf6 $CURR_TIME_DIRECT\cf0  != \cf6 $STORED_TIME_DIRECT\cf0  )\
   \cf2 343\cf0 	\{\
   \cf2 344\cf0 	    &\cf5 _reverse_gro_files_in_PREV\cf0 ();\
   \cf2 345\cf0 	    \cf6 $STORED_TIME_DIRECT\cf0  *= -\cf2 1\cf0 ;                        
\f1\i \cf3 #<<< gros reverse (in PREV_GROS);
\f0\i0 \cf0 \
   \cf2 346\cf0 	\}\
\
 \
   \cf2 347\cf0 	&\cf5 prepare_new_run\cf0 ();                                   
\f1\i \cf3 #<<< initiate run folders (and random the initial gro file)
\f0\i0 \cf0 \
Until line \cf2 2051\cf0 \
  \cf2 1968\cf0 	
\f2\b sub
\f0\b0  \cf5 prepare_new_run\cf0 ()\
  \cf2 1969\cf0 	\{\
  \cf2 1970\cf0 	    
\f2\b print
\f0\b0  RED, \cf4 ">>>>prepare_new_run: BEGIN (DEBUG)<<<<<<<<<\cf7 \\n\cf4 "\cf0 , RESET 
\f2\b if
\f0\b0  \cf6 $DEBUG_ON\cf0 ;\
  \cf2 1971\cf0 	    
\f2\b print
\f0\b0  BLUE, \cf4 "[ preparing new run ]\cf7 \\n\cf4 "\cf0 , RESET 
\f2\b if
\f0\b0  \cf6 $DEBUG_ON\cf0 ;\
  \cf2 1972\cf0 	   \
  \cf2 1973\cf0 	\
  \cf2 1974\cf0 	     
\f1\i \cf3 #first remove unnecessary files####
\f0\i0 \cf0 \
  \cf2 1975\cf0 	    
\f2\b my
\f0\b0  \cf6 @list\cf0  =(\cf4 "*.log"\cf0 ,\cf4 "*.err"\cf0 ,\cf4 "*.out"\cf0 ,\cf4 "*.gro"\cf0 ,\cf4 "mdout.mdp"\cf0 ,\
  \cf2 1976\cf0 		       \cf4 "*.tpr"\cf0 ,\cf4 "*.xtc"\cf0 ,\cf4 "*.trr"\cf0 ,\cf4 "*.edr"\cf0 ,\cf4 "#*"\cf0 );\
  \cf2 1977\cf0 	\
  \cf2 1978\cf0 	    
\f1\i \cf3 #print "removing files --> [".join("|",@list)."]\\n";
\f0\i0 \cf0 \
  \cf2 1979\cf0 	    
\f2\b print
\f0\b0  \cf4 "removing files...\cf7 \\n\cf4 "\cf0  
\f2\b if
\f0\b0  \cf6 $DEBUG_ON\cf0 ;\
  \cf2 1980\cf0 	    
\f2\b for
\f0\b0 (
\f2\b my
\f0\b0  \cf6 $i\cf0 =\cf2 0\cf0 ; \cf6 $i\cf0 <\cf6 @list\cf0 ; \cf6 $i\cf0 ++)\
  \cf2 1981\cf0 	    \{\
  \cf2 1982\cf0 		`rm \cf6 $PATH\cf0 \{TPSRUNF\}\cf6 $list\cf0 [\cf6 $i\cf0 ] \cf2 1\cf0 >\cf6 $NULL\cf0  \cf2 2\cf0 >\cf6 $NULL\cf0 `;\
  \cf2 1983\cf0 		`rm \cf6 $PATH\cf0 \{TPSRUNB\}\cf6 $list\cf0 [\cf6 $i\cf0 ] \cf2 1\cf0 >\cf6 $NULL\cf0  \cf2 2\cf0 >\cf6 $NULL\cf0 `;\
  \cf2 1984\cf0 	    \}\
  \cf2 1985\cf0 	   \
  \cf2 1986\cf0 	    
\f1\i \cf3 #choos starting frame, prepare reverse gro###
\f0\i0 \cf0 \
  \cf2 1987\cf0 	    
\f1\i \cf3 #and copy to right folders###################
\f0\i0 \cf0 \
* \cf2 1988\cf0 	    &\cf5 prepare_gro_files\cf0 ();\
  \cf2 1989\cf0 	\
  \cf2 1990\cf0 	    
\f1\i \cf3 #init the RESULTS####
\f0\i0 \cf0 \
  \cf2 1991\cf0 	    \cf6 $RES\cf0 \{F\} = \cf4 "f"\cf0 ;\
  \cf2 1992\cf0 	    \cf6 $RES\cf0 \{B\} = \cf4 "f"\cf0 ;\
  \cf2 1993\cf0 	    \
  \cf2 1994\cf0 	\
  \cf2 1995\cf0 	    
\f1\i \cf3 #also do some cleaning in output
\f0\i0 \cf0 \
  \cf2 1996\cf0 	    
\f1\i \cf3 #remove all the files with the current step 
\f0\i0 \cf0 \
  \cf2 1997\cf0 	    
\f1\i \cf3 #IMPORTANT!!! most IMPORTANT TO CLEAN XY!
\f0\i0 \cf0 \
  \cf2 1998\cf0 	    
\f2\b print
\f0\b0  \cf4 "removing this step output files\cf7 \\n\cf4 "\cf0  
\f2\b if
\f0\b0  \cf6 $DEBUG_ON\cf0 ;\
  \cf2 1999\cf0 	    
\f2\b my
\f0\b0  \cf6 $step6\cf0  = &\cf5 numtostr\cf0 (\cf6 $STEP\cf0 ,\cf2 6\cf0 );\
  \cf2 2000\cf0 	    
\f2\b foreach
\f0\b0  
\f2\b my
\f0\b0  \cf6 $ext\cf0  (keys \cf6 %OPATH\cf0 )\
  \cf2 2001\cf0 	    \{\
  \cf2 2002\cf0 		
\f1\i \cf3 #dont remove REJECTED PATWAYS....
\f0\i0 \cf0 \
  \cf2 2003\cf0 		
\f2\b next if
\f0\b0  \cf6 $ext\cf0 =~
\f2\b /REJ/
\f0\b0 ;\
  \cf2 2004\cf0 		`rm \cf6 $OPATH\cf0 \{\cf6 $ext\cf0 \}\cf6 $step6\cf0 * \cf2 1\cf0 >\cf6 $NULL\cf0  \cf2 2\cf0 >\cf6 $NULL\cf0 `;\
  \cf2 2005\cf0 	    \}\
  \cf2 2006\cf0 	    `rm \cf6 $OPATH\cf0 \{PAR\}\cf6 $STEP\cf0 .forw \cf2 1\cf0 >\cf6 $NULL\cf0  \cf2 2\cf0 >\cf6 $NULL\cf0 `;\
  \cf2 2007\cf0 	    `rm \cf6 $OPATH\cf0 \{PAR\}\cf6 $STEP\cf0 .back \cf2 1\cf0 >\cf6 $NULL\cf0  \cf2 2\cf0 >\cf6 $NULL\cf0 `;\
  \cf2 2008\cf0 	\
  \cf2 2009\cf0 	    
\f1\i \cf3 #here we set the mdp file ini vel type as it may change every step 
\f0\i0 \cf0 \
  \cf2 2010\cf0 	    
\f2\b my
\f0\b0  \cf6 $mdpf\cf0  = \cf4 "$PATH\{TPSRUNF\}/run.mdp"\cf0 ;\
  \cf2 2011\cf0 	    
\f2\b my
\f0\b0  \cf6 $mdpb\cf0  = \cf4 "$PATH\{TPSRUNB\}/run.mdp"\cf0 ;\
  \cf2 2012\cf0 	    
\f2\b if
\f0\b0 ( \cf6 $TPS\cf0 \{SHOOTING\}\{TYPE\} =~ 
\f2\b /1WAY/
\f0\b0  )\
  \cf2 2013\cf0 	    \{	\
  \cf2 2014\cf0 		
\f2\b if
\f0\b0 ( \cf6 $TPS\cf0 \{SHOOT\}\{INI\}\{VEL\}\{_1WAY\} =~ 
\f2\b /RANDOM/
\f0\b0  )\
  \cf2 2015\cf0 		\{\
  \cf2 2016\cf0 		    &\cf5 set_mdp_value\cf0 (\cf6 $mdpf\cf0 ,\cf4 "gen_vel"\cf0 ,      \cf4 "yes"\cf0 );\
  \cf2 2017\cf0 		    &\cf5 set_mdp_value\cf0 (\cf6 $mdpf\cf0 ,\cf4 "gen_seed"\cf0 ,     \cf4 "-1"\cf0  );\
  \cf2 2018\cf0 		    &\cf5 set_mdp_value\cf0 (\cf6 $mdpb\cf0 ,\cf4 "gen_vel"\cf0 ,      \cf4 "yes"\cf0 );\
  \cf2 2019\cf0 		    &\cf5 set_mdp_value\cf0 (\cf6 $mdpb\cf0 ,\cf4 "gen_seed"\cf0 ,     \cf4 "-1"\cf0  );\
  \cf2 2020\cf0 		\}\
  \cf2 2021\cf0 		
\f2\b if
\f0\b0 ( \cf6 $TPS\cf0 \{SHOOT\}\{INI\}\{VEL\}\{_1WAY\} =~ 
\f2\b /UNCHANGED/
\f0\b0  )\
  \cf2 2022\cf0 		\{\
  \cf2 2023\cf0 		    &\cf5 set_mdp_value\cf0 (\cf6 $mdpf\cf0 ,\cf4 "gen_vel"\cf0 ,      \cf4 "no"\cf0 );\
  \cf2 2024\cf0 		    &\cf5 set_mdp_value\cf0 (\cf6 $mdpf\cf0 ,\cf4 "gen_seed"\cf0 ,     \cf4 "0"\cf0  );\
  \cf2 2025\cf0 		    &\cf5 set_mdp_value\cf0 (\cf6 $mdpb\cf0 ,\cf4 "gen_vel"\cf0 ,      \cf4 "no"\cf0 );\
  \cf2 2026\cf0 		    &\cf5 set_mdp_value\cf0 (\cf6 $mdpb\cf0 ,\cf4 "gen_seed"\cf0 ,     \cf4 "0"\cf0  );\
  \cf2 2027\cf0 		\}\
  \cf2 2028\cf0 		\
  \cf2 2029\cf0 	    \}\
  \cf2 2030\cf0 	    \
  \cf2 2031\cf0 	    
\f2\b if
\f0\b0 ( \cf6 $TPS\cf0 \{SHOOTING\}\{TYPE\} =~ 
\f2\b /2WAY/
\f0\b0  )\
  \cf2 2032\cf0 	    \{\
  \cf2 2033\cf0 		
\f2\b if
\f0\b0 ( \cf6 $TPS\cf0 \{SHOOT\}\{INI\}\{VEL\}\{_2WAY\} =~ 
\f2\b /RANDOM/
\f0\b0  )\
  \cf2 2034\cf0 		\{\
  \cf2 2035\cf0 		    &\cf5 set_mdp_value\cf0 (\cf6 $mdpf\cf0 ,\cf4 "gen_vel"\cf0 ,      \cf4 "yes"\cf0 );\
  \cf2 2036\cf0 		    &\cf5 set_mdp_value\cf0 (\cf6 $mdpf\cf0 ,\cf4 "gen_seed"\cf0 ,     \cf4 "-1"\cf0  );\
  \cf2 2037\cf0 		    &\cf5 set_mdp_value\cf0 (\cf6 $mdpb\cf0 ,\cf4 "gen_vel"\cf0 ,      \cf4 "no"\cf0 );\
  \cf2 2038\cf0 		    &\cf5 set_mdp_value\cf0 (\cf6 $mdpb\cf0 ,\cf4 "gen_seed"\cf0 ,     \cf4 "0"\cf0  );\
  \cf2 2039\cf0 		\}\
  \cf2 2040\cf0 		
\f2\b if
\f0\b0 ( \cf6 $TPS\cf0 \{SHOOT\}\{INI\}\{VEL\}\{_2WAY\} =~ 
\f2\b /UNCHANGED/
\f0\b0  )\
  \cf2 2041\cf0 		\{\
  \cf2 2042\cf0 		    &\cf5 set_mdp_value\cf0 (\cf6 $mdpf\cf0 ,\cf4 "gen_vel"\cf0 ,      \cf4 "no"\cf0 );\
  \cf2 2043\cf0 		    &\cf5 set_mdp_value\cf0 (\cf6 $mdpf\cf0 ,\cf4 "gen_seed"\cf0 ,     \cf4 "0"\cf0  );\
  \cf2 2044\cf0 		    &\cf5 set_mdp_value\cf0 (\cf6 $mdpb\cf0 ,\cf4 "gen_vel"\cf0 ,      \cf4 "no"\cf0 );\
  \cf2 2045\cf0 		    &\cf5 set_mdp_value\cf0 (\cf6 $mdpb\cf0 ,\cf4 "gen_seed"\cf0 ,     \cf4 "0"\cf0  );\
  \cf2 2046\cf0 		\}\
  \cf2 2047\cf0 	    \}\
  \cf2 2048\cf0 	    \
  \cf2 2049\cf0 	\
  \cf2 2050\cf0 	    
\f2\b print
\f0\b0  RED, \cf4 ">>>>prepare_new_run: END (DEBUG)<<<<<<<<<<<\cf7 \\n\cf4 "\cf0 , RESET 
\f2\b if
\f0\b0  \cf6 $DEBUG_ON\cf0 ;\
  \cf2 2051\cf0 	\}\
\
\
   \cf2 348\cf0 	&\cf5 init_step_variables\cf0 ();                               
\f1\i \cf3 #<<< set values for the global variables that change with new step 
\f0\i0 \cf0 \
   \cf2 936\cf0 	
\f2\b sub
\f0\b0  \cf5 init_step_variables\cf0 ()\
   \cf2 937\cf0 	\{\
   \cf2 938\cf0 	    
\f2\b print
\f0\b0  RED, \cf4 "\cf7 \\n\cf4 >>>>init_step_variables: BEGIN (DEBUG)<<<<<<<<<\cf7 \\n\cf4 "\cf0 , RESET 
\f2\b if
\f0\b0  \cf6 $DEBUG_ON\cf0 ;\
   \cf2 939\cf0 	    \cf6 $T_START_CYCLE\cf0  = \cf5 time\cf0 ;\
   \cf2 940\cf0 	    \
   \cf2 941\cf0 	    
\f2\b my
\f0\b0  \cf6 @pars\cf0  = `ls -\cf2 1\cf0  \cf6 $OPATH\cf0 \{PAR\}/*.par`; chomp \cf6 @pars\cf0 ;\
   \cf2 942\cf0 	    
\f2\b my
\f0\b0  \cf6 $par_0\cf0  = \cf6 $pars\cf0 [\cf2 0\cf0 ];\
   \cf2 943\cf0 	    die \cf4 "$par_0 doesnt exist"\cf0  
\f2\b if
\f0\b0  !-e \cf6 $par_0\cf0 ;\
   \cf2 944\cf0 	   \
   \cf2 945\cf0 	    
\f1\i \cf3 #$N_0 = `wc -l $OPATH\{PAR\}/$step6.par | awk \\'\{print \\$1\}\\'`-1;
\f0\i0 \cf0 \
   \cf2 946\cf0 	    
\f2\b my
\f0\b0  \cf6 $awk_col\cf0  = \cf6 $BIAS\cf0 \{PAR\} + \cf2 1\cf0 ;\
   \cf2 947\cf0 	\
   \cf2 948\cf0 	    
\f1\i \cf3 ##############################################################
\f0\i0 \cf0 \
   \cf2 949\cf0 	    
\f2\b my
\f0\b0  \cf6 $prev_par\cf0  = \cf6 $OPATH\cf0 \{PAR\}.&\cf5 numtostr\cf0 (\cf6 $STEP\cf0 -\cf2 1\cf0 ,\cf2 6\cf0 ).\cf4 ".par"\cf0 ;\
   \cf2 950\cf0 	    
\f2\b my
\f0\b0  \cf6 @lambda_prev\cf0  = split \cf4 "\cf7 \\n\cf4 "\cf0 , `awk \cf7 \\'\cf0 \{
\f2\b print
\f0\b0  \\$\cf6 $awk_col\cf0 \}\cf7 \\'\cf0  \cf6 $prev_par\cf0 `;\
   \cf2 951\cf0 	    chomp \cf6 @lambda_prev\cf0 ; shift \cf6 @lambda_prev\cf0 ; \
   \cf2 952\cf0 	    
\f2\b my
\f0\b0  \cf6 $SW_prev\cf0  = &\cf5 SW\cf0 (\\\cf6 @lambda_prev\cf0 );\
   \cf2 953\cf0 	    
\f2\b my
\f0\b0  \cf6 $alpha\cf0 ;\
   \cf2 954\cf0 	    
\f2\b do
\f0\b0 \{ \cf6 $alpha\cf0  = \cf5 rand\cf0 () \} 
\f2\b while
\f0\b0  (\cf6 $alpha\cf0 ==\cf2 0\cf0 );\
   \cf2 955\cf0 	    
\f1\i \cf3 ##############################################################
\f0\i0 \cf0 \
   \cf2 956\cf0 	    \cf6 $SW_MAX\cf0  = \cf6 $SW_prev\cf0  / \cf6 $alpha\cf0 ;  \
   \cf2 957\cf0 	    
\f1\i \cf3 ##############################################################
\f0\i0 \cf0 \
   \cf2 958\cf0 	\
   \cf2 959\cf0 	\
   \cf2 960\cf0 	\
   \cf2 961\cf0 	    \cf6 $RES\cf0 \{F\}=\cf4 "f"\cf0 ; \cf6 $RES\cf0 \{B\}=\cf4 "f"\cf0 ;   \
   \cf2 962\cf0 	    \
   \cf2 963\cf0 	    \cf6 $ACCEPTED\cf0  = \cf4 ""\cf0 ;\
   \cf2 964\cf0 	        \
   \cf2 965\cf0 	    
\f1\i \cf3 #setting step dependent file names###
\f0\i0 \cf0 \
   \cf2 966\cf0 	    \cf6 $FILE\cf0 \{XYF\} = \cf4 "$OPATH\{PAR\}$STEP.forw"\cf0 ;\
   \cf2 967\cf0 	    \cf6 $FILE\cf0 \{XYB\} = \cf4 "$OPATH\{PAR\}$STEP.back"\cf0 ;\
   \cf2 968\cf0 	    
\f1\i \cf3 #####################################
\f0\i0 \cf0 \
   \cf2 969\cf0 	    
\f2\b print
\f0\b0  RED, \cf4 ">>>>init_step_variables: END (DEBUG)<<<<<<<<<<<\cf7 \\n\cf4 "\cf0 , RESET 
\f2\b if
\f0\b0  \cf6 $DEBUG_ON\cf0 ;\
   \cf2 970\cf0 	\}\
\
\
   \cf2 349\cf0 	
\f2\b if
\f0\b0 (\cf6 $TPS\cf0 \{SHOOTING\}\{TYPE\}=~
\f2\b /1WAY/
\f0\b0 )\
   \cf2 350\cf0 	\{\
   \cf2 351\cf0 	    
\f2\b my
\f0\b0  \cf6 $p\cf0  = \cf5 rand\cf0 (); \
   \cf2 352\cf0 	    
\f2\b if
\f0\b0 (\cf6 $p\cf0 <\cf2 0.5\cf0 )\{ \cf6 $INIT_FORW_BACK\cf0 =\cf2 0\cf0  \}\
   \cf2 353\cf0 	    
\f2\b else
\f0\b0  \{ \cf6 $INIT_FORW_BACK\cf0 =\cf2 1\cf0 \}                         
\f1\i \cf3 #<<< decide if we shoot forward=1/backward=0
\f0\i0 \cf0 \
   \cf2 354\cf0 	    
\f2\b print
\f0\b0  \cf4 "SHOOTING "\cf0 .(\cf6 $INIT_FORW_BACK\cf0 ==\cf2 1\cf0  ? \cf4 "FORWARD "\cf0  : \cf4 "BACKWARD "\cf0  );\
   \cf2 355\cf0 	    printf \cf4 "(rand = %.4f)\cf7 \\n\cf4 "\cf0 , \cf6 $p\cf0 ;\
   \cf2 356\cf0 	\}\
   \cf2 357\cf0 	
\f2\b print
\f0\b0  \cf4 "\cf7 \\n\cf4 "\cf0 ;\
   \cf2 358\cf0 	\
   \cf2 359\cf0 	&\cf5 _info_step_variables\cf0 ();                              
\f1\i \cf3 #<<< print values of the variables for checkup
\f0\i0 \cf0 \
   \cf2 918\cf0 	
\f2\b sub
\f0\b0  \cf5 _info_step_variables\cf0 ()\
   \cf2 919\cf0 	\{\
   \cf2 920\cf0 	    
\f2\b my
\f0\b0  \cf6 $line\cf0  = \cf4 '-'\cf0  x \cf5 length\cf0 (\cf6 $FILE\cf0 \{XYB\});\
   \cf2 921\cf0 	    
\f2\b print
\f0\b0  RED, \cf4 "--------[ step variables ]$line\cf7 \\n\cf4 "\cf0 ,\cf5 RESET\cf0 ;\
   \cf2 922\cf0 	    
\f2\b print
\f0\b0  \cf4 "\cf7 \\t\cf4 STEP               = $STEP\cf7 \\n\cf4 "\cf0 ;\
   \cf2 923\cf0 	    
\f2\b print
\f0\b0  \cf4 "\cf7 \\t\cf4 CUT_G              = $CUT_G\cf7 \\n\cf4 "\cf0 ;\
   \cf2 924\cf0 	    
\f2\b print
\f0\b0  \cf4 "\cf7 \\t\cf4 N_0                = $N_0\cf7 \\n\cf4 "\cf0 ;\
   \cf2 925\cf0 	    
\f2\b print
\f0\b0  \cf4 "\cf7 \\t\cf4 NMAX               = $NMAX\cf7 \\n\cf4 "\cf0 ;\
   \cf2 926\cf0 	   printf \cf4 "\cf7 \\t\cf4 SW_0               = %.2f\cf7 \\n\cf4 "\cf0 , \cf6 $SW_0\cf0 ;\
   \cf2 927\cf0 	   printf \cf4 "\cf7 \\t\cf4 SW_MAX             = %.2f\cf7 \\n\cf4 "\cf0 , \cf6 $SW_MAX\cf0 ;\
   \cf2 928\cf0 	    
\f2\b print
\f0\b0  \cf4 "\cf7 \\t\cf4 \{RESB,RESF\}        = \{$RES\{B\},$RES\{F\}\}\cf7 \\n\cf4 "\cf0 ;\
   \cf2 929\cf0 	    
\f2\b print
\f0\b0  \cf4 "\cf7 \\t\cf4 ACCEPTED           = $ACCEPTED\cf7 \\n\cf4 "\cf0 ;\
   \cf2 930\cf0 	    
\f2\b print
\f0\b0  \cf4 "\cf7 \\t\cf4 STORED             = $STORED\cf7 \\n\cf4 "\cf0 ;\
   \cf2 931\cf0 	    
\f2\b print
\f0\b0  \cf4 "\cf7 \\t\cf4 INIT_FORW_BACK     = $INIT_FORW_BACK\cf7 \\n\cf4 "\cf0 ;\
   \cf2 932\cf0 	    
\f2\b print
\f0\b0  \cf4 "\cf7 \\t\cf4 STORED_TIME_DIRECT = $STORED_TIME_DIRECT\cf7 \\n\cf4 "\cf0 ;\
   \cf2 933\cf0 	    
\f2\b print
\f0\b0  RED, \cf4 "--------------------------$line\cf7 \\n\cf4 "\cf0 ,\cf5 RESET\cf0 ;\
   \cf2 934\cf0 	\} \
\
\
   \cf2 361\cf0 	&\cf5 start_runs\cf0 ();                                        
\f1\i \cf3 #<<< start forw/back runs respectively of $INIT_FORW_BACK
\f0\i0 \cf0 \
Until line \cf2 1585\cf0 \
--------------------------------------------------\
-forward forward.tpr -backward backward.tpr\

\f2\b if
\f0\b0  FORWARD:\
    MD forward.tpr\

\f2\b if
\f0\b0  BACKWARD\
    MD backward.tpr\
--------------------------------------------------\
  \cf2 1436\cf0 	
\f2\b sub
\f0\b0  \cf5 start_runs\cf0 ()\
  \cf2 1437\cf0 	\{\
  \cf2 1438\cf0 	    
\f2\b print
\f0\b0  RED, \cf4 "\cf7 \\n\cf4 >>>>start_runs: BEGIN (DEBUG)<<<<<<<<<\cf7 \\n\cf4 "\cf0 , RESET 
\f2\b if
\f0\b0  \cf6 $DEBUG_ON\cf0 ;\
  \cf2 1439\cf0 	    
\f2\b my
\f0\b0  \cf6 $ERROR_STATUS\cf0  = \cf2 0\cf0 ;\
  \cf2 1440\cf0 	    \
  \cf2 1441\cf0 	    
\f2\b if
\f0\b0 ( \cf6 $INIT_FORW_BACK\cf0  == \cf2 1\cf0  || \cf6 $TPS\cf0 \{SHOOTING\}\{TYPE\}=~
\f2\b /2WAY/
\f0\b0  )\
  \cf2 1442\cf0 	    \{\
  \cf2 1443\cf0 		
\f1\i \cf3 #GROMPP FORWARD#######################################
\f0\i0 \cf0 \
  \cf2 1444\cf0 		
\f2\b print
\f0\b0  \cf4 "grompping forward run... "\cf0 ;\
  \cf2 1445\cf0 		chdir \cf6 $PATH\cf0 \{TPSRUNF\};\
  \cf2 1446\cf0 		
\f2\b my
\f0\b0  \cf6 $input\cf0   = \cf4 "-f run.mdp -c start.gro -p topol.top"\cf0 ;\
  \cf2 1447\cf0 		
\f2\b my
\f0\b0  \cf6 $output\cf0  = \cf4 "-o run.tpr"\cf0 ;\
  \cf2 1448\cf0 		
\f2\b my
\f0\b0  \cf6 $stream\cf0  = \cf4 "1>grompp.out 2>grompp.err"\cf0 ;\
  \cf2 1449\cf0 		\
  \cf2 1450\cf0 		system \cf4 "$PATH\{GROMACS\}/grompp  $input $output $stream"\cf0 ;\
  \cf2 1451\cf0 	\
  \cf2 1452\cf0 	
\f1\i \cf3 #	print &grompp("$input $output $stream");
\f0\i0 \cf0 \
  \cf2 1453\cf0 	
\f1\i \cf3 #	system "cp grompp.err grompp.out $PATH\{MAIN\}";
\f0\i0 \cf0 \
  \cf2 1454\cf0 	\
  \cf2 1455\cf0 		\cf6 $ERROR_STATUS\cf0  = \cf4 "\{tprforw\}"\cf0  
\f2\b if
\f0\b0  ! -e \cf4 "run.tpr"\cf0 ;\
  \cf2 1456\cf0 		
\f2\b print
\f0\b0  \cf4 "done\cf7 \\n\cf4 "\cf0 ;\
  \cf2 1457\cf0 	    \}\
  \cf2 1458\cf0 	\
  \cf2 1459\cf0 	    
\f2\b if
\f0\b0 ( \cf6 $INIT_FORW_BACK\cf0  == \cf2 1\cf0  || \cf6 $TPS\cf0 \{SHOOTING\}\{TYPE\}=~
\f2\b /2WAY/
\f0\b0  )\
  \cf2 1460\cf0 	    \{\
  \cf2 1461\cf0 		
\f1\i \cf3 #MDRUN FORWARD#########################################
\f0\i0 \cf0 \
  \cf2 1462\cf0 		
\f2\b print
\f0\b0  \cf4 "starting forward mdrun... "\cf0 ;\
  \cf2 1463\cf0 		chdir \cf6 $PATH\cf0 \{TPSRUNF\};\
  \cf2 1464\cf0 		
\f2\b my
\f0\b0  \cf6 $input\cf0   = \cf4 "-s run.tpr"\cf0 ;\
  \cf2 1465\cf0 		
\f2\b my
\f0\b0  \cf6 $output\cf0  = \cf4 "-e run -o run -c after -g run -x run"\cf0 ;\
  \cf2 1466\cf0 		
\f2\b my
\f0\b0  \cf6 $stream\cf0  = \cf4 "1> mdrun.log 2> mdrun.err"\cf0 ;\
  \cf2 1467\cf0 	\
  \cf2 1468\cf0 		system \cf4 "srun $FILE\{MDRUN\} $input $output $stream &"\cf0 ;\
  \cf2 1469\cf0 		
\f1\i \cf3 #system "$FILE\{MDRUN\} $input $output $stream &";
\f0\i0 \cf0 \
  \cf2 1470\cf0 	\
  \cf2 1471\cf0 		
\f2\b my
\f0\b0  \cf6 $mdtest\cf0 =\cf2 0\cf0 ;\
  \cf2 1472\cf0 		
\f2\b my
\f0\b0  \cf6 $mdpsid\cf0 =-\cf2 1\cf0 ;\
  \cf2 1473\cf0 		
\f2\b while
\f0\b0 (\cf6 $mdtest\cf0 <\cf2 20\cf0  && \cf6 $mdpsid\cf0 ==-\cf2 1\cf0 )\
  \cf2 1474\cf0 		\{\
  \cf2 1475\cf0 		    \cf6 $mdpsid\cf0  = &\cf5 get_folder_psid\cf0 (\cf6 $PATH\cf0 \{TPSRUNF\});\
  \cf2 1476\cf0 		    \cf6 $mdtest\cf0 ++;\
  \cf2 1477\cf0 		    \cf5 sleep\cf0 (\cf2 4\cf0 );\
  \cf2 1478\cf0 		\}\
  \cf2 1479\cf0 		
\f2\b if
\f0\b0 (\cf6 $mdpsid\cf0  == -\cf2 1\cf0 )\
  \cf2 1480\cf0 		\{\
  \cf2 1481\cf0 		    
\f2\b print
\f0\b0  \cf4 "forw mdrun not successfull\cf7 \\n\cf4 "\cf0 ;\
  \cf2 1482\cf0 		    
\f2\b print
\f0\b0  \cf4 "---> CRASH\cf7 \\n\cf4 "\cf0 ;\
  \cf2 1483\cf0 		    `cp \cf6 $PATH\cf0 \{TPSRUNF\}/mdrun.* \cf6 $PATH\cf0 \{MAIN\} `;\
  \cf2 1484\cf0 		    `cp \cf6 $PATH\cf0 \{TPSRUNF\}/run.log \cf6 $PATH\cf0 \{MAIN\} `;\
  \cf2 1485\cf0 		    \cf5 exit\cf0 ;\
  \cf2 1486\cf0 		\}\
  \cf2 1487\cf0 		
\f2\b print
\f0\b0  \cf4 "done\cf7 \\n\cf4 "\cf0 ;\
  \cf2 1488\cf0 	    \}\
  \cf2 1489\cf0 	    \
  \cf2 1490\cf0 	\
  \cf2 1491\cf0 	    
\f1\i \cf3 #in case of the 2 way Shooting
\f0\i0 \cf0 \
  \cf2 1492\cf0 	    
\f1\i \cf3 #we have to set the back mdp file no to randomize them,
\f0\i0 \cf0 \
  \cf2 1493\cf0 	    
\f1\i \cf3 #initial gro file has to be extracted from the run.trr in run_forw. 
\f0\i0 \cf0 \
  \cf2 1494\cf0 	\
  \cf2 1495\cf0 	    
\f2\b if
\f0\b0 ( \cf6 $TPS\cf0 \{SHOOTING\}\{TYPE\}=~
\f2\b /2WAY/
\f0\b0  )\
  \cf2 1496\cf0 	    \{\
  \cf2 1497\cf0 		
\f2\b print
\f0\b0  \cf4 "reversing first forward frame..."\cf0 ;\
  \cf2 1498\cf0 		chdir \cf6 $PATH\cf0 \{TPSRUNB\};\
  \cf2 1499\cf0 	\
  \cf2 1500\cf0 		
\f1\i \cf3 #this is already done in prepare_new_run 
\f0\i0 \cf0 \
  \cf2 1501\cf0 		
\f1\i \cf3 #&set_mdp_value("run.mdp","gen_vel",      "no");
\f0\i0 \cf0 \
  \cf2 1502\cf0 		
\f1\i \cf3 #&set_mdp_value("run.mdp","gen_seed",     "0" );
\f0\i0 \cf0 \
  \cf2 1503\cf0 		\
  \cf2 1504\cf0 		`rm start.gro`;\
  \cf2 1505\cf0 		
\f2\b my
\f0\b0  \cf6 $tpr\cf0  = \cf4 "$PATH\{TPSRUNF\}/run.tpr"\cf0 ;\
  \cf2 1506\cf0 		
\f2\b my
\f0\b0  \cf6 $trr\cf0  = \cf4 "$PATH\{TPSRUNF\}/run.trr"\cf0 ;\
  \cf2 1507\cf0 		
\f2\b my
\f0\b0  \cf6 $str\cf0  = \cf4 "1>ini.out 2>ini.err <<EOF\cf7 \\n\cf4 0\cf7 \\n\cf4 EOF"\cf0 ;\
  \cf2 1508\cf0 		`\cf6 $PATH\cf0 \{GROMACS\}/trjconv -s \cf6 $tpr\cf0  -f \cf6 $trr\cf0  -b \cf2 0\cf0  -e \cf2 0\cf0  -o ini.gro -ndec \cf6 $GRO_PREC $str\cf0 `;\
  \cf2 1509\cf0 		die \cf4 "problems with trjconv"\cf0  
\f2\b if
\f0\b0  !-e \cf4 "ini.gro"\cf0 ;\
  \cf2 1510\cf0 		\
  \cf2 1511\cf0 		
\f2\b my
\f0\b0  \cf6 %TMP\cf0 ; \cf6 $TMP\cf0 \{\cf2 0\cf0 \} = &\cf5 make_temp_dir_in\cf0 (\cf6 $PATH\cf0 \{TEMP\}); \
  \cf2 1512\cf0 		`cp ini.gro \cf6 $TMP\cf0 \{\cf2 0\cf0 \}`;\
  \cf2 1513\cf0 		
\f2\b my
\f0\b0  \cf6 $revgro\cf0  = &\cf5 reverse_gro\cf0 (\cf6 $TMP\cf0 \{\cf2 0\cf0 \},\cf4 "$TMP\{0\}ini.gro"\cf0 );\
  \cf2 1514\cf0 		chdir \cf6 $PATH\cf0 \{TPSRUNB\};\
  \cf2 1515\cf0 		`cp \cf6 $revgro\cf0  start.gro`;\
  \cf2 1516\cf0 	\
  \cf2 1517\cf0 		`rm ini.gro`;\
  \cf2 1518\cf0 		`rm -r \cf6 $TMP\cf0 \{\cf2 0\cf0 \}`;\
  \cf2 1519\cf0 		\
  \cf2 1520\cf0 		\
  \cf2 1521\cf0 	    \}\
  \cf2 1522\cf0 	\
  \cf2 1523\cf0 	\
  \cf2 1524\cf0 	    
\f2\b if
\f0\b0 ( \cf6 $INIT_FORW_BACK\cf0  == \cf2 0\cf0  ||  \cf6 $TPS\cf0 \{SHOOTING\}\{TYPE\}=~
\f2\b /2WAY/
\f0\b0  )\
  \cf2 1525\cf0 	    \{\
  \cf2 1526\cf0 		
\f1\i \cf3 #GROMPP BACKWARD######################################
\f0\i0 \cf0 \
  \cf2 1527\cf0 		
\f2\b print
\f0\b0  \cf4 "grompping backward run... "\cf0 ;\
  \cf2 1528\cf0 		chdir \cf6 $PATH\cf0 \{TPSRUNB\};\
  \cf2 1529\cf0 		
\f2\b my
\f0\b0  \cf6 $input\cf0   = \cf4 "-f run.mdp -c start.gro -p topol.top"\cf0 ;\
  \cf2 1530\cf0 		
\f2\b my
\f0\b0  \cf6 $output\cf0  = \cf4 "-o run.tpr"\cf0 ;\
  \cf2 1531\cf0 		
\f2\b my
\f0\b0  \cf6 $stream\cf0  = \cf4 "1>grompp.out 2>grompp.err"\cf0 ;\
  \cf2 1532\cf0 	\
  \cf2 1533\cf0 		system \cf4 "$PATH\{GROMACS\}/grompp $input $output $stream"\cf0 ;\
  \cf2 1534\cf0 	\
  \cf2 1535\cf0 	
\f1\i \cf3 #@	print &grompp("$input $output $stream");
\f0\i0 \cf0 \
  \cf2 1536\cf0 	
\f1\i \cf3 #	system "cp grompp.err grompp.out $PATH\{MAIN\}";
\f0\i0 \cf0 \
  \cf2 1537\cf0 	\
  \cf2 1538\cf0 		\cf6 $ERROR_STATUS\cf0  = \cf4 "\{tprback\}"\cf0  
\f2\b if
\f0\b0  ! -e \cf4 "run.tpr"\cf0 ;\
  \cf2 1539\cf0 		
\f2\b print
\f0\b0  \cf4 "done\cf7 \\n\cf4 "\cf0 ;\
  \cf2 1540\cf0 	    \}\
  \cf2 1541\cf0 	\
  \cf2 1542\cf0 	    
\f2\b if
\f0\b0 ( \cf6 $ERROR_STATUS\cf0 =~
\f2\b /(tprback|tprforw)/
\f0\b0  )\
  \cf2 1543\cf0 	    \{\
  \cf2 1544\cf0 		
\f2\b print
\f0\b0  \cf4 "grompping was not successfull :: $1\cf7 \\n\cf4 "\cf0 ;\
  \cf2 1545\cf0 		
\f2\b print
\f0\b0  \cf4 "---> CRASH\cf7 \\n\cf4 "\cf0 ;\
  \cf2 1546\cf0 		\cf5 exit\cf0 ;\
  \cf2 1547\cf0 		\
  \cf2 1548\cf0 	    \}\
  \cf2 1549\cf0 	\
  \cf2 1550\cf0 	    \
  \cf2 1551\cf0 	    
\f2\b if
\f0\b0 ( \cf6 $INIT_FORW_BACK\cf0  == \cf2 0\cf0  || \cf6 $TPS\cf0 \{SHOOTING\}\{TYPE\}=~
\f2\b /2WAY/
\f0\b0  )\
  \cf2 1552\cf0 	    \{\
  \cf2 1553\cf0 		
\f1\i \cf3 #MDRUN BACKWARD########################################
\f0\i0 \cf0 \
  \cf2 1554\cf0 		
\f2\b print
\f0\b0  \cf4 "starting backward mdrun... "\cf0 ;\
  \cf2 1555\cf0 		chdir \cf6 $PATH\cf0 \{TPSRUNB\};\
  \cf2 1556\cf0 		
\f2\b my
\f0\b0  \cf6 $input\cf0   = \cf4 "-s run.tpr"\cf0 ;\
  \cf2 1557\cf0 		
\f2\b my
\f0\b0  \cf6 $output\cf0  = \cf4 "-e run -o run -c after -g run -x run"\cf0 ;\
  \cf2 1558\cf0 		
\f2\b my
\f0\b0  \cf6 $stream\cf0  = \cf4 "1> mdrun.log 2> mdrun.err"\cf0 ;\
  \cf2 1559\cf0 	\
  \cf2 1560\cf0 		system \cf4 "srun $FILE\{MDRUN\} $input $output $stream &"\cf0 ;\
  \cf2 1561\cf0 		
\f1\i \cf3 #system "$FILE\{MDRUN\} $input $output $stream &";
\f0\i0 \cf0 \
  \cf2 1562\cf0 	\
  \cf2 1563\cf0 		
\f2\b my
\f0\b0  \cf6 $mdtest\cf0 =\cf2 0\cf0 ;\
  \cf2 1564\cf0 		
\f2\b my
\f0\b0  \cf6 $mdpsid\cf0 =-\cf2 1\cf0 ;\
  \cf2 1565\cf0 		
\f2\b while
\f0\b0 (\cf6 $mdtest\cf0 <\cf2 20\cf0  && \cf6 $mdpsid\cf0 ==-\cf2 1\cf0 )\
  \cf2 1566\cf0 		\{\
  \cf2 1567\cf0 		    \cf6 $mdpsid\cf0  = &\cf5 get_folder_psid\cf0 (\cf6 $PATH\cf0 \{TPSRUNB\});\
  \cf2 1568\cf0 		    \cf6 $mdtest\cf0 ++;\
  \cf2 1569\cf0 		    \cf5 sleep\cf0 (\cf2 4\cf0 );\
  \cf2 1570\cf0 		\}\
  \cf2 1571\cf0 		
\f2\b if
\f0\b0 (\cf6 $mdpsid\cf0  == -\cf2 1\cf0 )\
  \cf2 1572\cf0 		\{\
  \cf2 1573\cf0 		    
\f2\b print
\f0\b0  \cf4 "back mdrun not successfull\cf7 \\n\cf4 "\cf0 ;\
  \cf2 1574\cf0 		    
\f2\b print
\f0\b0  \cf4 "---> CRASH\cf7 \\n\cf4 "\cf0 ;\
  \cf2 1575\cf0 		    \cf5 exit\cf0 ;\
  \cf2 1576\cf0 		    `cp \cf6 $PATH\cf0 \{TPSRUNF\}/mdrun.* \cf6 $PATH\cf0 \{MAIN\} `;\
  \cf2 1577\cf0 		    `cp \cf6 $PATH\cf0 \{TPSRUNF\}/run.log \cf6 $PATH\cf0 \{MAIN\} `;\
  \cf2 1578\cf0 		\}\
  \cf2 1579\cf0 	    \
  \cf2 1580\cf0 		
\f2\b print
\f0\b0  \cf4 "done\cf7 \\n\cf4 "\cf0 ;\
  \cf2 1581\cf0 	    \}\
  \cf2 1582\cf0 	    
\f1\i \cf3 #FINISHED###############################################
\f0\i0 \cf0 \
  \cf2 1583\cf0 	    chdir \cf6 $PATH\cf0 \{MAIN\};\
  \cf2 1584\cf0 	    
\f2\b print
\f0\b0  RED, \cf4 ">>>>start_runs: END (DEBUG)<<<<<<<<<<<\cf7 \\n\cf4 "\cf0 , RESET 
\f2\b if
\f0\b0  \cf6 $DEBUG_ON\cf0 ;\
  \cf2 1585\cf0 	\}\
\
The simulations run in the background....\
\
   \cf2 366\cf0 	
\f1\i \cf3 #######################################
\f0\i0 \cf0 \
   \cf2 367\cf0 	
\f1\i \cf3 #                                     #
\f0\i0 \cf0 \
   \cf2 368\cf0 	
\f1\i \cf3 #           MD LOOP                   #
\f0\i0 \cf0 \
   \cf2 369\cf0 	
\f1\i \cf3 #                                     #
\f0\i0 \cf0 \
   \cf2 370\cf0 	
\f1\i \cf3 #######################################
\f0\i0 \cf0 \
   \cf2 371\cf0 	
\f2\b my
\f0\b0  (\cf6 $stf\cf0 , \cf6 $stb\cf0 )  = (\cf2 0\cf0 , \cf2 0\cf0 );                            \
   \cf2 372\cf0 	
\f2\b do
\f0\b0 \{\
   \cf2 373\cf0 	    die \cf4 "DIE in folder"\cf0  
\f2\b if
\f0\b0  -e \cf4 "DIE"\cf0 ;\
   \cf2 374\cf0 	    \
   \cf2 375\cf0 	    
\f1\i \cf3 #reload external variables#####################################################
\f0\i0 \cf0 \
   \cf2 376\cf0 	    &\cf5 init_CONF_from_file\cf0 (\cf6 $FILE\cf0 \{CONF\}); \
   \cf2 377\cf0 	    \cf6 $UPD\cf0                 =    &\cf5 value\cf0 (\cf4 "update.interval"\cf0 );\
   \cf2 378\cf0 	    \cf6 $MAX_SIMULT_UPDATES\cf0  =    &\cf5 value\cf0 (\cf4 "max.simult.updates"\cf0 );\
   \cf2 379\cf0 	\
   \cf2 380\cf0 	    
\f1\i \cf3 #updating queue#################################################################
\f0\i0 \cf0 \
   \cf2 381\cf0 	    
\f2\b my
\f0\b0  \cf6 $T1\cf0  = \cf5 time\cf0 ; \
   \cf2 382\cf0 	    \cf5 sleep\cf0 (\cf6 $UPD\cf0 ); \
   \cf2 383\cf0 	    
\f1\i \cf3 #my $dummy = &queue();
\f0\i0 \cf0 \
   \cf2 384\cf0 	    
\f2\b my
\f0\b0  \cf6 $T2\cf0  = \cf5 time\cf0 ; \
   \cf2 385\cf0 	\
   \cf2 386\cf0 	    open  UPD_BREAKS,\cf4 ">>$FILE\{UPD_BREAKS\}"\cf0 ;\
   \cf2 387\cf0 	    
\f2\b print
\f0\b0  \cf5 UPD_BREAKS\cf0  (\cf6 $T2\cf0 -\cf6 $T1\cf0 ).\cf4 "\cf7 \\n\cf4 "\cf0 ;\
   \cf2 388\cf0 	    close \cf5 UPD_BREAKS\cf0 ;\
   \cf2 389\cf0 	    \
   \cf2 390\cf0 	    
\f1\i \cf3 #`echo 1 > $CURR_UPD_FOLDER/$dummy`;  #add dummy file to the queue folder
\f0\i0 \cf0 \
\
\
   \cf2 391\cf0 	    &\cf5 update_xy\cf0 ();\
  \cf2 1372\cf0 	
\f2\b sub
\f0\b0  \cf5 update_xy\cf0 ()\
  \cf2 1373\cf0 	\{   \
  \cf2 1374\cf0 	    
\f2\b print
\f0\b0  RED, \cf4 "\cf7 \\n\cf4 >>>>update_xy: BEGIN (DEBUG)<<<<<<<<<\cf7 \\n\cf4 "\cf0 , RESET 
\f2\b if
\f0\b0  \cf6 $DEBUG_ON\cf0 ;\
  \cf2 1375\cf0 	    
\f1\i \cf3 #FIRST FORWARD#################################
\f0\i0 \cf0 \
  \cf2 1376\cf0 	    \
  \cf2 1377\cf0 	    
\f1\i \cf3 #IMPORTANT.
\f0\i0 \cf0 \
  \cf2 1378\cf0 	    
\f1\i \cf3 #this procedure also measures updating time, and if it is higher 
\f0\i0 \cf0 \
  \cf2 1379\cf0 	    
\f1\i \cf3 #than update frequency, the update frequency is adequatly tuned.
\f0\i0 \cf0 \
  \cf2 1380\cf0 	    \
  \cf2 1381\cf0 	    
\f2\b my
\f0\b0  \cf6 $T1\cf0  = \cf5 time\cf0 ;\
  \cf2 1382\cf0 	    \
  \cf2 1383\cf0 	    \
  \cf2 1384\cf0 	    
\f2\b if
\f0\b0 (!&\cf5 stopped\cf0 (\cf6 $PATH\cf0 \{TPSRUNF\}))\
  \cf2 1385\cf0 	    \{\
  \cf2 1386\cf0 	\
  \cf2 1387\cf0 		
\f2\b my
\f0\b0  \cf6 $trr\cf0  = \cf4 "$PATH\{TPSRUNF\}run.trr"\cf0 ;\
  \cf2 1388\cf0 		
\f1\i \cf3 #my $scr = "$SCRIPT\{UPDATE_XY\} $PATH\{TPSRUNF\} $STEP";
\f0\i0 \cf0 \
  \cf2 1389\cf0 		
\f2\b my
\f0\b0  \cf6 $scr\cf0  = \cf4 "$SCRIPT\{UPDATE_XY\} $trr $STEP forw"\cf0 ;\
  \cf2 1390\cf0 	
\f1\i \cf3 #	my $out = "$PATH\{TPSRUNF\}update.out";
\f0\i0 \cf0 \
  \cf2 1391\cf0 		
\f2\b my
\f0\b0  \cf6 $out\cf0  = \cf4 "$OPATH\{LOG\}updatef.out"\cf0 ;\
  \cf2 1392\cf0 	
\f1\i \cf3 #	my $err = "$PATH\{TPSRUNF\}update.err";
\f0\i0 \cf0 \
  \cf2 1393\cf0 		
\f2\b my
\f0\b0  \cf6 $err\cf0  = \cf4 "$OPATH\{LOG\}updatef.err"\cf0 ;\
  \cf2 1394\cf0 		\cf6 $scr\cf0 .=\cf4 " 1>$out 2>$err"\cf0 ;\
  \cf2 1395\cf0 		
\f1\i \cf3 #print "update cmd = $scr\\n";
\f0\i0 \cf0 \
Calculate \cf5 parameters\cf0  (
\f2\b and do
\f0\b0  a lot of silly things)\
  \cf2 1396\cf0 		system \cf6 $scr\cf0 ;    \
  \cf2 1397\cf0 	\
  \cf2 1398\cf0 		\
  \cf2 1399\cf0 		
\f1\i \cf3 #dummy XYB file only if 1WAY!
\f0\i0 \cf0 \
  \cf2 1400\cf0 		
\f2\b if
\f0\b0 ( \cf6 $TPS\cf0 \{SHOOTING\}\{TYPE\} =~ 
\f2\b /1WAY/
\f0\b0  )\
  \cf2 1401\cf0 		\{\
  \cf2 1402\cf0 		    open XYB, \cf4 ">$FILE\{XYB\}"\cf0 ;  
\f2\b print
\f0\b0  XYB \cf4 " "\cf0 ;  close \cf5 XYB\cf0 ;\
  \cf2 1403\cf0 		\}\
  \cf2 1404\cf0 		\
  \cf2 1405\cf0 	    \}\
  \cf2 1406\cf0 	    
\f2\b else
\f0\b0  \{  \}\
  \cf2 1407\cf0 	 \
  \cf2 1408\cf0 	   \
  \cf2 1409\cf0 	    
\f2\b if
\f0\b0 (!&\cf5 stopped\cf0 (\cf6 $PATH\cf0 \{TPSRUNB\}))\
  \cf2 1410\cf0 	    \{\
  \cf2 1411\cf0 	\
  \cf2 1412\cf0 		
\f2\b my
\f0\b0  \cf6 $trr\cf0  = \cf4 "$PATH\{TPSRUNB\}run.trr"\cf0 ;\
  \cf2 1413\cf0 		
\f1\i \cf3 #my $scr = "$SCRIPT\{UPDATE_XY\} $PATH\{TPSRUNB\} $STEP";
\f0\i0 \cf0 \
  \cf2 1414\cf0 		
\f2\b my
\f0\b0  \cf6 $scr\cf0  = \cf4 "$SCRIPT\{UPDATE_XY\} $trr $STEP back"\cf0 ;\
  \cf2 1415\cf0 		
\f2\b my
\f0\b0  \cf6 $out\cf0  = \cf4 "$OPATH\{LOG\}updateb.out"\cf0 ;\
  \cf2 1416\cf0 	
\f1\i \cf3 #	my $out = "$PATH\{TPSRUNB\}update.out";
\f0\i0 \cf0 \
  \cf2 1417\cf0 		
\f2\b my
\f0\b0  \cf6 $err\cf0  = \cf4 "$OPATH\{LOG\}updateb.err"\cf0 ;\
  \cf2 1418\cf0 	
\f1\i \cf3 #	my $err = "$PATH\{TPSRUNB\}update.err";
\f0\i0 \cf0 \
  \cf2 1419\cf0 		\cf6 $scr\cf0 .=\cf4 " 1>$out 2>$err"\cf0 ;\
  \cf2 1420\cf0 		
\f1\i \cf3 #print "update cmd = $scr\\n";
\f0\i0 \cf0 \
Calculate \cf5 parameters\cf0  (
\f2\b and do
\f0\b0  a lot of silly things)\
  \cf2 1421\cf0 		system \cf6 $scr\cf0 ;    \
  \cf2 1422\cf0 	\
  \cf2 1423\cf0 	\
  \cf2 1424\cf0 		
\f1\i \cf3 #dummy XYF file 
\f0\i0 \cf0 \
  \cf2 1425\cf0 		
\f2\b if
\f0\b0 ( \cf6 $TPS\cf0 \{SHOOTING\}\{TYPE\} =~ 
\f2\b /1WAY/
\f0\b0  )\
  \cf2 1426\cf0 		\{\
  \cf2 1427\cf0 		    open XYF, \cf4 ">$FILE\{XYF\}"\cf0 ;  
\f2\b print
\f0\b0  XYF \cf4 " "\cf0 ;  close \cf5 XYF\cf0 ;\
  \cf2 1428\cf0 		\}\
  \cf2 1429\cf0 	    \}\
  \cf2 1430\cf0 	    
\f2\b else
\f0\b0  \{ \}\
  \cf2 1431\cf0 	\
  \cf2 1432\cf0 	    
\f2\b print
\f0\b0  RED, \cf4 ">>>>update_xy: END (DEBUG)<<<<<<<<<<<\cf7 \\n\cf4 "\cf0 , RESET 
\f2\b if
\f0\b0  \cf6 $DEBUG_ON\cf0 ;\
  \cf2 1433\cf0 	\}\
\
\
   \cf2 392\cf0 	    
\f1\i \cf3 #`rm $CURR_UPD_FOLDER/$dummy`;        #remove dummy marker 
\f0\i0 \cf0 \
   \cf2 393\cf0 	    
\f1\i \cf3 ################################################################################
\f0\i0 \cf0 \
   \cf2 394\cf0 	\
   \cf2 395\cf0 	    
\f1\i \cf3 #STATE tells what are final/initail states possible and PARAM gives their definitions 
\f0\i0 \cf0 \
   \cf2 396\cf0 	    \cf6 $RES\cf0 \{F\} = &\cf5 reached_fin_ini_state\cf0 (\cf6 $FILE\cf0 \{XYF\},\\\cf6 %STATE\cf0 ,\\\cf6 %PARAM\cf0 ) 
\f2\b if
\f0\b0  \cf6 $RES\cf0 \{F\}=~
\f2\b /f|0/
\f0\b0 ;\
   \cf2 397\cf0 	    \cf6 $RES\cf0 \{B\} = &\cf5 reached_fin_ini_state\cf0 (\cf6 $FILE\cf0 \{XYB\},\\\cf6 %STATE\cf0 ,\\\cf6 %PARAM\cf0 ) 
\f2\b if
\f0\b0  \cf6 $RES\cf0 \{B\}=~
\f2\b /f|0/
\f0\b0 ;\
   \cf2 398\cf0 	   \
   \cf2 399\cf0 	    
\f1\i \cf3 #print the current path in state representation
\f0\i0 \cf0 \
   \cf2 400\cf0 	  \
   \cf2 401\cf0 	    \
   \cf2 402\cf0 	\
   \cf2 403\cf0 	    
\f1\i \cf3 #check stopped/running status of both mdruns
\f0\i0 \cf0 \
   \cf2 404\cf0 	    \cf6 $stf\cf0  = &\cf5 stopped\cf0 (\cf6 $PATH\cf0 \{TPSRUNF\});\
   \cf2 405\cf0 	    \cf6 $stb\cf0  = &\cf5 stopped\cf0 (\cf6 $PATH\cf0 \{TPSRUNB\});\
   \cf2 406\cf0 	 \
   \cf2 407\cf0 	    
\f1\i \cf3 #stop mdrun in case it reached a state and is still running
\f0\i0 \cf0 \
   \cf2 408\cf0 	    &\cf5 stop_running_folder\cf0 (\cf6 $PATH\cf0 \{TPSRUNF\})
\f2\b if
\f0\b0 (\cf6 $RES\cf0 \{F\}=~
\f2\b /1/
\f0\b0  && !\cf6 $stf\cf0  );\
   \cf2 409\cf0 	    &\cf5 stop_running_folder\cf0 (\cf6 $PATH\cf0 \{TPSRUNB\})
\f2\b if
\f0\b0 (\cf6 $RES\cf0 \{B\}=~
\f2\b /1/
\f0\b0  && !\cf6 $stb\cf0  );\
   \cf2 410\cf0 	    \cf5 sleep\cf0 (\cf2 2\cf0 );            \
   \cf2 411\cf0 	                          \
   \cf2 412\cf0 	    
\f1\i \cf3 #check the stopped status again just to be sure it was really stopped
\f0\i0 \cf0 \
   \cf2 413\cf0 	    \cf6 $stf\cf0  = &\cf5 stopped\cf0 (\cf6 $PATH\cf0 \{TPSRUNF\});\
   \cf2 414\cf0 	    \cf6 $stb\cf0  = &\cf5 stopped\cf0 (\cf6 $PATH\cf0 \{TPSRUNB\});\
   \cf2 415\cf0 	    \
   \cf2 416\cf0 	    
\f1\i \cf3 #check the N_max criterium
\f0\i0 \cf0 \
   \cf2 417\cf0 	
\f1\i \cf3 #    my $N_sum = &CURRENT_LENGTH();
\f0\i0 \cf0 \
   \cf2 418\cf0 	    \
   \cf2 419\cf0 	    
\f2\b my
\f0\b0  \cf6 $fr_curr\cf0  = &\cf5 FR_CURR\cf0 ();\
   \cf2 420\cf0 	    
\f2\b my
\f0\b0  \cf6 $sw_curr\cf0  = &\cf5 SW_CURR\cf0 ();\
   \cf2 421\cf0 	\
   \cf2 422\cf0 	    
\f2\b if
\f0\b0 (  \cf6 $fr_curr\cf0  >= \cf6 $MAX_LEN_FR\cf0   || \cf6 $sw_curr\cf0  >= \cf6 $SW_MAX\cf0 )\
   \cf2 423\cf0 	    \{\
   \cf2 424\cf0 		
\f2\b print
\f0\b0  \cf4 "NUMBER OF FRAMES ($MAX_LEN_FR) EXCEEDED\cf7 \\n\cf4 "\cf0  
\f2\b if
\f0\b0  \cf6 $fr_curr\cf0  >= \cf6 $MAX_LEN_FR\cf0  ;\
   \cf2 425\cf0 		printf \cf4 "SUM OF WEIGHTS  EXCEEDED SW_MAX=%.2f\cf7 \\n\cf4 "\cf0 , \cf6 $SW_MAX\cf0  
\f2\b if
\f0\b0  \cf6 $sw_curr\cf0  >= \cf6 $SW_MAX\cf0 ;\
   \cf2 426\cf0 		&\cf5 stop_running_folder\cf0 (\cf6 $PATH\cf0 \{TPSRUNF\}) 
\f2\b if
\f0\b0  \cf6 $stf\cf0 ==\cf2 0\cf0 ;\
   \cf2 427\cf0 		&\cf5 stop_running_folder\cf0 (\cf6 $PATH\cf0 \{TPSRUNB\}) 
\f2\b if
\f0\b0  \cf6 $stb\cf0 ==\cf2 0\cf0 ;\
   \cf2 428\cf0 	    \}\
   \cf2 429\cf0 	   \
   \cf2 430\cf0 	   \
   \cf2 431\cf0 	\
   \cf2 432\cf0 	    
\f1\i \cf3 #check if stopped again
\f0\i0 \cf0 \
   \cf2 433\cf0 	    \cf6 $stf\cf0  = &\cf5 stopped\cf0 (\cf6 $PATH\cf0 \{TPSRUNF\});\
   \cf2 434\cf0 	    \cf6 $stb\cf0  = &\cf5 stopped\cf0 (\cf6 $PATH\cf0 \{TPSRUNB\});\
   \cf2 435\cf0 	   \
   \cf2 436\cf0 	
\f1\i \cf3 #do the loop until at least one is running. if stf+stb=2 than both stopped
\f0\i0 \cf0 \
   \cf2 437\cf0 	\}
\f2\b while
\f0\b0 (\cf6 $stf\cf0  + \cf6 $stb\cf0  < \cf2 2\cf0 );\
   \cf2 438\cf0 	
\f1\i \cf3 #######################################
\f0\i0 \cf0 \
   \cf2 439\cf0 	
\f1\i \cf3 #                                     #
\f0\i0 \cf0 \
   \cf2 440\cf0 	
\f1\i \cf3 #         END of  MD LOOP             #
\f0\i0 \cf0 \
   \cf2 441\cf0 	
\f1\i \cf3 #                                     #
\f0\i0 \cf0 \
   \cf2 442\cf0 	
\f1\i \cf3 #######################################
\f0\i0 \cf0 \
   \cf2 443\cf0 	\
\
End of one 
\f2\b or
\f0\b0  two monitored MD runs\
\
   \cf2 444\cf0 	\
   \cf2 445\cf0 	&\cf5 truncate_trrs\cf0 ();                                      
\f1\i \cf3 #<<< cut the trr(s) just after they enter stable state
\f0\i0 \cf0 \
   \cf2 446\cf0 	
\f2\b print
\f0\b0  \cf4 "\cf7 \\n\cf4 "\cf0 ;\
   \cf2 447\cf0 	\
   \cf2 448\cf0 	
\f1\i \cf3 #first store to get par file even if this is not gonna be accepted########
\f0\i0 \cf0 \
   \cf2 449\cf0 	
\f1\i \cf3 #the storage procedure is based on the ACCEPTED/STORED values, so we set them 
\f0\i0 \cf0 \
   \cf2 450\cf0 	
\f1\i \cf3 #if they were going to be accepted                             
\f0\i0 \cf0 \
   \cf2 451\cf0 	\cf6 $STORED\cf0  = \cf2 1\cf0 ;                                               
\f1\i \cf3 #set to 1 for the store_trr
\f0\i0 \cf0 \
   \cf2 452\cf0 	\cf6 $ACCEPTED\cf0  = \cf6 $INIT_FORW_BACK\cf0  == \cf2 1\cf0  ? \cf4 "forw"\cf0  : \cf4 "back"\cf0 ;          \
   \cf2 453\cf0 	\cf6 $ACCEPTED\cf0  = \cf4 "forwback"\cf0  
\f2\b if
\f0\b0  \cf6 $TPS\cf0 \{SHOOTING\}\{TYPE\}=~
\f2\b /2WAY/
\f0\b0 ;        \
   \cf2 454\cf0 	&\cf5 store_trr\cf0 ();                                              
\f1\i \cf3 #<--- uses STORED and ACCEPTED
\f0\i0 \cf0 \
   \cf2 455\cf0 	&\cf5 make_par_file\cf0 ();\
   \cf2 456\cf0 	
\f2\b print
\f0\b0  \cf4 "\cf7 \\n\cf4 "\cf0 ; \
   \cf2 457\cf0 	\
   \cf2 458\cf0 	\
   \cf2 459\cf0 	
\f2\b my
\f0\b0  \cf6 $parf\cf0  = \cf6 $OPATH\cf0 \{PAR\}.&\cf5 numtostr\cf0 (\cf6 $STEP\cf0 ,\cf2 6\cf0 ).\cf4 ".par"\cf0 ;\
   \cf2 460\cf0 	\cf6 $ACCEPTED\cf0  = &\cf5 ACCEPTED\cf0 (\cf6 $parf\cf0 ,\cf6 $SW_MAX\cf0 );\
   \cf2 461\cf0 	
\f2\b print
\f0\b0  \cf4 "ACCEPTED = [$ACCEPTED]\cf7 \\n\cf4 "\cf0 ;\
   \cf2 462\cf0 	
\f1\i \cf3 #now the files $STEP.par/trr/zos files are stored as if they were going to be accepted 
\f0\i0 \cf0 \
   \cf2 463\cf0 	
\f1\i \cf3 #they will be removed later after storage of the rejected paths
\f0\i0 \cf0 \
   \cf2 464\cf0 	
\f2\b print
\f0\b0  \cf4 "\cf7 \\n\cf4 "\cf0 ;\
   \cf2 465\cf0 	\
   \cf2 466\cf0 	
\f1\i \cf3 #######################################
\f0\i0 \cf0 \
   \cf2 467\cf0 	
\f1\i \cf3 #                                     #
\f0\i0 \cf0 \
   \cf2 468\cf0 	
\f1\i \cf3 #         STORAGE & STATS             #
\f0\i0 \cf0 \
   \cf2 469\cf0 	
\f1\i \cf3 #                                     #
\f0\i0 \cf0 \
   \cf2 470\cf0 	
\f1\i \cf3 #######################################
\f0\i0 \cf0 \
   \cf2 471\cf0 	
\f2\b my
\f0\b0  \cf6 $this_step_path\cf0  = ( &\cf5 get_par_path\cf0 (\cf6 $parf\cf0 ,\\\cf6 %PARAM\cf0 ) =~ 
\f2\b /\\[(.+)\\]/
\f0\b0 g )[\cf2 0\cf0 ];\
   \cf2 472\cf0 	
\f2\b my
\f0\b0  \cf6 $this_step_ess_path\cf0  = &\cf5 get_essential_path\cf0 (\cf6 $this_step_path\cf0 ,\\\cf6 @RECROSSING_RULES\cf0 );\
   \cf2 473\cf0 	\
   \cf2 474\cf0 	\
   \cf2 475\cf0 	\
   \cf2 476\cf0 	&\cf5 write_step_summary\cf0 (\cf6 $parf\cf0 ); 
\f1\i \cf3 #write summary before par file might be moved to output.rej
\f0\i0 \cf0 \
   \cf2 477\cf0 	\
   \cf2 478\cf0 	
\f2\b if
\f0\b0 ( \cf6 $ACCEPTED\cf0 =~
\f2\b /forw/
\f0\b0  || \cf6 $ACCEPTED\cf0 =~
\f2\b /back/
\f0\b0  )\
   \cf2 479\cf0 	\{\
   \cf2 480\cf0 	    \cf6 $STORED\cf0  = \cf2 1\cf0 ;\
   \cf2 481\cf0 	    &\cf5 store_dat_files_all_steps\cf0 ();\
   \cf2 482\cf0 	    &\cf5 store_dat_files_acc_steps\cf0 ();\
   \cf2 483\cf0 	    &\cf5 check_if_step_OK\cf0 ();\
   \cf2 484\cf0 	    
\f2\b print
\f0\b0  FILE_MOVES \cf4 "$STEP6\cf7 \\t\cf4 shooting($TPS\{SHOOTING\}\{TYPE\})\cf7 \\t\cf4 accepted\cf7 \\t\cf4 $this_step_ess_path\cf7 \\n\cf4 "\cf0 ;\
   \cf2 485\cf0 	    
\f1\i \cf3 #storing direction is already correct
\f0\i0 \cf0 \
   \cf2 486\cf0 	\}\
   \cf2 487\cf0 	
\f2\b else
\f0\b0  \
   \cf2 488\cf0 	\{ \
   \cf2 489\cf0 	    \cf6 $STORED\cf0  = \cf2 0\cf0 ;\
   \cf2 490\cf0 	    \
   \cf2 491\cf0 	    &\cf5 store_dat_files_all_steps\cf0 ();\
   \cf2 492\cf0 	    &\cf5 store_rejected\cf0 ();\
   \cf2 493\cf0 	\
   \cf2 494\cf0 	    
\f2\b print
\f0\b0  \cf4 " --> trial files are going to be removed:\cf7 \\n\cf4 "\cf0 ;\
   \cf2 495\cf0 	    
\f2\b my
\f0\b0  \cf6 $parf\cf0  = \cf6 $OPATH\cf0 \{PAR\}.&\cf5 numtostr\cf0 (\cf6 $STEP\cf0 ,\cf2 6\cf0 ).\cf4 ".par"\cf0 ; \
   \cf2 496\cf0 	    
\f2\b print
\f0\b0  \cf4 "--> remove $parf"\cf0 ; `rm \cf6 $parf\cf0 `;\
   \cf2 497\cf0 	    
\f2\b my
\f0\b0  \cf6 $trrf\cf0  = \cf6 $OPATH\cf0 \{TRR\}.&\cf5 numtostr\cf0 (\cf6 $STEP\cf0 ,\cf2 6\cf0 ).\cf4 ".trr"\cf0 ; \
   \cf2 498\cf0 	    
\f2\b print
\f0\b0  \cf4 "--> remove $trrf"\cf0 ; `rm \cf6 $trrf\cf0 `;\
   \cf2 499\cf0 	    
\f2\b my
\f0\b0  \cf6 $zosf\cf0  = \cf6 $OPATH\cf0 \{ZOS\}.&\cf5 numtostr\cf0 (\cf6 $STEP\cf0 ,\cf2 6\cf0 ).\cf4 ".zos"\cf0 ;\
   \cf2 500\cf0 	    
\f2\b print
\f0\b0  \cf4 "--> remove $zosf"\cf0 ; `rm \cf6 $zosf\cf0 `;\
   \cf2 501\cf0 	    `rm \cf6 $PATH\cf0 \{CURR_GROS\}/*`;\
   \cf2 502\cf0 	\
   \cf2 503\cf0 	    
\f2\b print
\f0\b0  FILE_MOVES \cf4 "$STEP6\cf7 \\t\cf4 shooting($TPS\{SHOOTING\}\{TYPE\})\cf7 \\t\cf4 rejected\cf7 \\t\cf4 $this_step_ess_path\cf7 \\n\cf4 "\cf0 ;\
   \cf2 504\cf0 	    \
   \cf2 505\cf0 	\}\
   \cf2 506\cf0 	\
   \cf2 507\cf0 	
\f1\i \cf3 #----------------------------------------------------------------------------------------------------------------------------
\f0\i0 \cf0 \
   \cf2 508\cf0 	\
   \cf2 509\cf0 	
\f2\b goto
\f0\b0  \cf5 BEG\cf0  ;\
\
Goes back to line \cf2 280\cf0 \
\
   \cf2 510\cf0 	FIN: \cf5 exit\cf0 ;\
\
   \cf2 511\cf0 	
\f1\i \cf3 ##############################################################################
\f0\i0 \cf0 \
   \cf2 512\cf0 	
\f1\i \cf3 #                                                                            #
\f0\i0 \cf0 \
   \cf2 513\cf0 	
\f1\i \cf3 #                     END of Main LOOP                                       #
\f0\i0 \cf0 \
   \cf2 514\cf0 	
\f1\i \cf3 #                                                                            #
\f0\i0 \cf0 \
   \cf2 515\cf0 	
\f1\i \cf3 ##############################################################################
\f0\i0 \cf0 \
   \cf2 516\cf0 	\
\
SUB ROUTINES:\
\
   \cf2 517\cf0 	\
   \cf2 518\cf0 	
\f2\b sub
\f0\b0  \cf5 B\cf0 () 
\f1\i \cf3 # frame \\@lambda
\f0\i0 \cf0 \
   \cf2 519\cf0 	\{\
   \cf2 520\cf0 	    
\f1\i \cf3 #with this function we can bias the initial frames towards the interface
\f0\i0 \cf0 \
   \cf2 521\cf0 	\
   \cf2 522\cf0 	    
\f2\b my
\f0\b0  \cf6 $frame\cf0  = \cf5 shift\cf0 ;\
   \cf2 523\cf0 	    
\f2\b my
\f0\b0  \cf6 $ref\cf0  = \cf5 shift\cf0 ;\
   \cf2 524\cf0 	    
\f2\b my
\f0\b0  \cf6 @lambda\cf0  = @\{\cf6 $ref\cf0 \};\
   \cf2 525\cf0 	\
   \cf2 526\cf0 	    
\f2\b my
\f0\b0  \cf6 $L\cf0        = \cf6 @lambda\cf0  + \cf2 0\cf0 ; \
   \cf2 527\cf0 	    \
   \cf2 528\cf0 	    
\f1\i \cf3 #if bias type is  uniform B is just 1 - all initial frames are equally probable
\f0\i0 \cf0 \
   \cf2 529\cf0 	    
\f2\b return
\f0\b0  \cf2 1.0\cf0  
\f2\b if
\f0\b0  \cf6 $TPS\cf0 \{BIAS\}\{TYPE\} =~ 
\f2\b /UNIFORM/
\f0\b0 ;  
\f1\i \cf3 #any frame will be picked with the same probability
\f0\i0 \cf0 \
   \cf2 530\cf0 	    \
   \cf2 531\cf0 	    
\f1\i \cf3 #gaussian case
\f0\i0 \cf0 \
   \cf2 532\cf0 	    
\f2\b if
\f0\b0 ( \cf6 $TPS\cf0 \{BIAS\}\{TYPE\} =~ 
\f2\b /GAUSSIAN/
\f0\b0  )\
   \cf2 533\cf0 	    \{\
   \cf2 534\cf0 		
\f2\b return
\f0\b0  &\cf5 W\cf0 (\cf6 $lambda\cf0 [\cf6 $frame\cf0 ]) / &\cf5 SW\cf0 (\\\cf6 @lambda\cf0 );	\
   \cf2 535\cf0 	    \}\
   \cf2 536\cf0 	\}\
   \cf2 537\cf0 	\
   \cf2 538\cf0 	
\f2\b sub
\f0\b0  \cf5 W\cf0 () 
\f1\i \cf3 # $lambda
\f0\i0 \cf0 \
   \cf2 539\cf0 	\{\
   \cf2 540\cf0 	    
\f2\b if
\f0\b0 ( \cf6 $TPS\cf0 \{BIAS\}\{TYPE\} =~ 
\f2\b /UNIFORM/
\f0\b0  ) \{ 
\f2\b return
\f0\b0  \cf2 1\cf0  \}  
\f1\i \cf3 #each frame has weight 1 
\f0\i0 \cf0 \
   \cf2 541\cf0 	\
   \cf2 542\cf0 	    
\f2\b if
\f0\b0 (\cf6 $TPS\cf0 \{BIAS\}\{TYPE\} =~ 
\f2\b /GAUSSIAN/
\f0\b0  )\
   \cf2 543\cf0 	    \{\
   \cf2 544\cf0 		
\f2\b my
\f0\b0  \cf6 $lambda\cf0  = \cf5 shift\cf0 ;\
   \cf2 545\cf0 		
\f2\b return
\f0\b0  \cf5 exp\cf0 (-(\cf6 $lambda\cf0 -\cf6 $BIAS\cf0 \{MAXAT\})**\cf2 2\cf0 /(\cf2 2\cf0 *\cf6 $BIAS\cf0 \{SIGMA\}**\cf2 2\cf0 ));\
   \cf2 546\cf0 	    \}\
   \cf2 547\cf0 	\}\
   \cf2 548\cf0 	\
   \cf2 549\cf0 	
\f2\b sub
\f0\b0  \cf5 SW\cf0 () 
\f1\i \cf3 #\\@lambda
\f0\i0 \cf0 \
   \cf2 550\cf0 	\{\
   \cf2 551\cf0 	    
\f2\b my
\f0\b0  \cf6 $ref\cf0  = \cf5 shift\cf0 ;\
   \cf2 552\cf0 	    
\f2\b my
\f0\b0  \cf6 @lambda\cf0  = @\{\cf6 $ref\cf0 \};\
   \cf2 553\cf0 	    
\f2\b my
\f0\b0  \cf6 $sum\cf0  = \cf2 0\cf0 ;\
   \cf2 554\cf0 	    
\f2\b for
\f0\b0 (
\f2\b my
\f0\b0  \cf6 $i\cf0 =\cf2 0\cf0 ; \cf6 $i\cf0 <\cf6 @lambda\cf0 ; \cf6 $i\cf0 ++)\
   \cf2 555\cf0 	    \{\
   \cf2 556\cf0 		\cf6 $sum\cf0  += &\cf5 W\cf0 (\cf6 $lambda\cf0 [\cf6 $i\cf0 ]);\
   \cf2 557\cf0 	    \}\
   \cf2 558\cf0 	    
\f2\b return
\f0\b0  \cf6 $sum\cf0 ;  
\f1\i \cf3 #the sum of weights will be N for the uniform case 
\f0\i0 \cf0 \
   \cf2 559\cf0 	\}\
   \cf2 560\cf0 	\
   \cf2 561\cf0 	\
   \cf2 562\cf0 	\
   \cf2 563\cf0 	
\f2\b sub
\f0\b0  \cf5 _reverse_gro_files_in_PREV\cf0 ()\
   \cf2 564\cf0 	\{\
   \cf2 565\cf0 	    
\f2\b print
\f0\b0  RED, \cf4 "\cf7 \\n\cf4 >>>>_reverse_gro_files_in_PREV: BEGIN (DEBUG)<<<<<<<<<\cf7 \\n\cf4 "\cf0 , RESET 
\f2\b if
\f0\b0  \cf6 $DEBUG_ON\cf0 ;\
   \cf2 566\cf0 	    
\f1\i \cf3 #reverse numbers and b<->f
\f0\i0 \cf0 \
   \cf2 567\cf0 	    
\f2\b print
\f0\b0  \cf4 "REVERSING INPUT GROS AS WILL BE SHOOTING FROM REVERSED TRR\cf7 \\n\cf4 "\cf0 ;\
   \cf2 568\cf0 	    chdir \cf6 $PATH\cf0 \{PREV_GROS\};\
   \cf2 569\cf0 	    mkdir \cf4 "tmp"\cf0 ;\
   \cf2 570\cf0 	    
\f2\b my
\f0\b0  \cf6 @b_gros\cf0  = split \cf4 "\cf7 \\n\cf4 "\cf0 , `ls -\cf2 1\cf0  b*  | grep gro`; chomp \cf6 @b_gros\cf0 ;\
   \cf2 571\cf0 	    
\f2\b my
\f0\b0  \cf6 @f_gros\cf0  = split \cf4 "\cf7 \\n\cf4 "\cf0 , `ls -\cf2 1\cf0  f*  | grep gro`; chomp \cf6 @b_gros\cf0 ;\
   \cf2 572\cf0 	    
\f2\b my
\f0\b0  \cf6 @gros\cf0    = split \cf4 "\cf7 \\n\cf4 "\cf0 , `ls -\cf2 1\cf0      | grep gro`;   chomp \cf6 @gros\cf0 ; \
   \cf2 573\cf0 	 \
   \cf2 574\cf0 	    
\f2\b for
\f0\b0 (
\f2\b my
\f0\b0  \cf6 $i\cf0 =\cf2 0\cf0 ; \cf6 $i\cf0 <\cf6 @gros\cf0 ; \cf6 $i\cf0 ++) \{`mv \cf6 $PATH\cf0 \{PREV_GROS\}\cf6 $gros\cf0 [\cf6 $i\cf0 ] \cf6 $PATH\cf0 \{PREV_GROS\}tmp/`\}\
   \cf2 575\cf0 	    \
   \cf2 576\cf0 	    
\f2\b my
\f0\b0  \cf6 %bf\cf0  =  ( \cf4 "b"\cf0  => \cf4 "f"\cf0 , \cf4 "f"\cf0  => \cf4 "b"\cf0  );\
   \cf2 577\cf0 	    
\f2\b for
\f0\b0 (
\f2\b my
\f0\b0  \cf6 $i\cf0 =\cf2 0\cf0 ; \cf6 $i\cf0 <\cf6 @gros\cf0 ; \cf6 $i\cf0 ++)\
   \cf2 578\cf0 	    \{\
   \cf2 579\cf0 		\cf6 $gros\cf0 [\cf6 $i\cf0 ] =~ 
\f2\b /(b|f)(\\d+)\\.gro/
\f0\b0 ;\
   \cf2 580\cf0 		
\f2\b my
\f0\b0  \cf6 $new6\cf0     = &\cf5 numtostr\cf0 (\cf6 @gros\cf0 -\cf6 $2\cf0 -\cf2 1\cf0 ,\cf2 6\cf0 );\
   \cf2 581\cf0 		
\f2\b my
\f0\b0  \cf6 $new_gro\cf0  = \cf4 "$bf\{$1\}$new6.gro"\cf0 ;\
   \cf2 582\cf0 	
\f1\i \cf3 #	print "tmp/$gros[$i] ---> $new_gro\\n";
\f0\i0 \cf0 \
   \cf2 583\cf0 		`mv \cf6 $PATH\cf0 \{PREV_GROS\}tmp/\cf6 $gros\cf0 [\cf6 $i\cf0 ] \cf6 $PATH\cf0 \{PREV_GROS\}\cf6 $new_gro\cf0 `;	\
   \cf2 584\cf0 	    \}\
   \cf2 585\cf0 	    `rm -r tmp`;\
   \cf2 586\cf0 	\
   \cf2 587\cf0 	    
\f1\i \cf3 #reverse velocities 
\f0\i0 \cf0 \
   \cf2 588\cf0 	    
\f2\b my
\f0\b0  \cf6 @gros\cf0    = split \cf4 "\cf7 \\n\cf4 "\cf0 , `ls -\cf2 1\cf0      | grep gro`;   chomp \cf6 @gros\cf0 ;\
   \cf2 589\cf0 	    
\f2\b for
\f0\b0 (
\f2\b my
\f0\b0  \cf6 $g\cf0 =\cf2 0\cf0 ; \cf6 $g\cf0 <\cf6 @gros\cf0 ; \cf6 $g\cf0 ++)\
   \cf2 590\cf0 	    \{\
   \cf2 591\cf0 	
\f1\i \cf3 #	print "rev vel $gros[$g]\\n";
\f0\i0 \cf0 \
   \cf2 592\cf0 	
\f1\i \cf3 #NDEC16 `$SCRIPT\{REV_GRO\} -prec 16 -gro $gros[$g]`;	
\f0\i0 \cf0 \
   \cf2 593\cf0 		`\cf6 $SCRIPT\cf0 \{REV_GRO\} -prec \cf6 $GRO_PREC\cf0  -gro \cf6 $gros\cf0 [\cf6 $g\cf0 ]`;	\
   \cf2 594\cf0 		die \cf4 "rev_$gros[$g] doesn't exist! problem with reversing gro file in $PATH\{PREV_GROS\}"\cf0 \
   \cf2 595\cf0 		    
\f2\b if
\f0\b0  !-e \cf4 "rev_$gros[$g]"\cf0 ;\
   \cf2 596\cf0 		`mv rev_\cf6 $gros\cf0 [\cf6 $g\cf0 ] \cf6 $gros\cf0 [\cf6 $g\cf0 ]`;\
   \cf2 597\cf0 	    \}\
   \cf2 598\cf0 	   \
   \cf2 599\cf0 	    
\f2\b print
\f0\b0  RED, \cf4 "\cf7 \\n\cf4 >>>>_reverse_gro_files_in_PREV: END (DEBUG)<<<<<<<<<\cf7 \\n\cf4 "\cf0 , RESET 
\f2\b if
\f0\b0  \cf6 $DEBUG_ON\cf0 ;\
   \cf2 600\cf0 	\}\
   \cf2 601\cf0 	\
\
\
   \cf2 616\cf0 	\
   \cf2 617\cf0 	\
   \cf2 618\cf0 	\
   \cf2 619\cf0 	
\f1\i \cf3 #function that says what is and what is not accepted for storage
\f0\i0 \cf0 \
   \cf2 620\cf0 	
\f2\b sub
\f0\b0  \cf5 ACCEPTED\cf0 ()  
\f1\i \cf3 #parf nmax
\f0\i0 \cf0 \
   \cf2 621\cf0 	\{\
   \cf2 622\cf0 	    
\f2\b print
\f0\b0  RED \cf4 "ACCEPTANCE"\cf0 ;\
   \cf2 623\cf0 	    
\f2\b print
\f0\b0  \cf5 RESET\cf0 ;\
   \cf2 624\cf0 	    
\f2\b print
\f0\b0  \cf4 "\cf7 \\n\cf4 "\cf0 ;\
   \cf2 625\cf0 	    
\f2\b my
\f0\b0  \cf6 $parf\cf0  = \cf5 shift\cf0 ;\
   \cf2 626\cf0 	    
\f2\b my
\f0\b0  \cf6 $sw_max\cf0   = \cf5 shift\cf0 ;\
   \cf2 627\cf0 	\
   \cf2 628\cf0 	    
\f2\b return
\f0\b0  \cf4 "file"\cf0  
\f2\b if
\f0\b0  !-e \cf6 $parf\cf0 ;\
   \cf2 629\cf0 	    
\f1\i \cf3 #my $n_ = `wc -l $parf | awk \\'\\\{print \\$1\\\}\\'`; 
\f0\i0 \cf0 \
   \cf2 630\cf0 	    
\f2\b my
\f0\b0  \cf6 $awk_col\cf0  = \cf6 $BIAS\cf0 \{PAR\} + \cf2 1\cf0 ;\
   \cf2 631\cf0 	    
\f2\b my
\f0\b0  \cf6 @lambda\cf0  = split \cf4 "\cf7 \\n\cf4 "\cf0 , `awk \cf7 \\'\cf0 \{
\f2\b print
\f0\b0  \\$\cf6 $awk_col\cf0 \}\cf7 \\'\cf0  \cf6 $parf\cf0 `;\
   \cf2 632\cf0 	    chomp \cf6 @lambda\cf0 ; shift \cf6 @lambda\cf0 ;\
   \cf2 633\cf0 	    
\f2\b my
\f0\b0  \cf6 $sw\cf0  = &\cf5 SW\cf0 (\\\cf6 @lambda\cf0 );\
   \cf2 634\cf0 	    
\f2\b return
\f0\b0  \cf4 "nmax exceeded"\cf0  
\f2\b if
\f0\b0  \cf6 $sw\cf0  > \cf6 $sw_max\cf0 ;\
   \cf2 635\cf0 	    \
   \cf2 636\cf0 	    \
   \cf2 637\cf0 	    
\f1\i \cf3 #we need both signs the same for esspth (we dont care about times here)
\f0\i0 \cf0 \
   \cf2 638\cf0 	    
\f2\b my
\f0\b0  \cf6 $path\cf0  = &\cf5 get_par_path\cf0 (\cf6 $parf\cf0 ,\\\cf6 %PARAM\cf0 ,\cf4 "->"\cf0 );\
   \cf2 639\cf0 	    \
   \cf2 640\cf0 	\
   \cf2 641\cf0 	    
\f2\b my
\f0\b0  \cf6 $spath\cf0  = (\cf6 $path\cf0 =~
\f2\b /\\[(.*)\\]/
\f0\b0 g)[\cf2 0\cf0 ];\
   \cf2 642\cf0 	    
\f2\b print
\f0\b0  \cf4 "NEW PATHWAY : $spath\cf7 \\n\cf4 "\cf0 ;\
   \cf2 643\cf0 	    \
   \cf2 644\cf0 	    
\f2\b my
\f0\b0  \cf6 $ess_path\cf0  = &\cf5 get_essential_path\cf0 (\cf6 $spath\cf0 , \\\cf6 @RECROSSING_RULES\cf0 , \\\cf6 %STATE\cf0 );\
   \cf2 645\cf0 	    
\f2\b print
\f0\b0  \cf4 "ESSENTIAL   : $ess_path\cf7 \\n\cf4 "\cf0 ;\
   \cf2 646\cf0 	\
   \cf2 647\cf0 	    
\f1\i \cf3 #TEST THE PATHWAY AGAINST THE ENSEMBLE RULES
\f0\i0 \cf0 \
   \cf2 648\cf0 	    
\f1\i \cf3 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
\f0\i0 \cf0 \
   \cf2 649\cf0 	    
\f2\b if
\f0\b0 (\cf6 $TPS\cf0 \{SHOOTING\}\{TYPE\}=~
\f2\b /2WAY/
\f0\b0 ) \
   \cf2 650\cf0 	    \{\
   \cf2 651\cf0 		
\f1\i \cf3 #add rules here 
\f0\i0 \cf0 \
   \cf2 652\cf0 		
\f2\b print
\f0\b0  \cf4 "CHECKING $ess_path WITH ALL COMBINATIONS OF BEG/END ANCHORS:\cf7 \\n\cf4 "\cf0 ;\
   \cf2 653\cf0 		
\f2\b for
\f0\b0 (
\f2\b my
\f0\b0  \cf6 $i\cf0 =\cf2 0\cf0 ; \cf6 $i\cf0 <\cf6 @ANCHOR_END\cf0 ; \cf6 $i\cf0 ++)\
   \cf2 654\cf0 		\{	    \
   \cf2 655\cf0 		   \
   \cf2 656\cf0 		    
\f2\b if
\f0\b0  ( \cf6 $ess_path\cf0 =~
\f2\b /$ANCHOR_END[$i]$/
\f0\b0  )\
   \cf2 657\cf0 		    \{\
   \cf2 658\cf0 			
\f2\b for
\f0\b0 (
\f2\b my
\f0\b0  \cf6 $j\cf0 =\cf2 0\cf0 ; \cf6 $j\cf0 <\cf6 @ANCHOR_BEG\cf0 ; \cf6 $j\cf0 ++)\
   \cf2 659\cf0 			\{	    \
   \cf2 660\cf0 			    
\f2\b print
\f0\b0  \cf4 "---> \{$ANCHOR_END[$i] + $ANCHOR_BEG[$j]\} "\cf0 ;\
   \cf2 661\cf0 			    
\f2\b if
\f0\b0  ( \cf6 $ess_path\cf0 =~
\f2\b /^$ANCHOR_BEG[$j]/
\f0\b0  )\
   \cf2 662\cf0 			    \{ \
   \cf2 663\cf0 				
\f2\b print
\f0\b0  \cf4 "YES\cf7 \\n\cf4 "\cf0 ; \
   \cf2 664\cf0 				
\f2\b return
\f0\b0  \cf4 "forwback"\cf0 ; \
   \cf2 665\cf0 			    \}	\
   \cf2 666\cf0 			    
\f2\b print
\f0\b0  \cf4 "NO\cf7 \\n\cf4 "\cf0 ;\
   \cf2 667\cf0 			\}\
   \cf2 668\cf0 			\
   \cf2 669\cf0 			\
   \cf2 670\cf0 		    \}\
   \cf2 671\cf0 		    \
   \cf2 672\cf0 		    \
   \cf2 673\cf0 		\}\
   \cf2 674\cf0 		
\f2\b return
\f0\b0  \cf4 ""\cf0 ; 
\f1\i \cf3 #if both dont fullfill rules - step will be rejected
\f0\i0 \cf0 \
   \cf2 675\cf0 	    \}\
   \cf2 676\cf0 	    
\f1\i \cf3 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
\f0\i0 \cf0 \
   \cf2 677\cf0 	    
\f2\b if
\f0\b0 (\cf6 $TPS\cf0 \{SHOOTING\}\{TYPE\}=~
\f2\b /1WAY/
\f0\b0  && \cf6 $INIT_FORW_BACK\cf0 ==\cf2 1\cf0  ) 
\f1\i \cf3 #one way shooting, forward
\f0\i0 \cf0 \
   \cf2 678\cf0 	    \{\
   \cf2 679\cf0 		
\f2\b print
\f0\b0  \cf4 "CHECKING $ess_path WITH END ANCHORS:\cf7 \\n\cf4 "\cf0 ;\
   \cf2 680\cf0 		
\f2\b for
\f0\b0 (
\f2\b my
\f0\b0  \cf6 $i\cf0 =\cf2 0\cf0 ; \cf6 $i\cf0 <\cf6 @ANCHOR_END\cf0 ; \cf6 $i\cf0 ++)\
   \cf2 681\cf0 		\{	    \
   \cf2 682\cf0 		    
\f2\b print
\f0\b0  \cf4 "---> \{$ANCHOR_END[$i]\} "\cf0 ;\
   \cf2 683\cf0 		    
\f2\b if
\f0\b0  ( \cf6 $ess_path\cf0 =~
\f2\b /$ANCHOR_END[$i]$/
\f0\b0  )\{ 
\f2\b print
\f0\b0  \cf4 "YES\cf7 \\n\cf4 "\cf0 ;  
\f2\b return
\f0\b0  \cf4 "forw"\cf0 ;\}\
   \cf2 684\cf0 		    
\f2\b print
\f0\b0  \cf4 "NO\cf7 \\n\cf4 "\cf0 ;\
   \cf2 685\cf0 		\}\
   \cf2 686\cf0 	    \} \
   \cf2 687\cf0 	    
\f1\i \cf3 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
\f0\i0 \cf0 \
   \cf2 688\cf0 	    
\f2\b if
\f0\b0 (\cf6 $TPS\cf0 \{SHOOTING\}\{TYPE\}=~
\f2\b /1WAY/
\f0\b0  && \cf6 $INIT_FORW_BACK\cf0 ==\cf2 0\cf0  ) 
\f1\i \cf3 #one way shooting, backward
\f0\i0 \cf0 \
   \cf2 689\cf0 	    \{\
   \cf2 690\cf0 		
\f2\b print
\f0\b0  \cf4 "CHECKING $ess_path WITH BEG ANCHORS:\cf7 \\n\cf4 "\cf0 ;\
   \cf2 691\cf0 		
\f2\b for
\f0\b0 (
\f2\b my
\f0\b0  \cf6 $i\cf0 =\cf2 0\cf0 ; \cf6 $i\cf0 <\cf6 @ANCHOR_BEG\cf0 ; \cf6 $i\cf0 ++)\
   \cf2 692\cf0 		\{\
   \cf2 693\cf0 		    
\f2\b print
\f0\b0  \cf4 "---> \{$ANCHOR_BEG[$i]\} "\cf0 ;\
   \cf2 694\cf0 		    
\f2\b if
\f0\b0  ( \cf6 $ess_path\cf0 =~
\f2\b /^$ANCHOR_BEG[$i]/
\f0\b0  )\{ 
\f2\b print
\f0\b0  \cf4 "YES\cf7 \\n\cf4 "\cf0 ;  
\f2\b return
\f0\b0  \cf4 "back"\cf0 ; \}	\
   \cf2 695\cf0 		    
\f2\b print
\f0\b0  \cf4 "NO\cf7 \\n\cf4 "\cf0 ;\
   \cf2 696\cf0 		\}\
   \cf2 697\cf0 	    \}\
   \cf2 698\cf0 	    
\f1\i \cf3 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
\f0\i0 \cf0 \
   \cf2 699\cf0 	    
\f2\b return
\f0\b0  \cf4 ""\cf0 ;\
   \cf2 700\cf0 	\}\
   \cf2 701\cf0 	\
   \cf2 702\cf0 	
\f2\b sub
\f0\b0  \cf5 FR_CURR\cf0 ()\
   \cf2 703\cf0 	\{\
   \cf2 704\cf0 	    
\f2\b print
\f0\b0  \cf4 "FR_CURR: "\cf0 ;\
   \cf2 705\cf0 	    
\f2\b print
\f0\b0  \cf4 "[ $TPS\{SHOOTING\}\{TYPE\} ] "\cf0 ;\
   \cf2 706\cf0 	    \
   \cf2 707\cf0 	    
\f2\b my
\f0\b0  \cf6 $fr_curr\cf0  = \cf2 0\cf0 ;\
   \cf2 708\cf0 	    
\f2\b my
\f0\b0  \cf6 $pstep6\cf0   = &\cf5 numtostr\cf0 (\cf6 $STEP\cf0 -\cf2 1\cf0 ,\cf2 6\cf0 );\
   \cf2 709\cf0 	    \
   \cf2 710\cf0 	    
\f1\i \cf3 #load lambdas for previous and current trajectories################################## 
\f0\i0 \cf0 \
   \cf2 711\cf0 	    
\f2\b my
\f0\b0  \cf6 $awk_col\cf0  = \cf6 $BIAS\cf0 \{PAR\} + \cf2 1\cf0 ;\
   \cf2 712\cf0 	    
\f2\b my
\f0\b0  \cf6 @lambda_prev\cf0  = split \cf4 "\cf7 \\n\cf4 "\cf0 , `awk \cf7 \\'\cf0 \{
\f2\b print
\f0\b0  \\$\cf6 $awk_col\cf0 \}\cf7 \\'\cf0  \cf6 $OPATH\cf0 \{PAR\}\cf6 $pstep6\cf0 .par`;\
   \cf2 713\cf0 	    chomp \cf6 @lambda_prev\cf0 ; shift \cf6 @lambda_prev\cf0 ;\
   \cf2 714\cf0 	    
\f2\b my
\f0\b0  \cf6 @lambda_curr_forw\cf0  = split \cf4 "\cf7 \\n\cf4 "\cf0 , `awk \cf7 \\'\cf0 \{
\f2\b print
\f0\b0  \\$\cf6 $awk_col\cf0 \}\cf7 \\'\cf0  \cf6 $OPATH\cf0 \{PAR\}/\cf6 $STEP\cf0 .forw`;\
   \cf2 715\cf0 	    chomp \cf6 @lambda_curr_forw\cf0 ; shift \cf6 @lambda_curr_forw\cf0 ;\
   \cf2 716\cf0 	    
\f2\b my
\f0\b0  \cf6 @lambda_curr_back\cf0  = split \cf4 "\cf7 \\n\cf4 "\cf0 , `awk \cf7 \\'\cf0 \{
\f2\b print
\f0\b0  \\$\cf6 $awk_col\cf0 \}\cf7 \\'\cf0  \cf6 $OPATH\cf0 \{PAR\}/\cf6 $STEP\cf0 .back`;\
   \cf2 717\cf0 	    chomp \cf6 @lambda_curr_back\cf0 ; shift \cf6 @lambda_curr_back\cf0 ;\
   \cf2 718\cf0 	        \
   \cf2 719\cf0 	    
\f1\i \cf3 #we need to split @lambda_prev in two arrays -> before and after CUT_G. 
\f0\i0 \cf0 \
   \cf2 720\cf0 	    
\f1\i \cf3 #CUT_G itself will be counted in STEP.forw or STEP.back so we dont include it 
\f0\i0 \cf0 \
   \cf2 721\cf0 	    
\f2\b my
\f0\b0  \cf6 @lambda_prev_a\cf0  = \cf6 @lambda_prev\cf0 [\cf2 0\cf0  .. (\cf6 $CUT_G\cf0 -\cf2 1\cf0 )] ;\
   \cf2 722\cf0 	    
\f2\b my
\f0\b0  \cf6 @lambda_prev_b\cf0  = \cf6 @lambda_prev\cf0 [(\cf6 $CUT_G\cf0 +\cf2 1\cf0 ) .. \cf6 $#lambda_prev\cf0 ] ;\
   \cf2 723\cf0 	\
   \cf2 724\cf0 	    
\f2\b if
\f0\b0 ( \cf6 $TPS\cf0 \{SHOOTING\}\{TYPE\} =~ 
\f2\b /1WAY/
\f0\b0 )\
   \cf2 725\cf0 	    \{\
   \cf2 726\cf0 		
\f2\b if
\f0\b0 (\cf6 $INIT_FORW_BACK\cf0  == \cf2 1\cf0  ) 
\f1\i \cf3 #than we were shooting forward
\f0\i0 \cf0 \
   \cf2 727\cf0 		\{\
   \cf2 728\cf0 		    
\f2\b my
\f0\b0  \cf6 $fr_old\cf0  = \cf5 scalar\cf0 ( \cf6 @lambda_prev_a\cf0     );\
   \cf2 729\cf0 		    
\f2\b my
\f0\b0  \cf6 $fr_new\cf0  = \cf5 scalar\cf0 ( \cf6 @lambda_curr_forw\cf0  ); \
   \cf2 730\cf0 		    \cf6 $fr_curr\cf0    = \cf6 $fr_old\cf0  + \cf6 $fr_new\cf0 ;\
   \cf2 731\cf0 		    
\f2\b print
\f0\b0  \cf4 "[new sum: $fr_old + $fr_new (->) = $fr_curr]\cf7 \\n\cf4 "\cf0 ;\
   \cf2 732\cf0 		    
\f2\b return
\f0\b0  \cf6 $fr_curr\cf0 ;\
   \cf2 733\cf0 		\}\
   \cf2 734\cf0 		\
   \cf2 735\cf0 		
\f2\b if
\f0\b0 (\cf6 $INIT_FORW_BACK\cf0  == \cf2 0\cf0  ) 
\f1\i \cf3 #than we were shooting backward
\f0\i0 \cf0 \
   \cf2 736\cf0 		\{\
   \cf2 737\cf0 		    
\f2\b my
\f0\b0  \cf6 $fr_old\cf0  = \cf5 scalar\cf0 ( \cf6 @lambda_prev_b\cf0     );\
   \cf2 738\cf0 		    
\f2\b my
\f0\b0  \cf6 $fr_new\cf0  = \cf5 scalar\cf0 ( \cf6 @lambda_curr_back\cf0  ); \
   \cf2 739\cf0 		    \cf6 $fr_curr\cf0    = \cf6 $fr_old\cf0  + \cf6 $fr_new\cf0 ;\
   \cf2 740\cf0 		    
\f2\b print
\f0\b0  \cf4 "[new sum: (<-) $fr_new + $fr_old = $fr_curr]\cf7 \\n\cf4 "\cf0 ;\
   \cf2 741\cf0 		    
\f2\b return
\f0\b0  \cf6 $fr_curr\cf0 ;\
   \cf2 742\cf0 		\}\
   \cf2 743\cf0 	    \}\
   \cf2 744\cf0 	\
   \cf2 745\cf0 	    
\f2\b if
\f0\b0 ( \cf6 $TPS\cf0 \{SHOOTING\}\{TYPE\} =~ 
\f2\b /2WAY/
\f0\b0 )\
   \cf2 746\cf0 	    \{\
   \cf2 747\cf0 		
\f2\b my
\f0\b0  \cf6 $fr_forw\cf0  = \cf5 scalar\cf0 ( \cf6 @lambda_curr_forw\cf0  ); \
   \cf2 748\cf0 		
\f2\b my
\f0\b0  \cf6 $fr_back\cf0  = \cf5 scalar\cf0 ( \cf6 @lambda_curr_back\cf0  ); \
   \cf2 749\cf0 		\cf6 $fr_curr\cf0  = \cf6 $fr_forw\cf0  + \cf6 $fr_back\cf0 ;\
   \cf2 750\cf0 		
\f2\b print
\f0\b0  \cf4 "[new sum: (<-) $fr_back + $fr_forw (->) = $fr_curr]\cf7 \\n\cf4 "\cf0 ;\
   \cf2 751\cf0 		
\f2\b return
\f0\b0  \cf6 $fr_curr\cf0 ;\
   \cf2 752\cf0 	    \}\
   \cf2 753\cf0 	\}\
   \cf2 754\cf0 	\
   \cf2 755\cf0 	\
   \cf2 756\cf0 	\
   \cf2 757\cf0 	
\f2\b sub
\f0\b0  \cf5 SW_CURR\cf0 ()\
   \cf2 758\cf0 	\{\
   \cf2 759\cf0 	    
\f2\b print
\f0\b0  \cf4 "SW_CURR: "\cf0 ;\
   \cf2 760\cf0 	    
\f2\b print
\f0\b0  \cf4 "[ $TPS\{SHOOTING\}\{TYPE\} ] "\cf0 ;\
   \cf2 761\cf0 	    \
   \cf2 762\cf0 	    
\f2\b my
\f0\b0  \cf6 $sw_curr\cf0  = \cf2 0\cf0 ;\
   \cf2 763\cf0 	    
\f2\b my
\f0\b0  \cf6 $pstep6\cf0   = &\cf5 numtostr\cf0 (\cf6 $STEP\cf0 -\cf2 1\cf0 ,\cf2 6\cf0 );\
   \cf2 764\cf0 	    \
   \cf2 765\cf0 	    
\f1\i \cf3 #load lambdas for previous and current trajectories################################## 
\f0\i0 \cf0 \
   \cf2 766\cf0 	    
\f2\b my
\f0\b0  \cf6 $awk_col\cf0  = \cf6 $BIAS\cf0 \{PAR\} + \cf2 1\cf0 ;\
   \cf2 767\cf0 	    
\f2\b my
\f0\b0  \cf6 @lambda_prev\cf0  = split \cf4 "\cf7 \\n\cf4 "\cf0 , `awk \cf7 \\'\cf0 \{
\f2\b print
\f0\b0  \\$\cf6 $awk_col\cf0 \}\cf7 \\'\cf0  \cf6 $OPATH\cf0 \{PAR\}\cf6 $pstep6\cf0 .par`;\
   \cf2 768\cf0 	    chomp \cf6 @lambda_prev\cf0 ; shift \cf6 @lambda_prev\cf0 ;\
   \cf2 769\cf0 	    
\f2\b my
\f0\b0  \cf6 @lambda_curr_forw\cf0  = split \cf4 "\cf7 \\n\cf4 "\cf0 , `awk \cf7 \\'\cf0 \{
\f2\b print
\f0\b0  \\$\cf6 $awk_col\cf0 \}\cf7 \\'\cf0  \cf6 $OPATH\cf0 \{PAR\}/\cf6 $STEP\cf0 .forw`;\
   \cf2 770\cf0 	    chomp \cf6 @lambda_curr_forw\cf0 ; shift \cf6 @lambda_curr_forw\cf0 ;\
   \cf2 771\cf0 	    
\f2\b my
\f0\b0  \cf6 @lambda_curr_back\cf0  = split \cf4 "\cf7 \\n\cf4 "\cf0 , `awk \cf7 \\'\cf0 \{
\f2\b print
\f0\b0  \\$\cf6 $awk_col\cf0 \}\cf7 \\'\cf0  \cf6 $OPATH\cf0 \{PAR\}/\cf6 $STEP\cf0 .back`;\
   \cf2 772\cf0 	    chomp \cf6 @lambda_curr_back\cf0 ; shift \cf6 @lambda_curr_back\cf0 ;\
   \cf2 773\cf0 	        \
   \cf2 774\cf0 	    
\f1\i \cf3 #we need to split @lambda_prev in two arrays -> before and after CUT_G. 
\f0\i0 \cf0 \
   \cf2 775\cf0 	    
\f1\i \cf3 #CUT_G itself will be counted in STEP.forw or STEP.back so we dont include it 
\f0\i0 \cf0 \
   \cf2 776\cf0 	    
\f2\b my
\f0\b0  \cf6 @lambda_prev_a\cf0  = \cf6 @lambda_prev\cf0 [\cf2 0\cf0  .. (\cf6 $CUT_G\cf0 -\cf2 1\cf0 )] ;\
   \cf2 777\cf0 	    
\f2\b my
\f0\b0  \cf6 @lambda_prev_b\cf0  = \cf6 @lambda_prev\cf0 [(\cf6 $CUT_G\cf0 +\cf2 1\cf0 ) .. \cf6 $#lambda_prev\cf0 ] ;\
   \cf2 778\cf0 	\
   \cf2 779\cf0 	    
\f2\b if
\f0\b0 ( \cf6 $TPS\cf0 \{SHOOTING\}\{TYPE\} =~ 
\f2\b /1WAY/
\f0\b0 )\
   \cf2 780\cf0 	    \{\
   \cf2 781\cf0 		
\f2\b if
\f0\b0 (\cf6 $INIT_FORW_BACK\cf0  == \cf2 1\cf0  ) 
\f1\i \cf3 #than we were shooting forward
\f0\i0 \cf0 \
   \cf2 782\cf0 		\{\
   \cf2 783\cf0 		    
\f2\b my
\f0\b0  \cf6 $sw_old\cf0  = sprintf \cf4 "%.2f"\cf0 , &\cf5 SW\cf0 (\\\cf6 @lambda_prev_a\cf0 );\
   \cf2 784\cf0 		    
\f2\b my
\f0\b0  \cf6 $sw_new\cf0  = sprintf \cf4 "%.2f"\cf0 , &\cf5 SW\cf0 (\\\cf6 @lambda_curr_forw\cf0 ); \
   \cf2 785\cf0 		    \cf6 $sw_curr\cf0    = sprintf \cf4 "%.2f"\cf0 , \cf6 $sw_old\cf0  + \cf6 $sw_new\cf0 ;\
   \cf2 786\cf0 	
\f1\i \cf3 #	    print "[frames:  ".(@lambda_prev_a+0)." + ".(@lambda_curr_forw+0)."] ";
\f0\i0 \cf0 \
   \cf2 787\cf0 		    
\f2\b print
\f0\b0  \cf4 "[new sum: $sw_old + $sw_new (->) = $sw_curr]\cf7 \\n\cf4 "\cf0 ;\
   \cf2 788\cf0 		    
\f2\b return
\f0\b0  \cf6 $sw_curr\cf0 ;\
   \cf2 789\cf0 		\}\
   \cf2 790\cf0 		\
   \cf2 791\cf0 		
\f2\b if
\f0\b0 (\cf6 $INIT_FORW_BACK\cf0  == \cf2 0\cf0  ) 
\f1\i \cf3 #than we were shooting backward
\f0\i0 \cf0 \
   \cf2 792\cf0 		\{\
   \cf2 793\cf0 		    
\f2\b my
\f0\b0  \cf6 $sw_old\cf0  = sprintf \cf4 "%.2f"\cf0 , &\cf5 SW\cf0 (\\\cf6 @lambda_prev_b\cf0 );\
   \cf2 794\cf0 		    
\f2\b my
\f0\b0  \cf6 $sw_new\cf0  = sprintf \cf4 "%.2f"\cf0 , &\cf5 SW\cf0 (\\\cf6 @lambda_curr_back\cf0 ); \
   \cf2 795\cf0 		    \cf6 $sw_curr\cf0    = sprintf \cf4 "%.2f"\cf0 , \cf6 $sw_old\cf0  + \cf6 $sw_new\cf0 ;\
   \cf2 796\cf0 	
\f1\i \cf3 #	    print "[frames:  ".(@lambda_curr_back+0)." + ".(@lambda_prev_b+0)."] ";
\f0\i0 \cf0 \
   \cf2 797\cf0 		    
\f2\b print
\f0\b0  \cf4 "[new sum: (<-) $sw_new + $sw_old = $sw_curr]\cf7 \\n\cf4 "\cf0 ;\
   \cf2 798\cf0 		    
\f2\b return
\f0\b0  \cf6 $sw_curr\cf0 ;\
   \cf2 799\cf0 		\}\
   \cf2 800\cf0 	    \}\
   \cf2 801\cf0 	\
   \cf2 802\cf0 	    
\f2\b if
\f0\b0 ( \cf6 $TPS\cf0 \{SHOOTING\}\{TYPE\} =~ 
\f2\b /2WAY/
\f0\b0 )\
   \cf2 803\cf0 	    \{\
   \cf2 804\cf0 		
\f2\b my
\f0\b0  \cf6 $sw_forw\cf0  = sprintf \cf4 "%.2f"\cf0 , &\cf5 SW\cf0 (\\\cf6 @lambda_curr_forw\cf0 ); \
   \cf2 805\cf0 		
\f2\b my
\f0\b0  \cf6 $sw_back\cf0  = sprintf \cf4 "%.2f"\cf0 , &\cf5 SW\cf0 (\\\cf6 @lambda_curr_back\cf0 ); \
   \cf2 806\cf0 		\cf6 $sw_curr\cf0  = sprintf \cf4 "%.2f"\cf0 , \cf6 $sw_forw\cf0  + \cf6 $sw_back\cf0 ;\
   \cf2 807\cf0 	
\f1\i \cf3 #	print "[frames:  ".(@lambda_curr_back+0)." + ".(@lambda_curr_forw+0)."] ";
\f0\i0 \cf0 \
   \cf2 808\cf0 		
\f2\b print
\f0\b0  \cf4 "[new sum: (<-) $sw_back + $sw_forw (->) = $sw_curr]\cf7 \\n\cf4 "\cf0 ;\
   \cf2 809\cf0 		
\f2\b return
\f0\b0  \cf6 $sw_curr\cf0 ;\
   \cf2 810\cf0 	    \}\
   \cf2 811\cf0 	\
   \cf2 812\cf0 	\}\
   \cf2 813\cf0 	\
   \cf2 814\cf0 	
\f1\i \cf3 #function giving length of pathway that would be created if glued with old one
\f0\i0 \cf0 \
   \cf2 815\cf0 	
\f2\b sub
\f0\b0  \cf5 CURRENT_LENGTH\cf0 ()\
   \cf2 816\cf0 	\{\
   \cf2 817\cf0 	    \
   \cf2 818\cf0 	    
\f2\b print
\f0\b0  \cf4 ">>CURRENT_LENGTH:"\cf0 ;\
   \cf2 819\cf0 	    
\f2\b if
\f0\b0 ( \cf6 $TPS\cf0 \{SHOOTING\}\{TYPE\} =~ 
\f2\b /1WAY/
\f0\b0 )\
   \cf2 820\cf0 	    \{\
   \cf2 821\cf0 		
\f2\b if
\f0\b0 (\cf6 $INIT_FORW_BACK\cf0  == \cf2 1\cf0  ) 
\f1\i \cf3 #than we were shooting forward
\f0\i0 \cf0 \
   \cf2 822\cf0 		\{\
   \cf2 823\cf0 		    
\f2\b my
\f0\b0  \cf6 $new_frames\cf0  = &\cf5 get_numof_frames\cf0 (\cf4 "$PATH\{TPSRUNF\}run.trr"\cf0 );\
   \cf2 824\cf0 		    
\f2\b print
\f0\b0  \cf4 "[new=$new_frames]"\cf0 ;\
   \cf2 825\cf0 		    
\f2\b print
\f0\b0  \cf4 "[shoot_point=$CUT_G]"\cf0 ;\
   \cf2 826\cf0 		    
\f2\b print
\f0\b0  \cf4 "[curr_len="\cf0 .(\cf6 $new_frames\cf0  + \cf6 $CUT_G\cf0 ).\cf4 "]\cf7 \\n\cf4 "\cf0 ;\
   \cf2 827\cf0 		    
\f2\b return
\f0\b0  \cf6 $new_frames\cf0  + \cf6 $CUT_G\cf0 ;\
   \cf2 828\cf0 		\}\
   \cf2 829\cf0 		\
   \cf2 830\cf0 		
\f2\b if
\f0\b0 (\cf6 $INIT_FORW_BACK\cf0  == \cf2 0\cf0  ) 
\f1\i \cf3 #than we were shooting backward
\f0\i0 \cf0 \
   \cf2 831\cf0 		\{\
   \cf2 832\cf0 		    
\f2\b my
\f0\b0  \cf6 $new_frames\cf0  = &\cf5 get_numof_frames\cf0 (\cf4 "$PATH\{TPSRUNB\}run.trr"\cf0 );\
   \cf2 833\cf0 		    
\f2\b print
\f0\b0  \cf4 "[new=$new_frames]"\cf0 ;\
   \cf2 834\cf0 		    
\f2\b my
\f0\b0  \cf6 $prev_par\cf0  = \cf6 $OPATH\cf0 \{PAR\}.&\cf5 numtostr\cf0 (\cf6 $STEP\cf0 -\cf2 1\cf0 ,\cf2 6\cf0 ).\cf4 ".par"\cf0 ;\
   \cf2 835\cf0 		    
\f2\b my
\f0\b0  \cf6 $prev_traj_length\cf0  = `wc -l \cf6 $prev_par\cf0  | awk \cf7 \\'\cf0 \{
\f2\b print
\f0\b0  \\\cf6 $1\cf0 \}\cf7 \\'\cf0 `;\
   \cf2 836\cf0 		    chomp \cf6 $prev_traj_length\cf0 ;\
   \cf2 837\cf0 		    \cf6 $prev_traj_length\cf0 --; 
\f1\i \cf3 #header
\f0\i0 \cf0 \
   \cf2 838\cf0 		    
\f2\b print
\f0\b0  \cf4 "[prev_path_len=$prev_traj_length]"\cf0 ;\
   \cf2 839\cf0 		    
\f2\b print
\f0\b0  \cf4 "[shoot_point=$CUT_G]"\cf0 ;\
   \cf2 840\cf0 		    
\f2\b print
\f0\b0  \cf4 "[curr_len="\cf0 .(\cf6 $new_frames\cf0  + ( \cf6 $prev_traj_length\cf0  - \cf6 $CUT_G\cf0 )).\cf4 "]\cf7 \\n\cf4 "\cf0 ;\
   \cf2 841\cf0 		    
\f2\b return
\f0\b0  \cf6 $new_frames\cf0  + ( \cf6 $prev_traj_length\cf0  - \cf6 $CUT_G\cf0 );\
   \cf2 842\cf0 		\}\
   \cf2 843\cf0 	    \}\
   \cf2 844\cf0 	    \
   \cf2 845\cf0 	    
\f2\b if
\f0\b0 ( \cf6 $TPS\cf0 \{SHOOTING\}\{TYPE\} =~ 
\f2\b /2WAY/
\f0\b0 )\
   \cf2 846\cf0 	    \{\
   \cf2 847\cf0 		
\f2\b my
\f0\b0  \cf6 $new_fframes\cf0  = &\cf5 get_numof_frames\cf0 (\cf4 "$PATH\{TPSRUNF\}run.trr"\cf0 );\
   \cf2 848\cf0 		
\f2\b my
\f0\b0  \cf6 $new_bframes\cf0  = &\cf5 get_numof_frames\cf0 (\cf4 "$PATH\{TPSRUNB\}run.trr"\cf0 );\
   \cf2 849\cf0 		
\f2\b print
\f0\b0  \cf4 "[new_forw=$new_fframes][new_back=$new_bframes]"\cf0 ;\
   \cf2 850\cf0 		
\f2\b print
\f0\b0  \cf4 "[shoot_point=$CUT_G]"\cf0 ;\
   \cf2 851\cf0 		
\f2\b print
\f0\b0  \cf4 "[curr_len="\cf0 .(\cf6 $new_fframes\cf0  + \cf6 $new_bframes\cf0 ).\cf4 "]\cf7 \\n\cf4 "\cf0 ;\
   \cf2 852\cf0 		
\f2\b return
\f0\b0  \cf6 $new_fframes\cf0  + \cf6 $new_bframes\cf0 ;\
   \cf2 853\cf0 	    \}\
   \cf2 854\cf0 	\
   \cf2 855\cf0 	    
\f2\b return
\f0\b0  -\cf2 1\cf0 ;\
   \cf2 856\cf0 	\}\
   \cf2 857\cf0 	\
   \cf2 858\cf0 	\
   \cf2 859\cf0 	\
   \cf2 860\cf0 	\
   \cf2 861\cf0 	\
   \cf2 862\cf0 	
\f1\i \cf3 ############################################################
\f0\i0 \cf0 \
   \cf2 863\cf0 	
\f1\i \cf3 ############################################################
\f0\i0 \cf0 \
   \cf2 864\cf0 	\
   \cf2 865\cf0 	
\f2\b sub
\f0\b0  \cf5 write_step_summary\cf0 () 
\f1\i \cf3 #parf
\f0\i0 \cf0 \
   \cf2 866\cf0 	\{\
   \cf2 867\cf0 	    
\f2\b my
\f0\b0  \cf6 $parf\cf0  = \cf5 shift\cf0 ;\
   \cf2 868\cf0 	    
\f2\b my
\f0\b0  \cf6 $this_step_path\cf0  = ( &\cf5 get_par_path\cf0 (\cf6 $parf\cf0 ,\\\cf6 %PARAM\cf0 ) =~ 
\f2\b /\\[(.+)\\]/
\f0\b0 g )[\cf2 0\cf0 ];\
   \cf2 869\cf0 	    
\f2\b my
\f0\b0  \cf6 $this_step_ess_path\cf0  = &\cf5 get_essential_path\cf0 (\cf6 $this_step_path\cf0 ,\\\cf6 @RECROSSING_RULES\cf0 );\
   \cf2 870\cf0 	    \
   \cf2 871\cf0 	    
\f2\b print
\f0\b0  RED, \cf4 "\cf7 \\n\cf4 >>>>write_step_summary: BEGIN (DEBUG)<<<<<<<<<\cf7 \\n\cf4 "\cf0 , RESET 
\f2\b if
\f0\b0  \cf6 $DEBUG_ON\cf0 ;\
   \cf2 872\cf0 	    
\f2\b if
\f0\b0 ( !-e \cf6 $FILE\cf0 \{STEP_SUMUP\} )\
   \cf2 873\cf0 	    \{\
   \cf2 874\cf0 		open SUMF, \cf4 ">>$FILE\{STEP_SUMUP\}"\cf0 ;\
   \cf2 875\cf0 		printf SUMF \cf4 "%-7s"\cf0 ,\cf4 "STEP"\cf0 ; \
   \cf2 876\cf0 		printf SUMF \cf4 "%-9s"\cf0 ,\cf4 "SWMAX"\cf0 ; \
   \cf2 877\cf0 		printf SUMF \cf4 "%-10s"\cf0 ,\cf4 "SHOOTP"\cf0 ; \
   \cf2 878\cf0 		printf SUMF \cf4 "%-10s"\cf0 ,\cf4 "SHTYPE"\cf0 ;\
   \cf2 879\cf0 		printf SUMF \cf4 "%-5s%-5s%-5s%-5s"\cf0 ,\cf4 "RUNF"\cf0 ,\cf4 "RUNB"\cf0 ,\cf4 "ACCF"\cf0 ,\cf4 "ACCB"\cf0 ;\
   \cf2 880\cf0 		printf SUMF \cf4 "%-7s"\cf0 ,\cf4 "LENTRR"\cf0 ;  \
   \cf2 881\cf0 		printf SUMF \cf4 "%-15s"\cf0 ,\cf4 "PATH "\cf0 ;\
   \cf2 882\cf0 	
\f1\i \cf3 #	printf SUMF "%-20s","TRTIMES";
\f0\i0 \cf0 \
   \cf2 883\cf0 		printf SUMF \cf4 "\cf7 \\n\cf4 "\cf0 ;\
   \cf2 884\cf0 		close \cf5 SUMF\cf0 ;\
   \cf2 885\cf0 	    \}\
   \cf2 886\cf0 	    open SUMF, \cf4 ">>$FILE\{STEP_SUMUP\}"\cf0 ;\
   \cf2 887\cf0 	    \
   \cf2 888\cf0 	    
\f2\b my
\f0\b0  \cf6 $accf\cf0  = \cf6 $ACCEPTED\cf0  =~
\f2\b /forw/
\f0\b0  ? \cf2 1\cf0  : \cf2 0\cf0 ;\
   \cf2 889\cf0 	    
\f2\b my
\f0\b0  \cf6 $accb\cf0  = \cf6 $ACCEPTED\cf0  =~
\f2\b /back/
\f0\b0  ? \cf2 1\cf0  : \cf2 0\cf0 ;\
   \cf2 890\cf0 	    
\f2\b my
\f0\b0  \cf6 $runf\cf0  = \cf6 $INIT_FORW_BACK\cf0 ==\cf2 1\cf0  ? \cf2 1\cf0  : \cf2 0\cf0 ;\
   \cf2 891\cf0 	    
\f2\b my
\f0\b0  \cf6 $runb\cf0  = \cf6 $INIT_FORW_BACK\cf0 ==\cf2 1\cf0  ? \cf2 0\cf0  : \cf2 1\cf0 ;\
   \cf2 892\cf0 	    
\f2\b if
\f0\b0  (\cf6 $TPS\cf0 \{SHOOTING\}\{TYPE\}=~
\f2\b /2WAY/
\f0\b0 ) \{\cf6 $runf\cf0 =\cf2 1\cf0 ; \cf6 $runb\cf0 =\cf2 1\cf0 ;\}\
   \cf2 893\cf0 	\
   \cf2 894\cf0 	 
\f1\i \cf3 #   my $state_str = &get_state_str($FILE\{XYB\},$FILE\{XYF\},\\%PARAM);
\f0\i0 \cf0 \
   \cf2 895\cf0 	 
\f1\i \cf3 #   $state_str =~ /(\\[.*\\])\\s+(\\\{.*\\\})/;
\f0\i0 \cf0 \
   \cf2 896\cf0 	 
\f1\i \cf3 #   my $path = $1;
\f0\i0 \cf0 \
   \cf2 897\cf0 	 
\f1\i \cf3 #   my $times = $2;
\f0\i0 \cf0 \
   \cf2 898\cf0 	\
   \cf2 899\cf0 	    
\f2\b my
\f0\b0  \cf6 $step6\cf0  = &\cf5 numtostr\cf0 (\cf6 $STEP\cf0 ,\cf2 6\cf0 );\
   \cf2 900\cf0 	    
\f2\b my
\f0\b0  \cf6 $pathl\cf0  = (`wc -l \cf6 $parf\cf0 `=~ 
\f2\b /(\\d+)/
\f0\b0 g )[\cf2 0\cf0 ];\
   \cf2 901\cf0 	    \
   \cf2 902\cf0 	 \
   \cf2 903\cf0 	    printf SUMF \cf4 "%-7s"\cf0 ,\cf6 $step6\cf0 ;\
   \cf2 904\cf0 	    printf SUMF \cf4 "%-9.2f"\cf0 , \cf6 $SW_MAX\cf0 ; \
   \cf2 905\cf0 	    printf SUMF \cf4 "%-10d"\cf0 ,\cf6 $CUT_G\cf0 ; \
   \cf2 906\cf0 	    printf SUMF \cf4 "%-10s"\cf0 ,\cf6 $TPS\cf0 \{SHOOTING\}\{TYPE\}; \
   \cf2 907\cf0 	    printf SUMF \cf4 "%-5d%-5d%-5d%-5d"\cf0 ,\cf6 $runf\cf0 ,\cf6 $runb\cf0 ,\cf6 $accf\cf0 ,\cf6 $accb\cf0 ;\
   \cf2 908\cf0 	    printf SUMF \cf4 "%-7s"\cf0 ,\cf6 $pathl\cf0 ;\
   \cf2 909\cf0 	    printf SUMF \cf4 "%-15s"\cf0 ,\cf6 $this_step_ess_path\cf0 .\cf4 " "\cf0 ;\
   \cf2 910\cf0 	    \
   \cf2 911\cf0 	 
\f1\i \cf3 #  printf SUMF "%-20s",$times;
\f0\i0 \cf0 \
   \cf2 912\cf0 	    printf SUMF \cf4 "\cf7 \\n\cf4 "\cf0 ;\
   \cf2 913\cf0 	    close \cf5 SUMF\cf0 ;\
   \cf2 914\cf0 	    
\f2\b print
\f0\b0  RED, \cf4 "\cf7 \\n\cf4 >>>>write_step_summary: END (DEBUG)<<<<<<<<<<<\cf7 \\n\cf4 "\cf0 , RESET 
\f2\b if
\f0\b0  \cf6 $DEBUG_ON\cf0 ;\
   \cf2 915\cf0 	\}\
   \cf2 916\cf0 	\
   \cf2 917\cf0 	\
\
\
   \cf2 935\cf0 	\
\
\
   \cf2 971\cf0 	\
   \cf2 972\cf0 	
\f2\b sub
\f0\b0  \cf5 check_if_step_OK\cf0 ()\
   \cf2 973\cf0 	\{\
   \cf2 974\cf0 	    
\f2\b print
\f0\b0  RED, \cf4 "\cf7 \\n\cf4 >>>>check_if_step_OK: BEGIN (DEBUG)<<<<<<<<<\cf7 \\n\cf4 "\cf0 , RESET 
\f2\b if
\f0\b0  \cf6 $DEBUG_ON\cf0 ;\
   \cf2 975\cf0 	    
\f2\b return if
\f0\b0  \cf6 $STORED\cf0 ==\cf2 0\cf0 ; \
   \cf2 976\cf0 	    
\f1\i \cf3 #check wether all files that should be there - are there
\f0\i0 \cf0 \
   \cf2 977\cf0 	    die \cf4 "file $FILE\{XYB\} doesn't exist. check FAILED."\cf0  
\f2\b if
\f0\b0  !-e \cf6 $FILE\cf0 \{XYB\};\
   \cf2 978\cf0 	    die \cf4 "file $FILE\{XYF\} doesn't exist. check FAILED."\cf0  
\f2\b if
\f0\b0  !-e \cf6 $FILE\cf0 \{XYF\};\
   \cf2 979\cf0 	\
   \cf2 980\cf0 	    
\f2\b my
\f0\b0  \cf6 $STEP6\cf0  = &\cf5 numtostr\cf0 (\cf6 $STEP\cf0 ,\cf2 6\cf0 );\
   \cf2 981\cf0 	    
\f2\b my
\f0\b0  \cf6 $trr\cf0  = \cf4 "$OPATH\{TRR\}$STEP6.trr"\cf0 ;\
   \cf2 982\cf0 	    die \cf4 "file $trr doesn't exist. check FAILED."\cf0  
\f2\b if
\f0\b0  !-e \cf6 $trr\cf0 ;\
   \cf2 983\cf0 	    
\f2\b print
\f0\b0  \cf4 "done\cf7 \\n\cf4 "\cf0 ;\
   \cf2 984\cf0 	    
\f2\b print
\f0\b0  RED, \cf4 ">>>>check_if_step_OK: END (DEBUG)<<<<<<<<<<<\cf7 \\n\cf4 "\cf0 , RESET 
\f2\b if
\f0\b0  \cf6 $DEBUG_ON\cf0 ;\
   \cf2 985\cf0 	  \
   \cf2 986\cf0 	\}\
   \cf2 987\cf0 	\
   \cf2 988\cf0 	
\f2\b sub
\f0\b0  \cf5 store_rejected\cf0 ()\
   \cf2 989\cf0 	\{\
   \cf2 990\cf0 	    
\f2\b print
\f0\b0  RED, \cf4 "\cf7 \\n\cf4 >>>>~sr~store_rejected: BEGIN (DEBUG)<<<<<<<<<\cf7 \\n\cf4 "\cf0 , RESET 
\f2\b if
\f0\b0  \cf6 $DEBUG_ON\cf0 ;\
   \cf2 991\cf0 	    
\f2\b my
\f0\b0  \cf6 $step6\cf0  = &\cf5 numtostr\cf0 (\cf6 $STEP\cf0 ,\cf2 6\cf0 );\
   \cf2 992\cf0 	    
\f2\b my
\f0\b0  \cf6 $step\cf0  = \cf6 $STEP\cf0 +\cf2 0\cf0 ;     \
   \cf2 993\cf0 	    
\f1\i \cf3 #concatenated files are needed in case of 2way shooting 
\f0\i0 \cf0 \
   \cf2 994\cf0 	    
\f2\b my
\f0\b0  \cf6 $parf\cf0  = \cf6 $OPATH\cf0 \{PAR\}.&\cf5 numtostr\cf0 (\cf6 $STEP\cf0 ,\cf2 6\cf0 ).\cf4 ".par"\cf0 ;  
\f1\i \cf3 #concatenated par 
\f0\i0 \cf0 \
   \cf2 995\cf0 	    
\f2\b my
\f0\b0  \cf6 $trrf\cf0  = \cf6 $OPATH\cf0 \{TRR\}.&\cf5 numtostr\cf0 (\cf6 $STEP\cf0 ,\cf2 6\cf0 ).\cf4 ".trr"\cf0 ;  
\f1\i \cf3 #concatenated trr 
\f0\i0 \cf0 \
   \cf2 996\cf0 	\
   \cf2 997\cf0 	    
\f1\i \cf3 #get the amount of already stored steps
\f0\i0 \cf0 \
   \cf2 998\cf0 	    
\f2\b my
\f0\b0  \cf6 $n\cf0  = `ls -\cf2 1\cf0  \cf6 $OPATH\cf0 \{REJ\} | grep \cf6 $step6\cf0  | grep xtc | wc -l` + \cf2 0\cf0 ;\
   \cf2 999\cf0 	    
\f2\b my
\f0\b0  \cf6 $suffix\cf0  = \cf5 chr\cf0 (\cf5 ord\cf0 (\cf4 'a'\cf0 )+\cf6 $n\cf0 );\
  \cf2 1000\cf0 	    \
  \cf2 1001\cf0 	    
\f2\b if
\f0\b0 (\cf6 $TPS\cf0 \{SHOOTING\}\{TYPE\}=~
\f2\b /1WAY/
\f0\b0 )\
  \cf2 1002\cf0 	    \{\
  \cf2 1003\cf0 		
\f2\b my
\f0\b0  \cf6 $exp1\cf0  = \cf6 $INIT_FORW_BACK\cf0 ==\cf2 1\cf0  ? \cf4 "f"\cf0  : \cf4 "b"\cf0 ;\
  \cf2 1004\cf0 		
\f2\b my
\f0\b0  \cf6 $exp\cf0   = \cf6 $INIT_FORW_BACK\cf0 ==\cf2 1\cf0  ? \cf4 "forw"\cf0  : \cf4 "back"\cf0 ;\
  \cf2 1005\cf0 	\
  \cf2 1006\cf0 		
\f1\i \cf3 #the parfile/xtc names will be:
\f0\i0 \cf0 \
  \cf2 1007\cf0 		
\f2\b my
\f0\b0  \cf6 $pname\cf0  = \cf6 $step6\cf0 .\cf4 "_"\cf0 .\cf6 $suffix\cf0 .\cf4 "_"\cf0 .\cf6 $exp1\cf0 .\cf4 ".par"\cf0 ;\
  \cf2 1008\cf0 		
\f2\b my
\f0\b0  \cf6 $xname\cf0  = \cf6 $step6\cf0 .\cf4 "_"\cf0 .\cf6 $suffix\cf0 .\cf4 "_"\cf0 .\cf6 $exp1\cf0 .\cf4 ".xtc"\cf0 ;\
  \cf2 1009\cf0 	\
  \cf2 1010\cf0 		
\f1\i \cf3 #copy the forw/back file respectively 
\f0\i0 \cf0 \
  \cf2 1011\cf0 		
\f2\b if
\f0\b0 (\cf6 $TPS\cf0 \{STORE\}\{REJECTED\}\{PAR\}=~
\f2\b /YES/
\f0\b0 i)\
  \cf2 1012\cf0 		\{\
  \cf2 1013\cf0 		    system \cf4 "cp $OPATH\{PAR\}$step.$exp $OPATH\{REJ\}$pname"\cf0 ;\
  \cf2 1014\cf0 		    
\f1\i \cf3 #print "~sr~SOURCE ---> $OPATH\{PAR\}$step.$exp\\n";
\f0\i0 \cf0 \
  \cf2 1015\cf0 		    
\f1\i \cf3 #print "~sr~DEST -----> $OPATH\{REJ\}$pname\\n";
\f0\i0 \cf0 \
  \cf2 1016\cf0 		    
\f1\i \cf3 #print "~sr~".join( "|", split("\\n", `ls -1 $OPATH\{PAR\} | grep forw `) )."\\n" ;
\f0\i0 \cf0 \
  \cf2 1017\cf0 		    
\f1\i \cf3 #print "~sr~".join( "|", split("\\n", `ls -1 $OPATH\{PAR\} | grep back `) )."\\n" ;
\f0\i0 \cf0 \
  \cf2 1018\cf0 		\}\
  \cf2 1019\cf0 		\
  \cf2 1020\cf0 		
\f1\i \cf3 #trjconv to xtc the run file from the correct tps folder 
\f0\i0 \cf0 \
  \cf2 1021\cf0 		
\f2\b if
\f0\b0  (\cf6 $TPS\cf0 \{STORE\}\{REJECTED\}\{XTC\}=~
\f2\b /YES/
\f0\b0 i) \
  \cf2 1022\cf0 		\{\
  \cf2 1023\cf0 		    
\f2\b my
\f0\b0  \cf6 $trr\cf0  = \cf6 $INIT_FORW_BACK\cf0 ==\cf2 1\cf0  ? \cf4 "$PATH\{TPSRUNF\}run.trr"\cf0  : \cf4 "$PATH\{TPSRUNB\}run.trr"\cf0 ;\
  \cf2 1024\cf0 		    system \cf4 "$PATH\{GROMACS\}/trjconv -f $trr -o $OPATH\{REJ\}$xname 1>$OPATH\{LOG\}trjconv_rej.out 2>$OPATH\{LOG\}trjconv_rej.err"\cf0 ;\
  \cf2 1025\cf0 		\}\
  \cf2 1026\cf0 		\
  \cf2 1027\cf0 	    \}\
  \cf2 1028\cf0 	    
\f2\b else
\f0\b0 \
  \cf2 1029\cf0 	    \{\
  \cf2 1030\cf0 		
\f2\b if
\f0\b0 (\cf6 $TPS\cf0 \{SHOOTING\}\{TYPE\}=~
\f2\b /2WAY/
\f0\b0 ) \
  \cf2 1031\cf0 		\{\
  \cf2 1032\cf0 		    
\f1\i \cf3 #the parfile/xtc names will be:
\f0\i0 \cf0 \
  \cf2 1033\cf0 		    
\f2\b my
\f0\b0  \cf6 $pname\cf0  = \cf6 $step6\cf0 .\cf4 "_"\cf0 .\cf6 $suffix\cf0 .\cf4 "_bf.par"\cf0 ;\
  \cf2 1034\cf0 		    
\f2\b my
\f0\b0  \cf6 $xname\cf0  = \cf6 $step6\cf0 .\cf4 "_"\cf0 .\cf6 $suffix\cf0 .\cf4 "_bf.xtc"\cf0 ;\
  \cf2 1035\cf0 	\
  \cf2 1036\cf0 		    
\f1\i \cf3 #copy the concatenated par file
\f0\i0 \cf0 \
  \cf2 1037\cf0 		    
\f2\b if
\f0\b0 (\cf6 $TPS\cf0 \{STORE\}\{REJECTED\}\{PAR\}=~
\f2\b /YES/
\f0\b0 i)\
  \cf2 1038\cf0 		    \{\
  \cf2 1039\cf0 			system \cf4 "cp $parf $OPATH\{REJ\}$pname"\cf0 ;\
  \cf2 1040\cf0 			
\f2\b print
\f0\b0  \cf4 "~sr~error: $parf doesnt exist, storage of rejected unsuccessfull\cf7 \\n\cf4 "\cf0 ;\
  \cf2 1041\cf0 		    \}\
  \cf2 1042\cf0 	\
  \cf2 1043\cf0 		    
\f1\i \cf3 #trjconv to xtc the concatenated trr file
\f0\i0 \cf0 \
  \cf2 1044\cf0 		    
\f2\b if
\f0\b0  (\cf6 $TPS\cf0 \{STORE\}\{REJECTED\}\{XTC\}=~
\f2\b /YES/
\f0\b0 i) \
  \cf2 1045\cf0 		    \{\
  \cf2 1046\cf0 			system \cf4 "$PATH\{GROMACS\}/trjconv -f $trrf -o $OPATH\{REJ\}$xname 1>$OPATH\{LOG\}trjconv_rej.out 2>$OPATH\{LOG\}trjconv_rej.err"\cf0 ;\
  \cf2 1047\cf0 			
\f2\b print
\f0\b0  \cf4 "~sr~error: $trrf doesnt exist, storage of rejected unsuccessfull\cf7 \\n\cf4 "\cf0 ;\
  \cf2 1048\cf0 		    \}\
  \cf2 1049\cf0 		\}\
  \cf2 1050\cf0 	    \}\
  \cf2 1051\cf0 	\
  \cf2 1052\cf0 	    \
  \cf2 1053\cf0 	    &\cf5 dvline\cf0 ();\
  \cf2 1054\cf0 	    
\f2\b print
\f0\b0  RED, \cf4 ">>>>~sr~store_rejected: END (DEBUG)<<<<<<<<<<<\cf7 \\n\cf4 "\cf0 , RESET 
\f2\b if
\f0\b0  \cf6 $DEBUG_ON\cf0 ;\
  \cf2 1055\cf0 	\}\
  \cf2 1056\cf0 	\
  \cf2 1057\cf0 	\
  \cf2 1058\cf0 	
\f2\b sub
\f0\b0  \cf5 store_dat_files_all_steps\cf0 ()\
  \cf2 1059\cf0 	\{\
  \cf2 1060\cf0 	    
\f2\b print
\f0\b0  RED, \cf4 "\cf7 \\n\cf4 >>>>store_dat_files_all_steps: BEGIN (DEBUG)<<<<<<<<<\cf7 \\n\cf4 "\cf0 , RESET 
\f2\b if
\f0\b0  \cf6 $DEBUG_ON\cf0 ;\
  \cf2 1061\cf0 	    
\f2\b print
\f0\b0  \cf4 "Storing dat files (all steps)... "\cf0 ;\
  \cf2 1062\cf0 	    
\f2\b my
\f0\b0  \cf6 $curr_time\cf0  = \cf5 time\cf0 ;\
  \cf2 1063\cf0 	    
\f2\b my
\f0\b0  \cf6 $delta_t\cf0  = \cf6 $curr_time\cf0  - \cf6 $T_START_CYCLE\cf0 ;\
  \cf2 1064\cf0 	    
\f2\b my
\f0\b0  \cf6 $step6\cf0  = &\cf5 numtostr\cf0 (\cf6 $STEP\cf0 ,\cf2 6\cf0 );\
  \cf2 1065\cf0 	\
  \cf2 1066\cf0 	    
\f1\i \cf3 #writing time.dat = real time sim info##########
\f0\i0 \cf0 \
  \cf2 1067\cf0 	    
\f1\i \cf3 #mainly for statistics and sim time predistion##
\f0\i0 \cf0 \
  \cf2 1068\cf0 	    
\f1\i \cf3 #WRITTEN ALWAYS even if NOT ACCEPTED############
\f0\i0 \cf0 \
  \cf2 1069\cf0 	    open  TIMES, \cf4 ">>$FILE\{STAT_TIME\}"\cf0 ;\
  \cf2 1070\cf0 	    
\f2\b print
\f0\b0  TIMES \cf4 "$step6 $curr_time $delta_t\cf7 \\n\cf4 "\cf0 ;\
  \cf2 1071\cf0 	    close \cf5 TIMES\cf0 ;\
  \cf2 1072\cf0 	\
  \cf2 1073\cf0 	    
\f1\i \cf3 #acceptance file : STEP BACC FACC <-str->#########
\f0\i0 \cf0 \
  \cf2 1074\cf0 	    
\f1\i \cf3 #to calculate rates we need to know how many was##
\f0\i0 \cf0 \
  \cf2 1075\cf0 	    
\f1\i \cf3 #not accepted ?? #################################
\f0\i0 \cf0 \
  \cf2 1076\cf0 	    
\f1\i \cf3 #WRITTEN ALWAYS even if NOT ACCEPTED##############
\f0\i0 \cf0 \
  \cf2 1077\cf0 	    open  ACCF, \cf4 ">>$FILE\{STAT_ACC\}"\cf0 ;\
  \cf2 1078\cf0 	\
  \cf2 1079\cf0 	\
  \cf2 1080\cf0 	    
\f2\b my
\f0\b0  \cf6 $facc\cf0  = \cf6 $ACCEPTED\cf0 =~
\f2\b /forw/
\f0\b0  ? \cf2 1\cf0  : \cf2 0\cf0 ;\
  \cf2 1081\cf0 	    
\f2\b my
\f0\b0  \cf6 $bacc\cf0  = \cf6 $ACCEPTED\cf0 =~
\f2\b /back/
\f0\b0  ? \cf2 1\cf0  : \cf2 0\cf0 ;\
  \cf2 1082\cf0 	\
  \cf2 1083\cf0 	    
\f2\b my
\f0\b0  \cf6 $state_str\cf0  = &\cf5 get_state_str\cf0 (\cf6 $FILE\cf0 \{XYB\},\cf6 $FILE\cf0 \{XYF\},\\\cf6 %PARAM\cf0 );\
  \cf2 1084\cf0 	    
\f2\b print
\f0\b0  ACCF \cf4 "$step6 $bacc $facc $state_str\cf7 \\n\cf4 "\cf0 ;\
  \cf2 1085\cf0 	    close \cf5 ACCF\cf0 ;\
  \cf2 1086\cf0 	    \
  \cf2 1087\cf0 	    
\f2\b print
\f0\b0  \cf4 "done\cf7 \\n\cf4 "\cf0 ;\
  \cf2 1088\cf0 	    
\f2\b print
\f0\b0  RED, \cf4 ">>>>store_dat_files_all_steps: END (DEBUG)<<<<<<<<<<<\cf7 \\n\cf4 "\cf0 , RESET 
\f2\b if
\f0\b0  \cf6 $DEBUG_ON\cf0 ;\
  \cf2 1089\cf0 	\}\
  \cf2 1090\cf0 	\
  \cf2 1091\cf0 	
\f2\b sub
\f0\b0  \cf5 store_dat_files_acc_steps\cf0 ()\
  \cf2 1092\cf0 	\{ \
  \cf2 1093\cf0 	    
\f2\b print
\f0\b0  RED, \cf4 "\cf7 \\n\cf4 >>>>store_dat_files_acc_steps: BEGIN (DEBUG)<<<<<<<<<\cf7 \\n\cf4 "\cf0 , RESET 
\f2\b if
\f0\b0  \cf6 $DEBUG_ON\cf0 ;\
  \cf2 1094\cf0 	    
\f2\b print
\f0\b0  \cf4 "Storing dat files (acc steps)... "\cf0 ;\
  \cf2 1095\cf0 	    
\f2\b my
\f0\b0  \cf6 $step6\cf0  = &\cf5 numtostr\cf0 (\cf6 $STEP\cf0 ,\cf2 6\cf0 );\
  \cf2 1096\cf0 	    \
  \cf2 1097\cf0 	    
\f1\i \cf3 #zos info file -> has to be in accorance with the##
\f0\i0 \cf0 \
  \cf2 1098\cf0 	    
\f1\i \cf3 #number of trrs and zos files so written only when#
\f0\i0 \cf0 \
  \cf2 1099\cf0 	    
\f1\i \cf3 #traj accepted#####################################
\f0\i0 \cf0 \
  \cf2 1100\cf0 	    open ZOSINFO, \cf4 ">>$FILE\{ZOSINF\}"\cf0 ;\
  \cf2 1101\cf0 	\
  \cf2 1102\cf0 	    
\f2\b my
\f0\b0  \cf6 $facc\cf0  = \cf6 $ACCEPTED\cf0 =~
\f2\b /forw/
\f0\b0  ? \cf2 1\cf0  : \cf2 0\cf0 ;\
  \cf2 1103\cf0 	    
\f2\b my
\f0\b0  \cf6 $bacc\cf0  = \cf6 $ACCEPTED\cf0 =~
\f2\b /back/
\f0\b0  ? \cf2 1\cf0  : \cf2 0\cf0 ;\
  \cf2 1104\cf0 	\
  \cf2 1105\cf0 	    printf ZOSINFO \cf4 "%s %-5d %d %d\cf7 \\n\cf4 "\cf0 ,\cf6 $step6\cf0 ,\cf6 $CUT_G\cf0 ,\cf6 $bacc\cf0 ,\cf6 $facc\cf0 ;\
  \cf2 1106\cf0 	    close \cf5 ZOSINFO\cf0 ;\
  \cf2 1107\cf0 	\
  \cf2 1108\cf0 	    
\f1\i \cf3 #path file. the final path is stored. shoule be####
\f0\i0 \cf0 \
  \cf2 1109\cf0 	    
\f1\i \cf3 #A->0->B in TPS or eg A->0->1->0->1->B in TIS######
\f0\i0 \cf0 \
  \cf2 1110\cf0 	    
\f2\b my
\f0\b0  \cf6 $path\cf0  = &\cf5 get_par_path\cf0 (\cf4 "$OPATH\{PAR\}$step6.par"\cf0 ,\\\cf6 %PARAM\cf0 );\
  \cf2 1111\cf0 	    open PATHF, \cf4 ">>"\cf0 .\cf6 $FILE\cf0 \{PARPATH\};\
  \cf2 1112\cf0 	  
\f1\i \cf3 #  my $pathl = `more $OPATH\{PAR\}$step6.par | wc -l`;
\f0\i0 \cf0 \
  \cf2 1113\cf0 	    
\f2\b my
\f0\b0  \cf6 $pathl\cf0  = ( `wc -l \cf6 $OPATH\cf0 \{PAR\}\cf6 $step6\cf0 .par` =~ 
\f2\b /(\\d+)/
\f0\b0 g )[\cf2 0\cf0 ];\
  \cf2 1114\cf0 	    \cf6 $pathl\cf0  -= \cf2 1\cf0 ;\
  \cf2 1115\cf0 	    
\f2\b print
\f0\b0  PATHF \cf4 "$step6  $path $pathl\cf7 \\n\cf4 "\cf0 ;\
  \cf2 1116\cf0 	    close \cf5 PATHF\cf0 ; \
  \cf2 1117\cf0 	    
\f2\b print
\f0\b0  \cf4 "done\cf7 \\n\cf4 "\cf0 ;\
  \cf2 1118\cf0 	    
\f2\b print
\f0\b0  RED, \cf4 ">>>>store_dat_files_acc_steps: END (DEBUG)<<<<<<<<<<<\cf7 \\n\cf4 "\cf0 , RESET 
\f2\b if
\f0\b0  \cf6 $DEBUG_ON\cf0 ;\
  \cf2 1119\cf0 	\}\
  \cf2 1120\cf0 	\
  \cf2 1121\cf0 	
\f2\b sub
\f0\b0  \cf5 move_gro_frames\cf0 ()\
  \cf2 1122\cf0 	\{\
  \cf2 1123\cf0 	    
\f2\b print
\f0\b0  RED, \cf4 "\cf7 \\n\cf4 >>>>move_gro_frames: BEGIN (DEBUG)<<<<<<<<<\cf7 \\n\cf4 "\cf0 , RESET 
\f2\b if
\f0\b0  \cf6 $DEBUG_ON\cf0 ;\
  \cf2 1124\cf0 	    
\f1\i \cf3 #if the results of the previous run were both
\f0\i0 \cf0 \
  \cf2 1125\cf0 	    
\f1\i \cf3 #wrong, no files were created in the CURR_GROS.
\f0\i0 \cf0 \
  \cf2 1126\cf0 	    
\f1\i \cf3 #than we should do nothing with temporary gros!
\f0\i0 \cf0 \
  \cf2 1127\cf0 	    \
  \cf2 1128\cf0 	    
\f2\b if
\f0\b0  ( \cf6 $STORED\cf0  == \cf2 0\cf0  )\
  \cf2 1129\cf0 	    \{\
  \cf2 1130\cf0 		
\f2\b print
\f0\b0  \cf4 "no frames were moved\cf7 \\n\cf4 "\cf0  
\f2\b if
\f0\b0  \cf6 $DEBUG_ON\cf0 ;\
  \cf2 1131\cf0 		
\f2\b return
\f0\b0 ;\
  \cf2 1132\cf0 	    \}\
  \cf2 1133\cf0 	    \
  \cf2 1134\cf0 	    
\f1\i \cf3 #w przeciwnym wypdaku :
\f0\i0 \cf0 \
  \cf2 1135\cf0 	    `rm \cf6 $PATH\cf0 \{PREV_GROS\}* \cf2 1\cf0 >\cf6 $NULL\cf0  \cf2 2\cf0 >\cf6 $NULL\cf0 `;\
  \cf2 1136\cf0 	    `mv \cf6 $PATH\cf0 \{CURR_GROS\}*.gro \cf6 $PATH\cf0 \{PREV_GROS\} \cf2 1\cf0 >\cf6 $NULL\cf0  \cf2 2\cf0 >\cf6 $NULL\cf0 `;\
  \cf2 1137\cf0 	    `rm \cf6 $PATH\cf0 \{CURR_GROS\}* \cf2 1\cf0 >\cf6 $NULL\cf0  \cf2 2\cf0 >\cf6 $NULL\cf0 `;\
  \cf2 1138\cf0 	\
  \cf2 1139\cf0 	    
\f2\b print
\f0\b0  RED, \cf4 "\cf7 \\n\cf4 >>>>move_gro_frames: END (DEBUG)<<<<<<<<<<<\cf7 \\n\cf4 "\cf0 , RESET 
\f2\b if
\f0\b0  \cf6 $DEBUG_ON\cf0 ;\
  \cf2 1140\cf0 	\}\
  \cf2 1141\cf0 	\
  \cf2 1142\cf0 	
\f2\b sub
\f0\b0  \cf5 store_trr\cf0 ()\
  \cf2 1143\cf0 	\{ \
  \cf2 1144\cf0 	    
\f2\b print
\f0\b0  RED, \cf4 "\cf7 \\n\cf4 >>>>store_trr: BEGIN (DEBUG)<<<<<<<<<\cf7 \\n\cf4 "\cf0 , RESET 
\f2\b if
\f0\b0  \cf6 $DEBUG_ON\cf0 ;\
  \cf2 1145\cf0 	    
\f2\b print
\f0\b0  RED, \cf4 "GLUEING AND CONCATENATING\cf7 \\n\cf4 "\cf0 , \cf5 RESET\cf0 ;\
  \cf2 1146\cf0 	    
\f2\b my
\f0\b0  \cf6 $last_frame_num\cf0 ;\
  \cf2 1147\cf0 	    
\f2\b my
\f0\b0  \cf6 $b_frames\cf0 ;\
  \cf2 1148\cf0 	    
\f2\b my
\f0\b0  \cf6 $f_frames\cf0 ;\
  \cf2 1149\cf0 	    
\f2\b print
\f0\b0  \cf4 "RES\{F\}=$RES\{F\}  RES\{B\}=$RES\{B\}\cf7 \\n\cf4 "\cf0  
\f2\b if
\f0\b0  \cf6 $DEBUG_ON\cf0 ;\
  \cf2 1150\cf0 	   \
  \cf2 1151\cf0 	    
\f2\b if
\f0\b0 (!\cf6 $STORED\cf0 ) \{ 
\f2\b return
\f0\b0 ; \} \
  \cf2 1152\cf0 	\
  \cf2 1153\cf0 	\
  \cf2 1154\cf0 	    
\f2\b if
\f0\b0 (\cf6 $ACCEPTED\cf0  =~ 
\f2\b /back/
\f0\b0 )\
  \cf2 1155\cf0 	    \{\
  \cf2 1156\cf0 		
\f1\i \cf3 #new trajectory OK
\f0\i0 \cf0 \
  \cf2 1157\cf0 		
\f1\i \cf3 #extract gros to $PATH\{CURR_GROS\}
\f0\i0 \cf0 \
  \cf2 1158\cf0 		
\f2\b print
\f0\b0  \cf4 "PREPARING BACKWARD FRAMES\cf7 \\n\cf4 "\cf0 ;\
  \cf2 1159\cf0 		
\f2\b my
\f0\b0  \cf6 $trr\cf0  = \cf4 "$PATH\{TPSRUNB\}run.trr"\cf0 ;\
  \cf2 1160\cf0 		&\cf5 extract_gros_from_trr\cf0 (\cf6 $trr\cf0 ,\cf6 $FILE\cf0 \{TPR\},\cf6 $PATH\cf0 \{CURR_GROS\},\cf4 "btmp"\cf0 );\
  \cf2 1161\cf0 		\
  \cf2 1162\cf0 		
\f1\i \cf3 #change their names#
\f0\i0 \cf0 \
  \cf2 1163\cf0 		
\f2\b my
\f0\b0  \cf6 @gros\cf0  = split 
\f2\b /\\n/
\f0\b0 , `ls -\cf2 1\cf0  \cf6 $PATH\cf0 \{CURR_GROS\} | grep gro | grep btmp`;\
  \cf2 1164\cf0 		chomp \cf6 @gros\cf0 ;\
  \cf2 1165\cf0 	
\f1\i \cf3 #	print join "\\n", @gros;
\f0\i0 \cf0 \
  \cf2 1166\cf0 	
\f1\i \cf3 #	print "\\n--------------------\\n";
\f0\i0 \cf0 \
  \cf2 1167\cf0 		
\f2\b for
\f0\b0 (
\f2\b my
\f0\b0  \cf6 $i\cf0 =\cf2 0\cf0 ; \cf6 $i\cf0 <\cf6 @gros\cf0 ; \cf6 $i\cf0 ++)\
  \cf2 1168\cf0 		\{\
  \cf2 1169\cf0 		    \cf6 $gros\cf0 [\cf6 $i\cf0 ] =~ 
\f2\b /(\\d+)/
\f0\b0 ;\
  \cf2 1170\cf0 		    
\f2\b my
\f0\b0  \cf6 $num\cf0   = \cf6 $1\cf0 ;\
  \cf2 1171\cf0 		    
\f1\i \cf3 #if($num == 0 || $num == @gros-1)	    \{
\f0\i0 \cf0 \
  \cf2 1172\cf0 		    
\f1\i \cf3 # nie usuwamy ostatniej klatki bo to juz zostalo zrobione 
\f0\i0 \cf0 \
  \cf2 1173\cf0 		    
\f1\i \cf3 # przez truncate_trr_and xys
\f0\i0 \cf0 \
  \cf2 1174\cf0 		    
\f2\b if
\f0\b0 (\cf6 $num\cf0  == \cf2 0\cf0 )\
  \cf2 1175\cf0 		    \{\
  \cf2 1176\cf0 			`rm \cf6 $PATH\cf0 \{CURR_GROS\}\cf6 $gros\cf0 [\cf6 $i\cf0 ]`;\
  \cf2 1177\cf0 			
\f2\b next
\f0\b0 ;\
  \cf2 1178\cf0 		    \}\
  \cf2 1179\cf0 		    
\f1\i \cf3 #cofamy o jeden licznik w dol######
\f0\i0 \cf0 \
  \cf2 1180\cf0 		    
\f2\b my
\f0\b0  \cf6 $num_new\cf0  = \cf6 $num\cf0  - \cf2 1\cf0 ;\
  \cf2 1181\cf0 		    `mv \cf6 $PATH\cf0 \{CURR_GROS\}\cf6 $gros\cf0 [\cf6 $i\cf0 ] \cf6 $PATH\cf0 \{CURR_GROS\}b\cf6 $num_new\cf0 .gro`;\
  \cf2 1182\cf0 		\}\
  \cf2 1183\cf0 		\
  \cf2 1184\cf0 		
\f1\i \cf3 #reverse order of the files!!!!!!!
\f0\i0 \cf0 \
  \cf2 1185\cf0 		\cf6 @gros\cf0  = ();\
  \cf2 1186\cf0 		\cf6 @gros\cf0  = split 
\f2\b /\\n/
\f0\b0 , `ls -\cf2 1\cf0  \cf6 $PATH\cf0 \{CURR_GROS\} | grep gro | grep b`;\
  \cf2 1187\cf0 	
\f1\i \cf3 #	print "\\n".join( "\\n", @gros);
\f0\i0 \cf0 \
  \cf2 1188\cf0 	
\f1\i \cf3 #	print "\\n---------------------\\n";
\f0\i0 \cf0 \
  \cf2 1189\cf0 		
\f2\b for
\f0\b0 (
\f2\b my
\f0\b0  \cf6 $i\cf0  = \cf2 0\cf0 ; \cf6 $i\cf0 <\cf6 @gros\cf0 ; \cf6 $i\cf0 ++)\
  \cf2 1190\cf0 		\{\
  \cf2 1191\cf0 		    \cf6 $gros\cf0 [\cf6 $i\cf0 ] =~ 
\f2\b /(\\d+)/
\f0\b0 ;\
  \cf2 1192\cf0 		    
\f2\b my
\f0\b0  \cf6 $num\cf0   = \cf6 $1\cf0 ;\
  \cf2 1193\cf0 		    
\f2\b my
\f0\b0  \cf6 $num6\cf0  = &\cf5 numtostr\cf0 (\cf6 @gros\cf0  - \cf2 1\cf0  - \cf6 $num\cf0 ,\cf2 6\cf0 );\
  \cf2 1194\cf0 	
\f1\i \cf3 #	    print "moving --->$PATH\{CURR_GROS\}$gros[$i]\\n";
\f0\i0 \cf0 \
  \cf2 1195\cf0 	
\f1\i \cf3 #	    print "     to ---> $PATH\{CURR_GROS\}b$num6.gro\\n";
\f0\i0 \cf0 \
  \cf2 1196\cf0 		    `mv \cf6 $PATH\cf0 \{CURR_GROS\}\cf6 $gros\cf0 [\cf6 $i\cf0 ] \cf6 $PATH\cf0 \{CURR_GROS\}b\cf6 $num6\cf0 .gro`;\
  \cf2 1197\cf0 		\}\
  \cf2 1198\cf0 	
\f1\i \cf3 #	print join "\\n", @gros;
\f0\i0 \cf0 \
  \cf2 1199\cf0 	
\f1\i \cf3 #	print "\\n--------------------\\n";
\f0\i0 \cf0 \
  \cf2 1200\cf0 	       \
  \cf2 1201\cf0 		\cf6 $last_frame_num\cf0  = \cf6 @gros\cf0  - \cf2 1\cf0 ;\
  \cf2 1202\cf0 	    \}\
  \cf2 1203\cf0 	    
\f2\b else
\f0\b0 \
  \cf2 1204\cf0 	    \{\
  \cf2 1205\cf0 		
\f2\b print
\f0\b0  \cf4 "COPYING BACKWARD FRAMES FROM PREVIOUS TRR\cf7 \\n\cf4 "\cf0 ;\
  \cf2 1206\cf0 		
\f2\b for
\f0\b0 (
\f2\b my
\f0\b0  \cf6 $i\cf0 =\cf2 0\cf0 ; \cf6 $i\cf0 <\cf6 $CUT_G\cf0 ; \cf6 $i\cf0 ++)\
  \cf2 1207\cf0 		\{\
  \cf2 1208\cf0 		    
\f2\b my
\f0\b0  \cf6 $i6\cf0  = &\cf5 numtostr\cf0 (\cf6 $i\cf0 ,\cf2 6\cf0 );\
  \cf2 1209\cf0 		    
\f2\b if
\f0\b0 ( -e \cf4 "$PATH\{PREV_GROS\}b$i6.gro"\cf0  || -e \cf4 "$PATH\{PREV_GROS\}f$i6.gro"\cf0  )\{  `cp \cf6 $PATH\cf0 \{PREV_GROS\}*\cf6 $i6\cf0 .gro \cf6 $PATH\cf0 \{CURR_GROS\}`; \}\
  \cf2 1210\cf0 		    
\f2\b else
\f0\b0   \
  \cf2 1211\cf0 		    \{\
  \cf2 1212\cf0 			
\f2\b print
\f0\b0  \cf4 "going to die.$PATH\{PREV_GROS\} listing:\cf7 \\n\cf4 "\cf0 .\cf5 join\cf0 (\cf4 ""\cf0 ,\cf5 split\cf0 (\cf4 "\cf7 \\n\cf4 "\cf0 ,`ls -\cf2 1\cf0  \cf6 $PATH\cf0 \{PREV_GROS\}`));\
  \cf2 1213\cf0 			die \cf4 "store_trr >>>>> $PATH\{PREV_GROS\}*$i6.gro DOES NOT EXIST"\cf0 ; \
  \cf2 1214\cf0 		    \} \
  \cf2 1215\cf0 		\}\
  \cf2 1216\cf0 		
\f1\i \cf3 ##print "press sth.."; <STDIN>; #DEBUG
\f0\i0 \cf0 \
  \cf2 1217\cf0 		
\f2\b my
\f0\b0  \cf6 @gros\cf0  = `ls -\cf2 1\cf0  \cf6 $PATH\cf0 \{CURR_GROS\} | grep gro`;\
  \cf2 1218\cf0 		chomp \cf6 @gros\cf0 ;\
  \cf2 1219\cf0 		die \cf4 "\\@gros="\cf0 .\cf5 scalar\cf0 (\cf6 @gros\cf0 ).\cf4 ", \\$CUT_G=$CUT_G \\@gros != CUT_G"\cf0  
\f2\b if
\f0\b0  \cf6 @gros\cf0  != \cf6 $CUT_G\cf0 ;\
  \cf2 1220\cf0 		\cf6 $last_frame_num\cf0  = \cf6 @gros\cf0  - \cf2 1\cf0 ;\
  \cf2 1221\cf0 		\
  \cf2 1222\cf0 	    \}\
  \cf2 1223\cf0 	  \
  \cf2 1224\cf0 	    
\f1\i \cf3 #FORWARD
\f0\i0 \cf0 \
  \cf2 1225\cf0 	    
\f2\b if
\f0\b0 (\cf6 $ACCEPTED\cf0  =~ 
\f2\b /forw/
\f0\b0 )\
  \cf2 1226\cf0 	    \{\
  \cf2 1227\cf0 		
\f1\i \cf3 #new trajectory OK
\f0\i0 \cf0 \
  \cf2 1228\cf0 		
\f1\i \cf3 #extract gros to $PATH\{CURR_GROS\}
\f0\i0 \cf0 \
  \cf2 1229\cf0 		
\f2\b print
\f0\b0  \cf4 "PREPARING FORWARD FRAMES\cf7 \\n\cf4 "\cf0 ;\
  \cf2 1230\cf0 		
\f2\b my
\f0\b0  \cf6 $trr\cf0  = \cf4 "$PATH\{TPSRUNF\}run.trr"\cf0 ;\
  \cf2 1231\cf0 		&\cf5 extract_gros_from_trr\cf0 (\cf6 $trr\cf0 ,\cf6 $FILE\cf0 \{TPR\},\cf6 $PATH\cf0 \{CURR_GROS\},\cf4 "tmpf"\cf0 );\
  \cf2 1232\cf0 		\
  \cf2 1233\cf0 		
\f1\i \cf3 #change their names#
\f0\i0 \cf0 \
  \cf2 1234\cf0 		
\f2\b my
\f0\b0  \cf6 @gros\cf0  = split 
\f2\b /\\n/
\f0\b0 , `ls -\cf2 1\cf0  \cf6 $PATH\cf0 \{CURR_GROS\} | grep gro | grep tmpf`;\
  \cf2 1235\cf0 		chomp \cf6 @gros\cf0 ;\
  \cf2 1236\cf0 		\
  \cf2 1237\cf0 		
\f2\b for
\f0\b0 (
\f2\b my
\f0\b0  \cf6 $i\cf0 =\cf2 0\cf0 ; \cf6 $i\cf0 <\cf6 @gros\cf0 ; \cf6 $i\cf0 ++)\
  \cf2 1238\cf0 		\{\
  \cf2 1239\cf0 		    \cf6 $gros\cf0 [\cf6 $i\cf0 ] =~ 
\f2\b /(\\d+)/
\f0\b0 ;\
  \cf2 1240\cf0 		    
\f2\b my
\f0\b0  \cf6 $num\cf0   = \cf6 $1\cf0 ;\
  \cf2 1241\cf0 		    
\f1\i \cf3 #the sam as upper -> the truncate_trr_and_xys script
\f0\i0 \cf0 \
  \cf2 1242\cf0 		    
\f1\i \cf3 #already cut the last frame.
\f0\i0 \cf0 \
  \cf2 1243\cf0 	\
  \cf2 1244\cf0 		    
\f1\i \cf3 #if($num == @gros-1)	    \{
\f0\i0 \cf0 \
  \cf2 1245\cf0 		    
\f1\i \cf3 #	`rm $PATH\{CURR_GROS\}$gros[$i]`;
\f0\i0 \cf0 \
  \cf2 1246\cf0 		    
\f1\i \cf3 #	next;
\f0\i0 \cf0 \
  \cf2 1247\cf0 		    
\f1\i \cf3 #\}
\f0\i0 \cf0 \
  \cf2 1248\cf0 	\
  \cf2 1249\cf0 		    
\f2\b my
\f0\b0  \cf6 $num6\cf0  = &\cf5 numtostr\cf0 (\cf6 $num\cf0 +\cf6 $last_frame_num\cf0 +\cf2 1\cf0 ,\cf2 6\cf0 );\
  \cf2 1250\cf0 		    `mv \cf6 $PATH\cf0 \{CURR_GROS\}\cf6 $gros\cf0 [\cf6 $i\cf0 ] \cf6 $PATH\cf0 \{CURR_GROS\}f\cf6 $num6\cf0 .gro`;\
  \cf2 1251\cf0 		\
  \cf2 1252\cf0 		\}\
  \cf2 1253\cf0 		
\f1\i \cf3 ##print "press sth.."; <STDIN>; #DEBUG
\f0\i0 \cf0 \
  \cf2 1254\cf0 	    \}\
  \cf2 1255\cf0 	    
\f2\b else
\f0\b0 \
  \cf2 1256\cf0 	    \{\
  \cf2 1257\cf0 		
\f1\i \cf3 #copy old trajectory#
\f0\i0 \cf0 \
  \cf2 1258\cf0 		
\f2\b my
\f0\b0  \cf6 @gros\cf0  = ();\
  \cf2 1259\cf0 		
\f2\b my
\f0\b0  \cf6 @pgros\cf0  = split 
\f2\b /\\n/
\f0\b0 ,  `ls -\cf2 1\cf0  \cf6 $PATH\cf0 \{PREV_GROS\} | grep gro`;\
  \cf2 1260\cf0 		
\f2\b print
\f0\b0  \cf4 "COPYING FORWARD FRAMES FROM PREVIOUS TRR\cf7 \\n\cf4 "\cf0 ;\
  \cf2 1261\cf0 		
\f2\b for
\f0\b0 (
\f2\b my
\f0\b0  \cf6 $i\cf0 =\cf2 0\cf0 ; \cf6 $i\cf0 <\cf6 @pgros\cf0 ; \cf6 $i\cf0 ++)\
  \cf2 1262\cf0 		\{\
  \cf2 1263\cf0 		    \cf6 $pgros\cf0 [\cf6 $i\cf0 ] =~ 
\f2\b /(\\d+)/
\f0\b0 ;\
  \cf2 1264\cf0 		    
\f2\b my
\f0\b0  \cf6 $pnum\cf0  = \cf6 $1\cf0 ;\
  \cf2 1265\cf0 		    
\f2\b next if
\f0\b0 (\cf6 $pnum\cf0  < \cf6 $CUT_G\cf0 );\
  \cf2 1266\cf0 		    
\f2\b my
\f0\b0  \cf6 $i6\cf0  = &\cf5 numtostr\cf0 (\cf6 $pnum\cf0 ,\cf2 6\cf0 );\
  \cf2 1267\cf0 		    `cp \cf6 $PATH\cf0 \{PREV_GROS\}\cf6 $pgros\cf0 [\cf6 $i\cf0 ] \cf6 $PATH\cf0 \{CURR_GROS\}prev_\cf6 $pgros\cf0 [\cf6 $i\cf0 ]`;\
  \cf2 1268\cf0 		    push \cf6 @gros\cf0 , \cf4 "prev_"\cf0 .\cf6 $pgros\cf0 [\cf6 $i\cf0 ];\
  \cf2 1269\cf0 		\}\
  \cf2 1270\cf0 		\
  \cf2 1271\cf0 		
\f1\i \cf3 #the gros are sorted...
\f0\i0 \cf0 \
  \cf2 1272\cf0 		
\f2\b for
\f0\b0 (
\f2\b my
\f0\b0  \cf6 $i\cf0 =\cf2 0\cf0 ; \cf6 $i\cf0 <\cf6 @gros\cf0 ; \cf6 $i\cf0 ++)\
  \cf2 1273\cf0 		\{\
  \cf2 1274\cf0 		    \cf6 $gros\cf0 [\cf6 $i\cf0 ] =~ 
\f2\b /prev_(b|f)(\\d+)/
\f0\b0 ;\
  \cf2 1275\cf0 		    
\f2\b my
\f0\b0  \cf6 $nnum\cf0   = \cf6 $last_frame_num\cf0  + \cf2 1\cf0  + \cf6 $i\cf0 ;\
  \cf2 1276\cf0 		    
\f2\b my
\f0\b0  \cf6 $nnum6\cf0  = &\cf5 numtostr\cf0 (\cf6 $nnum\cf0 ,\cf2 6\cf0 );\
  \cf2 1277\cf0 		     `mv \cf6 $PATH\cf0 \{CURR_GROS\}\cf6 $gros\cf0 [\cf6 $i\cf0 ] \cf6 $PATH\cf0 \{CURR_GROS\}\cf6 $1$nnum6\cf0 .gro`;	    \
  \cf2 1278\cf0 		   \
  \cf2 1279\cf0 		\}\
  \cf2 1280\cf0 	      \
  \cf2 1281\cf0 	    \}\
  \cf2 1282\cf0 	    \
  \cf2 1283\cf0 	    
\f1\i \cf3 ###########################################################
\f0\i0 \cf0 \
  \cf2 1284\cf0 	    
\f2\b my
\f0\b0  \cf6 $step6\cf0  = &\cf5 numtostr\cf0 ( \cf6 $STEP\cf0 , \cf2 6\cf0 );\
  \cf2 1285\cf0 	    &\cf5 concat_GROS_as\cf0 (\cf4 "$OPATH\{TRR\}$step6.trr"\cf0 );\
  \cf2 1286\cf0 	    \
  \cf2 1287\cf0 	    
\f1\i \cf3 ###########################################################
\f0\i0 \cf0 \
  \cf2 1288\cf0 	    
\f1\i \cf3 #make zos file 
\f0\i0 \cf0 \
  \cf2 1289\cf0 	    
\f2\b my
\f0\b0  \cf6 $b_frames\cf0  = `ls -\cf2 1\cf0  \cf6 $PATH\cf0 \{CURR_GROS\} | grep gro | grep b | wc -l`+\cf2 0\cf0 ;\
  \cf2 1290\cf0 	    
\f2\b my
\f0\b0  \cf6 $f_frames\cf0  = `ls -\cf2 1\cf0  \cf6 $PATH\cf0 \{CURR_GROS\} | grep gro | grep f | wc -l`+\cf2 0\cf0 ;\
  \cf2 1291\cf0 	    \
  \cf2 1292\cf0 	    
\f2\b print
\f0\b0  \cf4 "SUMMARY: b_frames = $b_frames   f_frames = $f_frames\cf7 \\n\cf4 "\cf0 ;\
  \cf2 1293\cf0 	\
  \cf2 1294\cf0 	    
\f2\b my
\f0\b0  \cf6 $zos\cf0  = \cf4 "$OPATH\{ZOS\}$step6.zos"\cf0 ;\
  \cf2 1295\cf0 	    &\cf5 make_zos_file\cf0 (\cf6 $zos\cf0 ,\cf6 $b_frames\cf0 ,\cf6 $f_frames\cf0 );\
  \cf2 1296\cf0 	    \
  \cf2 1297\cf0 	    \
  \cf2 1298\cf0 	    
\f1\i \cf3 ##print "press sth.."; <STDIN>; #DEBUG
\f0\i0 \cf0 \
  \cf2 1299\cf0 	    
\f1\i \cf3 #copy edr files, even if one of them might not be used...
\f0\i0 \cf0 \
  \cf2 1300\cf0 	    
\f2\b print
\f0\b0  \cf4 "STORING EDR FILES\cf7 \\n\cf4 "\cf0 ;\
  \cf2 1301\cf0 	    
\f2\b my
\f0\b0  \cf6 $fedr\cf0  = \cf4 "$OPATH\{EDR\}$step6"\cf0 .\cf4 "f.edr"\cf0 ;\
  \cf2 1302\cf0 	    
\f2\b my
\f0\b0  \cf6 $bedr\cf0  = \cf4 "$OPATH\{EDR\}$step6"\cf0 .\cf4 "b.edr"\cf0 ;\
  \cf2 1303\cf0 	    `cp \cf6 $PATH\cf0 \{TPSRUNF\}run.edr \cf6 $fedr\cf0 ` 
\f2\b if
\f0\b0  -e \cf4 "$PATH\{TPSRUNF\}run.edr"\cf0 ;\
  \cf2 1304\cf0 	    `cp \cf6 $PATH\cf0 \{TPSRUNB\}run.edr \cf6 $bedr\cf0 ` 
\f2\b if
\f0\b0  -e \cf4 "$PATH\{TPSRUNB\}run.edr"\cf0 ;\
  \cf2 1305\cf0 	    
\f2\b print
\f0\b0  RED, \cf4 ">>>>store_trr: END (DEBUG)<<<<<<<<<<<\cf7 \\n\cf4 "\cf0 , RESET 
\f2\b if
\f0\b0  \cf6 $DEBUG_ON\cf0 ;\
  \cf2 1306\cf0 	\}\
  \cf2 1307\cf0 	\
  \cf2 1308\cf0 	\
  \cf2 1309\cf0 	
\f1\i \cf3 #######################################################################
\f0\i0 \cf0 \
  \cf2 1310\cf0 	
\f1\i \cf3 #######################################################################
\f0\i0 \cf0 \
  \cf2 1311\cf0 	
\f2\b sub
\f0\b0  \cf5 concat_GROS_as\cf0 () 
\f1\i \cf3 #output_trr_file_name
\f0\i0 \cf0 \
  \cf2 1312\cf0 	\{\
  \cf2 1313\cf0 	    
\f2\b print
\f0\b0  RED, \cf4 "\cf7 \\n\cf4 >>>>concat_GROS_as: BEGIN (DEBUG)<<<<<<<<<\cf7 \\n\cf4 "\cf0 , RESET 
\f2\b if
\f0\b0  \cf6 $DEBUG_ON\cf0 ;\
  \cf2 1314\cf0 	    
\f2\b my
\f0\b0  \cf6 $out_trr\cf0  = \cf5 shift\cf0 ;\
  \cf2 1315\cf0 	    
\f1\i \cf3 #print "error output trr already exists (concat_GROS_as)\\n ";
\f0\i0 \cf0 \
  \cf2 1316\cf0 	    
\f1\i \cf3 #print "changing output name --> _$out_trr\\n";
\f0\i0 \cf0 \
  \cf2 1317\cf0 	\
  \cf2 1318\cf0 	    
\f1\i \cf3 #at this moment one only has to glue the gro files together
\f0\i0 \cf0 \
  \cf2 1319\cf0 	    \
  \cf2 1320\cf0 	    
\f2\b my
\f0\b0  \cf6 @allgros\cf0  = `ls -\cf2 1\cf0  \cf6 $PATH\cf0 \{CURR_GROS\} | grep gro`;\
  \cf2 1321\cf0 	    chomp \cf6 @allgros\cf0 ;\
  \cf2 1322\cf0 	\
  \cf2 1323\cf0 	\
  \cf2 1324\cf0 	    
\f1\i \cf3 #BOX_SIZE################################
\f0\i0 \cf0 \
  \cf2 1325\cf0 	    
\f2\b if
\f0\b0 (\cf6 $CHANGE_BOX_SIZE_FLAG\cf0 )\
  \cf2 1326\cf0 	    \{\
  \cf2 1327\cf0 		
\f2\b for
\f0\b0 (
\f2\b my
\f0\b0  \cf6 $gi\cf0  = \cf2 0\cf0 ; \cf6 $gi\cf0  < \cf6 @allgros\cf0 ; \cf6 $gi\cf0 ++)\
  \cf2 1328\cf0 		\{\
  \cf2 1329\cf0 		    &\cf5 ChangeBoxSize\cf0 (\cf6 $allgros\cf0 [\cf6 $gi\cf0 ]);\
  \cf2 1330\cf0 		\}\
  \cf2 1331\cf0 	    \}\
  \cf2 1332\cf0 	    
\f1\i \cf3 ########################################
\f0\i0 \cf0 \
\
This is the first \cf5 call\cf0 ; there are two more later on.\
\
  \cf2 2416\cf0 	
\f2\b sub
\f0\b0  \cf5 ChangeBoxSize\cf0 () 
\f1\i \cf3 #grofile
\f0\i0 \cf0 \
  \cf2 2417\cf0 	\{\
  \cf2 2418\cf0 	    
\f2\b print
\f0\b0  RED, \cf4 ">>>>ChangeBoxSize: BEGIN (DEBUG)<<<<<<<<<\cf7 \\n\cf4 "\cf0 , RESET 
\f2\b if
\f0\b0  \cf6 $DEBUG_ON\cf0 ;\
  \cf2 2419\cf0 	    
\f1\i \cf3 #read gro file###############
\f0\i0 \cf0 \
  \cf2 2420\cf0 	    
\f2\b my
\f0\b0  \cf6 $grof\cf0  = \cf5 shift\cf0 ;\
  \cf2 2421\cf0 	    
\f2\b return if
\f0\b0  !-e \cf6 $grof\cf0 ;\
  \cf2 2422\cf0 	    
\f1\i \cf3 #CHANGE SIZE OF THE BOX########################################
\f0\i0 \cf0 \
  \cf2 2423\cf0 	    open GROF, \cf4 "$grof"\cf0 ;   \
  \cf2 2424\cf0 	    
\f2\b my
\f0\b0  \cf6 @GROA\cf0  = <GROF>;\
  \cf2 2425\cf0 	    close \cf5 GROF\cf0 ;\
  \cf2 2426\cf0 	    \cf6 $GROA\cf0 [-\cf2 1\cf0 ]=\cf4 "5.03711   5.03711   3.56177   0.00000   0.00000   0.00000   0.00000   2.51855   2.51855\cf7 \\n\cf4 "\cf0 ;\
  \cf2 2427\cf0 	    open GROF, \cf4 ">$grof"\cf0 ; \
  \cf2 2428\cf0 	    
\f2\b print
\f0\b0  GROF \cf5 join\cf0 (\cf4 ""\cf0 ,\cf6 @GROA\cf0 );\
  \cf2 2429\cf0 	    close \cf5 GROF\cf0 ;\
  \cf2 2430\cf0 	    
\f1\i \cf3 ##############################################################
\f0\i0 \cf0 \
  \cf2 2431\cf0 	    
\f2\b print
\f0\b0  RED, \cf4 ">>>>ChangeBoxSize: END (DEBUG)<<<<<<<<<<<\cf7 \\n\cf4 "\cf0 , RESET 
\f2\b if
\f0\b0  \cf6 $DEBUG_ON\cf0 ;\
  \cf2 2432\cf0 	\}\
\
  \cf2 1333\cf0 	\
  \cf2 1334\cf0 	\
  \cf2 1335\cf0 	    
\f2\b my
\f0\b0  \cf6 $times\cf0  = \cf4 "$PATH\{CURR_GROS\}times"\cf0 ;\
  \cf2 1336\cf0 	    \
  \cf2 1337\cf0 	    
\f2\b my
\f0\b0  \cf6 $count\cf0  = \cf2 0\cf0 ;\
  \cf2 1338\cf0 	    
\f2\b my
\f0\b0  \cf6 $delta\cf0  = \cf2 100\cf0 ;\
  \cf2 1339\cf0 	\
  \cf2 1340\cf0 	    
\f2\b print
\f0\b0  \cf4 "CONCATENATION: "\cf0 ;\
  \cf2 1341\cf0 	    
\f2\b do
\f0\b0 \{\
  \cf2 1342\cf0 	        
\f1\i \cf3 #write times files
\f0\i0 \cf0 \
  \cf2 1343\cf0 		open TIMES, \cf4 ">$times"\cf0 ;\
  \cf2 1344\cf0 		
\f2\b print
\f0\b0  TIMES \cf4 "0\cf7 \\n\cf4 "\cf0  
\f2\b if
\f0\b0  -e \cf6 $out_trr\cf0 ;\
  \cf2 1345\cf0 		
\f2\b for
\f0\b0 (
\f2\b my
\f0\b0  \cf6 $i\cf0 =\cf6 $count\cf0 ; \cf6 $i\cf0 <\cf6 $count\cf0 +\cf6 $delta\cf0 ; \cf6 $i\cf0 ++) \{\
  \cf2 1346\cf0 		    
\f2\b if
\f0\b0 ( \cf6 $i\cf0  == \cf6 @allgros\cf0  ) \{ \cf6 $delta\cf0  = \cf6 $i\cf0  - \cf6 $count\cf0 ;  
\f2\b last
\f0\b0 \}\
  \cf2 1347\cf0 		    
\f2\b print
\f0\b0  \cf5 TIMES\cf0  (\cf6 $i\cf0 *\cf6 $TRR_STEP\cf0 ).\cf4 "\cf7 \\n\cf4 "\cf0  \}\
  \cf2 1348\cf0 		close \cf5 TIMES\cf0 ;\
  \cf2 1349\cf0 	\
  \cf2 1350\cf0 	        
\f1\i \cf3 #prepare list of files
\f0\i0 \cf0 \
  \cf2 1351\cf0 	        
\f2\b my
\f0\b0  \cf6 $list\cf0  =  \cf5 join\cf0 ( \cf4 " "\cf0 , map \{ \cf4 "$PATH\{CURR_GROS\}$_"\cf0  \} \cf6 @allgros\cf0 [ \cf6 $count\cf0  .. (\cf6 $count\cf0  + \cf6 $delta\cf0  - \cf2 1\cf0 ) ] );\
  \cf2 1352\cf0 	        \cf6 $list\cf0  = \cf6 $out_trr\cf0 .\cf4 " "\cf0 .\cf6 $list\cf0  
\f2\b if
\f0\b0  -e \cf6 $out_trr\cf0 ;\
  \cf2 1353\cf0 	\
  \cf2 1354\cf0 		
\f2\b my
\f0\b0  \cf6 $input\cf0  = \cf4 "-f $list -settime"\cf0 ;\
  \cf2 1355\cf0 	        
\f2\b my
\f0\b0  \cf6 $output\cf0  = \cf4 "-o $out_trr"\cf0 ;\
  \cf2 1356\cf0 	        
\f2\b my
\f0\b0  \cf6 $stream\cf0  = \cf4 "1>/dev/null 2>/dev/null"\cf0 ;\
  \cf2 1357\cf0 	\
  \cf2 1358\cf0 		
\f1\i \cf3 #&dvline("command");
\f0\i0 \cf0 \
  \cf2 1359\cf0 	        
\f1\i \cf3 #print &trjcat("$input $output $stream")." < $times \\n";
\f0\i0 \cf0 \
  \cf2 1360\cf0 		
\f2\b print
\f0\b0  \cf4 "$count "\cf0 ;\
  \cf2 1361\cf0 	        system \cf4 "$PATH\{GROMACS\}/trjcat $input $output $stream"\cf0 .\cf4 " < $times"\cf0 ;\
  \cf2 1362\cf0 	        \
  \cf2 1363\cf0 	        \cf6 $count\cf0  += \cf6 $delta\cf0 ;\
  \cf2 1364\cf0 	    \}
\f2\b while
\f0\b0 (\cf6 $count\cf0  < \cf6 @allgros\cf0 );\
  \cf2 1365\cf0 	    
\f2\b print
\f0\b0  \cf4 "\cf7 \\n\cf4 "\cf0 ;\
  \cf2 1366\cf0 	    
\f2\b print
\f0\b0  RED, \cf4 ">>>>concat_GROS_as: END (DEBUG)<<<<<<<<<<<\cf7 \\n\cf4 "\cf0 , RESET 
\f2\b if
\f0\b0  \cf6 $DEBUG_ON\cf0 ;\
  \cf2 1367\cf0 	    \
  \cf2 1368\cf0 	\}\
  \cf2 1369\cf0 	
\f1\i \cf3 #######################################################################
\f0\i0 \cf0 \
  \cf2 1370\cf0 	
\f1\i \cf3 #######################################################################
\f0\i0 \cf0 \
  \cf2 1371\cf0 	\
\
\
  \cf2 1434\cf0 	\
  \cf2 1435\cf0 	
\f1\i \cf3 ##########################################################################
\f0\i0 \cf0 \
\
\
  \cf2 1586\cf0 	\
  \cf2 1587\cf0 	
\f1\i \cf3 ##########################################################################
\f0\i0 \cf0 \
  \cf2 1588\cf0 	
\f2\b sub
\f0\b0  \cf5 reverse_gro\cf0 () 
\f1\i \cf3 #tmp dir, gro file
\f0\i0 \cf0 \
  \cf2 1589\cf0 	\{\
  \cf2 1590\cf0 	    
\f2\b print
\f0\b0  RED, \cf4 "\cf7 \\n\cf4 >>>>reverse_gro: BEGIN (DEBUG)<<<<<<<<<\cf7 \\n\cf4 "\cf0 , RESET 
\f2\b if
\f0\b0  \cf6 $DEBUG_ON\cf0 ;\
  \cf2 1591\cf0 	    
\f2\b print
\f0\b0  \cf4 "[ reversing gro "\cf0 ;\
  \cf2 1592\cf0 	    
\f2\b my
\f0\b0  \cf6 %TMP\cf0 ; \cf6 $TMP\cf0 \{\cf2 0\cf0 \} = \cf6 $_\cf0 [\cf2 0\cf0 ];\
  \cf2 1593\cf0 	    chdir \cf6 $TMP\cf0 \{\cf2 0\cf0 \};\
  \cf2 1594\cf0 	    
\f2\b my
\f0\b0  \cf6 $gro\cf0  = \cf6 $_\cf0 [\cf2 1\cf0 ];\
  \cf2 1595\cf0 	    \
  \cf2 1596\cf0 	    
\f1\i \cf3 #copy and modify mdp#
\f0\i0 \cf0 \
  \cf2 1597\cf0 	    
\f2\b my
\f0\b0  \cf6 $mdp\cf0  = \cf4 "$TMP\{0\}mdout.mdp"\cf0 ;\
  \cf2 1598\cf0 	    `cp \cf6 $FILE\cf0 \{MDP\} \cf6 $mdp\cf0 `;   \
  \cf2 1599\cf0 	    \
  \cf2 1600\cf0 	    
\f2\b my
\f0\b0  \cf6 $res\cf0 ; \
  \cf2 1601\cf0 	    \cf6 $res\cf0 =&\cf5 set_mdp_value\cf0 (\cf6 $mdp\cf0 ,\cf4 "nsteps"\cf0 ,\cf2 1\cf0 );\
  \cf2 1602\cf0 	    die \cf4 "problem with setting nsteps in $mdp when reversing"\cf0  
\f2\b if
\f0\b0  \cf6 $res\cf0 <\cf2 0\cf0 ;\
  \cf2 1603\cf0 	    \cf6 $res\cf0 =&\cf5 set_mdp_value\cf0 (\cf6 $mdp\cf0 ,\cf4 "nstxout"\cf0 ,\cf2 1\cf0 );\
  \cf2 1604\cf0 	    die \cf4 "problem with setting nstxout in $mdp when reversing"\cf0  
\f2\b if
\f0\b0  \cf6 $res\cf0 <\cf2 0\cf0 ;\
  \cf2 1605\cf0 	    \cf6 $res\cf0 =&\cf5 set_mdp_value\cf0 (\cf6 $mdp\cf0 ,\cf4 "nstvout"\cf0 ,\cf2 1\cf0 );\
  \cf2 1606\cf0 	    die \cf4 "problem with setting nstvout in $mdp when reversing"\cf0  
\f2\b if
\f0\b0  \cf6 $res\cf0 <\cf2 0\cf0 ;\
  \cf2 1607\cf0 	    \cf6 $res\cf0 =&\cf5 set_mdp_value\cf0 (\cf6 $mdp\cf0 ,\cf4 "gen_vel"\cf0 ,\cf4 "no"\cf0 );\
  \cf2 1608\cf0 	    die \cf4 "problem with setting gen_vel in $mdp when reversing"\cf0  
\f2\b if
\f0\b0  \cf6 $res\cf0 <\cf2 0\cf0 ;\
  \cf2 1609\cf0 	    \cf6 $res\cf0 =&\cf5 set_mdp_value\cf0 (\cf6 $mdp\cf0 ,\cf4 "gen_seed"\cf0 ,\cf4 "0"\cf0 );\
  \cf2 1610\cf0 	    die \cf4 "problem with setting gen_seed in $mdp when reversing"\cf0  
\f2\b if
\f0\b0  \cf6 $res\cf0 <\cf2 0\cf0 ;\
  \cf2 1611\cf0 	
\f1\i \cf3 #    $res=&set_mdp_value($mdp,"comm-mode","None");
\f0\i0 \cf0 \
  \cf2 1612\cf0 	
\f1\i \cf3 #    die "problem with setting comm-mode in $mdp when reversing" if $res<0;
\f0\i0 \cf0 \
  \cf2 1613\cf0 	    \cf6 $res\cf0 =&\cf5 set_mdp_value\cf0 (\cf6 $mdp\cf0 ,\cf4 "tcoupl"\cf0 ,\cf4 "no"\cf0 );\
  \cf2 1614\cf0 	\
  \cf2 1615\cf0 	    \cf6 $res\cf0 =&\cf5 set_mdp_value\cf0 (\cf6 $mdp\cf0 ,\cf4 "tau_t"\cf0 ,\cf4 "0.2 0.2"\cf0 );\
  \cf2 1616\cf0 	    die \cf4 "problem with setting tau_t in $mdp when reversing"\cf0  
\f2\b if
\f0\b0  \cf6 $res\cf0 <\cf2 0\cf0 ;\
  \cf2 1617\cf0 	    \
  \cf2 1618\cf0 	    
\f2\b if
\f0\b0 ( \cf6 $res\cf0 <\cf2 0\cf0 )\
  \cf2 1619\cf0 	    \{\
  \cf2 1620\cf0 		\cf6 $res\cf0 =&\cf5 set_mdp_value\cf0 (\cf6 $mdp\cf0 ,\cf4 "Tcoupl"\cf0 ,\cf4 "no"\cf0 );\
  \cf2 1621\cf0 		die \cf4 "problem with setting tcoupl in $mdp when reversing"\cf0  
\f2\b if
\f0\b0  \cf6 $res\cf0 <\cf2 0\cf0 ;\
  \cf2 1622\cf0 	    \}\
  \cf2 1623\cf0 	    \cf6 $res\cf0 =&\cf5 set_mdp_value\cf0 (\cf6 $mdp\cf0 ,\cf4 "pcoupl"\cf0 ,\cf4 "no"\cf0 );\
  \cf2 1624\cf0 	    
\f2\b if
\f0\b0 ( \cf6 $res\cf0  <\cf2 0\cf0  )\
  \cf2 1625\cf0 	    \{\
  \cf2 1626\cf0 		\cf6 $res\cf0 =&\cf5 set_mdp_value\cf0 (\cf6 $mdp\cf0 ,\cf4 "Pcoupl"\cf0 ,\cf4 "no"\cf0 );\
  \cf2 1627\cf0 		die \cf4 "problem with setting pcoupl in $mdp when reversing"\cf0  
\f2\b if
\f0\b0  \cf6 $res\cf0 <\cf2 0\cf0 ;\
  \cf2 1628\cf0 	    \}\
  \cf2 1629\cf0 	    \
  \cf2 1630\cf0 	    \
  \cf2 1631\cf0 	    
\f2\b my
\f0\b0  \cf6 $dt\cf0  = &\cf5 get_mdp_value\cf0 (\cf6 $mdp\cf0 ,\cf4 "dt"\cf0 );\
  \cf2 1632\cf0 	\
  \cf2 1633\cf0 	    \
  \cf2 1634\cf0 	    
\f1\i \cf3 #grompping###########
\f0\i0 \cf0 \
  \cf2 1635\cf0 	    
\f2\b print
\f0\b0  \cf4 "grompp "\cf0 ;\
  \cf2 1636\cf0 	    
\f2\b my
\f0\b0  \cf6 $tpr\cf0     = \cf4 "$TMP\{0\}run1.tpr"\cf0 ; \
  \cf2 1637\cf0 	    
\f2\b my
\f0\b0  \cf6 $input\cf0   = \cf4 "-f $mdp -c $gro -p $FILE\{TOP\}"\cf0 ;\
  \cf2 1638\cf0 	    
\f2\b my
\f0\b0  \cf6 $output\cf0  = \cf4 "-o $tpr"\cf0 ;\
  \cf2 1639\cf0 	    
\f2\b my
\f0\b0  \cf6 $stream\cf0  = \cf4 "1>$TMP\{0\}grompp.out 2>$TMP\{0\}grompp.err"\cf0 ;\
  \cf2 1640\cf0 	    system \cf4 "$PATH\{GROMACS\}/grompp $input $output $stream"\cf0 ;\
  \cf2 1641\cf0 	    die \cf4 "failed to create rev_gro in $TMP\{0\}, step1"\cf0  
\f2\b if
\f0\b0  ! -e \cf6 $tpr\cf0 ;\
  \cf2 1642\cf0 	\
  \cf2 1643\cf0 	    \
  \cf2 1644\cf0 	\
  \cf2 1645\cf0 	    
\f1\i \cf3 #mdrunning###########
\f0\i0 \cf0 \
  \cf2 1646\cf0 	    
\f2\b print
\f0\b0  \cf4 "mdrun "\cf0 ;\
  \cf2 1647\cf0 	    
\f2\b my
\f0\b0  \cf6 $trr\cf0  = \cf4 "$TMP\{0\}run1.trr"\cf0 ;\
  \cf2 1648\cf0 	    \cf6 $input\cf0   = \cf4 "-s $tpr"\cf0 ;\
  \cf2 1649\cf0 	    \cf6 $output\cf0  = \cf4 "-o $trr -c $TMP\{0\}after_run1.gro"\cf0 ;\
  \cf2 1650\cf0 	    \cf6 $stream\cf0  = \cf4 "1>$TMP\{0\}mdrun.out 2>$TMP\{0\}mdrun.err"\cf0 ;\
  \cf2 1651\cf0 	    system \cf4 "$FILE\{MDRUN_STANDARD\} $input $output $stream"\cf0 ;\
  \cf2 1652\cf0 	    die \cf4 "failed to create rev_gro in $TMP\{0\}, step2\cf0  \cf7 \\n\cf4 COMMAND ---> "\cf0 .(\cf4 "$FILE\{MDRUN_STANDARD\} $input $output $stream"\cf0 ) 
\f2\b if
\f0\b0  ! -e \cf6 $trr\cf0 ;\
  \cf2 1653\cf0 	\
  \cf2 1654\cf0 	    
\f1\i \cf3 #get the frame in 16dig prec
\f0\i0 \cf0 \
  \cf2 1655\cf0 	    
\f2\b print
\f0\b0  \cf4 "extract "\cf0 ;\
  \cf2 1656\cf0 	    
\f2\b my
\f0\b0  \cf6 $gro1\cf0  = \cf4 "$TMP\{0\}start1.gro"\cf0 ;\
  \cf2 1657\cf0 	
\f1\i \cf3 #NDEC16    $input  = "-s $tpr -f $trr -b $dt -e $dt -ndec 16";
\f0\i0 \cf0 \
  \cf2 1658\cf0 	    \cf6 $input\cf0   = \cf4 "-s $tpr -f $trr -b $dt -e $dt -ndec $GRO_PREC"\cf0 ;\
  \cf2 1659\cf0 	    \cf6 $output\cf0  = \cf4 "-o $gro1"\cf0 ;\
  \cf2 1660\cf0 	    \cf6 $stream\cf0  = \cf4 "1>$TMP\{0\}trjconv.out 2>$TMP\{0\}trjconv.err"\cf0 ;\
  \cf2 1661\cf0 	    system \cf4 "$PATH\{GROMACS\}/trjconv $input $output $stream"\cf0 .\cf4 " <<EOF\cf7 \\n\cf0  \cf4 0\cf7 \\n\cf0  \cf4 EOF"\cf0 ;\
  \cf2 1662\cf0 	\
  \cf2 1663\cf0 	    
\f2\b if
\f0\b0 ( ! -e \cf6 $gro1\cf0  )\
  \cf2 1664\cf0 	    \{\
  \cf2 1665\cf0 		
\f2\b print
\f0\b0  \cf4 "\cf7 \\n\cf4 failed to create rev_gro in $TMP\{0\}, step3\cf7 \\n\cf4 "\cf0 ;\
  \cf2 1666\cf0 		
\f2\b print
\f0\b0  \cf4 "\cf7 \\n\cf4 COMMAND ---> "\cf0 .\cf4 "$PATH\{GROMACS\}/trjconv $input $output $stream"\cf0 .\cf4 " <<EOF\cf7 \\n\cf0  \cf4 0\cf7 \\n\cf0  \cf4 EOF\cf7 \\n\cf4 "\cf0 ;\
  \cf2 1667\cf0 		
\f2\b return
\f0\b0  \cf4 "ERROR"\cf0 ;\
  \cf2 1668\cf0 	    \}\
  \cf2 1669\cf0 	\
  \cf2 1670\cf0 	\
  \cf2 1671\cf0 	    
\f2\b print
\f0\b0  \cf4 "combine "\cf0 ;\
  \cf2 1672\cf0 	
\f1\i \cf3 #NDEC16    `$SCRIPT\{COMB_GRO\} -prec 16 -grox $gro -grov $gro1`;
\f0\i0 \cf0 \
  \cf2 1673\cf0 	    `\cf6 $SCRIPT\cf0 \{COMB_GRO\} -prec \cf6 $GRO_PREC\cf0  -grox \cf6 $gro\cf0  -grov \cf6 $gro1\cf0 `;\
  \cf2 1674\cf0 	    die \cf4 "failed to create rev_gro in $TMP\{0\}, step4"\cf0  \
  \cf2 1675\cf0 		
\f2\b if
\f0\b0  ! -e \cf4 "$TMP\{0\}comb.gro"\cf0 ;\
  \cf2 1676\cf0 	    \
  \cf2 1677\cf0 	    
\f2\b print
\f0\b0  \cf4 "velrev "\cf0 ;\
  \cf2 1678\cf0 	
\f1\i \cf3 #NDEC16    `$SCRIPT\{REV_GRO\} -prec 16 -gro comb.gro`;
\f0\i0 \cf0 \
  \cf2 1679\cf0 	    `\cf6 $SCRIPT\cf0 \{REV_GRO\} -prec \cf6 $GRO_PREC\cf0  -gro comb.gro`;\
  \cf2 1680\cf0 	    die \cf4 "failed to create back_gro in $TMP\{0\}, step5"\cf0  \
  \cf2 1681\cf0 		
\f2\b if
\f0\b0  ! -e \cf4 "$TMP\{0\}rev_comb.gro"\cf0 ;\
  \cf2 1682\cf0 	     \
  \cf2 1683\cf0 	    
\f2\b print
\f0\b0  \cf4 "]\cf7 \\n\cf4 "\cf0 ;\
  \cf2 1684\cf0 	    chdir \cf6 $PATH\cf0 \{MAIN\};\
  \cf2 1685\cf0 	    
\f2\b print
\f0\b0  RED, \cf4 ">>>>reverse_gro: END (DEBUG)<<<<<<<<<<<\cf7 \\n\cf4 "\cf0 , RESET 
\f2\b if
\f0\b0  \cf6 $DEBUG_ON\cf0 ;\
  \cf2 1686\cf0 	    
\f2\b return
\f0\b0  \cf4 "$TMP\{0\}rev_comb.gro"\cf0 ;\
  \cf2 1687\cf0 	\}\
  \cf2 1688\cf0 	\
  \cf2 1689\cf0 	
\f2\b sub
\f0\b0  \cf5 get_nth_parline\cf0 ()
\f1\i \cf3 #file, number of line 
\f0\i0 \cf0 \
  \cf2 1690\cf0 	\{\
  \cf2 1691\cf0 	
\f1\i \cf3 #    print RED, "\\n>>>>get_nth_parline: BEGIN (DEBUG)<<<<<<<<<\\n", RESET if $DEBUG_ON;
\f0\i0 \cf0 \
  \cf2 1692\cf0 	    
\f2\b my
\f0\b0  \cf6 $pfile\cf0  = \cf5 shift\cf0 ;\
  \cf2 1693\cf0 	    
\f2\b return
\f0\b0  \cf4 ""\cf0  
\f2\b if
\f0\b0  !-e \cf6 $pfile\cf0 ;\
  \cf2 1694\cf0 	    
\f2\b my
\f0\b0  \cf6 $pn\cf0  = \cf5 shift\cf0 ; \
  \cf2 1695\cf0 	    \
  \cf2 1696\cf0 	    open PFILE, \cf6 $pfile\cf0 ;\
  \cf2 1697\cf0 	    
\f2\b my
\f0\b0  \cf6 @pfile\cf0  = <PFILE>;\
  \cf2 1698\cf0 	    chomp \cf6 @pfile\cf0 ;\
  \cf2 1699\cf0 	    close \cf5 PFILE\cf0 ;\
  \cf2 1700\cf0 	    \
  \cf2 1701\cf0 	    shift \cf6 @pfile\cf0 ; 
\f1\i \cf3 #get rid of the header!
\f0\i0 \cf0 \
  \cf2 1702\cf0 	    
\f2\b my
\f0\b0  \cf6 $pline\cf0  = \cf6 $pfile\cf0 [\cf6 $pn\cf0 ];\
  \cf2 1703\cf0 	    \cf6 @pfile\cf0 =();\
  \cf2 1704\cf0 	
\f1\i \cf3 #    print RED, ">>>>get_nth_parline: END (DEBUG)<<<<<<<<<<<\\n", RESET if $DEBUG_ON;
\f0\i0 \cf0 \
  \cf2 1705\cf0 	    
\f2\b return
\f0\b0  \cf6 $pline\cf0 ;\
  \cf2 1706\cf0 	\}\
  \cf2 1707\cf0 	\
  \cf2 1708\cf0 	\
\
\
\
  \cf2 1709\cf0 	
\f1\i \cf3 #this works only if we do not reverse :/ ERROR
\f0\i0 \cf0 \
  \cf2 1710\cf0 	
\f2\b sub
\f0\b0  \cf5 prepare_gro_files\cf0 ()\
  \cf2 1711\cf0 	\{\
  \cf2 1712\cf0 	    
\f2\b print
\f0\b0  BLUE, \cf4 "\cf7 \\n\cf4 >>>>>>>>>>>>>>>> prepare_gro_files: BEGIN <<<<<<<<<<<<<<<<<\cf7 \\n\cf4 "\cf0 , RESET 
\f2\b if
\f0\b0  \cf6 $DEBUG_ON\cf0 ;    \
  \cf2 1713\cf0 	    
\f2\b print
\f0\b0  \cf4 "PICKING INITIAL FRAME\cf7 \\n\cf4 "\cf0 ;\
\
This is absurd! This tag is jumped to from another function!!\
\
  \cf2 1714\cf0 	  prepare_gro_BEG:\
  \cf2 1715\cf0 	    \
  \cf2 1716\cf0 	    
\f2\b my
\f0\b0  \cf6 %TMP\cf0 ; \cf6 $TMP\cf0 \{\cf2 0\cf0 \} = &\cf5 make_temp_dir_in\cf0 (\cf6 $PATH\cf0 \{TEMP\});       \
  \cf2 1717\cf0 	                                                        \
  \cf2 1718\cf0 	    
\f2\b my
\f0\b0  \cf6 $pstep6\cf0  = &\cf5 numtostr\cf0 (\cf6 $STEP\cf0 -\cf2 1\cf0 ,\cf2 6\cf0 );                  \
  \cf2 1719\cf0 	    
\f1\i \cf3 #read corresponding zos-file#######################################################
\f0\i0 \cf0 \
  \cf2 1720\cf0 	
\f1\i \cf3 #    my $zosln = `head -n1 $OPATH\{ZOS\}$pstep6.zos`;             
\f0\i0 \cf0 \
\
  \cf2 1721\cf0 	    
\f2\b my
\f0\b0  \cf6 @zos\cf0  = &\cf5 _get_zos_array_from_PREV\cf0 ();\
   \cf2 602\cf0 	
\f2\b sub
\f0\b0  \cf5 _get_zos_array_from_PREV\cf0 () 
\f1\i \cf3 # 
\f0\i0 \cf0 \
   \cf2 603\cf0 	\{\
   \cf2 604\cf0 	    
\f2\b print
\f0\b0  RED, \cf4 "\cf7 \\n\cf4 >>>>get_zos_from_PREV: BEGIN (DEBUG)<<<<<<<<<\cf7 \\n\cf4 "\cf0 , RESET 
\f2\b if
\f0\b0  \cf6 $DEBUG_ON\cf0 ;\
   \cf2 605\cf0 	    \
   \cf2 606\cf0 	    
\f2\b my
\f0\b0  \cf6 $b_frames\cf0  = `ls -\cf2 1\cf0  \cf6 $PATH\cf0 \{PREV_GROS\} | grep gro | grep b | wc -l`;\
   \cf2 607\cf0 	    
\f2\b my
\f0\b0  \cf6 $f_frames\cf0  = `ls -\cf2 1\cf0  \cf6 $PATH\cf0 \{PREV_GROS\} | grep gro | grep f | wc -l`;\
   \cf2 608\cf0 	    chomp \cf6 $b_frames\cf0 ; chomp \cf6 $f_frames\cf0 ;\
   \cf2 609\cf0 	    
\f2\b print
\f0\b0  \cf4 "frames in PREV_GROS: b_frames = $b_frames  f_frames = $f_frames\cf7 \\n\cf4 "\cf0  
\f2\b if
\f0\b0  \cf6 $DEBUG_ON\cf0 ;\
   \cf2 610\cf0 	    
\f2\b my
\f0\b0  \cf6 @zos\cf0 ;\
   \cf2 611\cf0 	    
\f2\b for
\f0\b0 (
\f2\b my
\f0\b0  \cf6 $i\cf0 =\cf2 0\cf0 ; \cf6 $i\cf0 <\cf6 $b_frames\cf0 ; \cf6 $i\cf0 ++) \{push \cf6 @zos\cf0 , \cf2 0\cf0 \}\
   \cf2 612\cf0 	    
\f2\b for
\f0\b0 (
\f2\b my
\f0\b0  \cf6 $i\cf0 =\cf2 0\cf0 ; \cf6 $i\cf0 <\cf6 $f_frames\cf0 ; \cf6 $i\cf0 ++) \{push \cf6 @zos\cf0 , \cf2 1\cf0 \}\
   \cf2 613\cf0 	    
\f2\b print
\f0\b0  RED, \cf4 "\cf7 \\n\cf4 >>>>get_zos_from_PREV: END (DEBUG) <<<<<<<<<<\cf7 \\n\cf4 "\cf0 , RESET 
\f2\b if
\f0\b0  \cf6 $DEBUG_ON\cf0 ;\
   \cf2 614\cf0 	    
\f2\b return
\f0\b0  \cf6 @zos\cf0 ;\
   \cf2 615\cf0 	\}\
\
  \cf2 1722\cf0 	\
  \cf2 1723\cf0 	    die \cf4 "input trajectory too short"\cf0  
\f2\b if
\f0\b0  \cf6 @zos\cf0 <\cf2 10\cf0 ;\
  \cf2 1724\cf0 	    
\f2\b print
\f0\b0  \cf4 "zos from PREV_GROS --> "\cf0 .\cf5 join\cf0 (\cf4 ""\cf0 ,\cf6 @zos\cf0 ).\cf4 "\cf7 \\n\cf4 "\cf0  
\f2\b if
\f0\b0  \cf6 $DEBUG_ON\cf0 ;\
  \cf2 1725\cf0 	\
  \cf2 1726\cf0 	    
\f1\i \cf3 #choose gro from the trr###########################################################
\f0\i0 \cf0 \
  \cf2 1727\cf0 	    
\f2\b my
\f0\b0  \cf6 $parpath\cf0  = &\cf5 get_par_path\cf0 (\cf4 "$OPATH\{PAR\}$pstep6.par"\cf0 ,\\\cf6 %PARAM\cf0 );\
  \cf2 1728\cf0 	    
\f2\b my
\f0\b0  \cf6 $states_str\cf0  = (\cf6 $parpath\cf0 =~
\f2\b /(\\[.*\\])/
\f0\b0 g)[\cf2 0\cf0 ];\
  \cf2 1729\cf0 	    
\f2\b my
\f0\b0  \cf6 $times_str\cf0   =  (\cf6 $parpath\cf0 =~
\f2\b /(\\\{.*\\\})/
\f0\b0 g)[\cf2 0\cf0 ];\
  \cf2 1730\cf0 	    
\f2\b print
\f0\b0  \cf6 $states_str\cf0 .\cf4 "\cf7 \\n\cf4 "\cf0 .\cf6 $times_str\cf0 .\cf4 "\cf7 \\n\cf4 "\cf0 ;\
  \cf2 1731\cf0 	    
\f2\b my
\f0\b0  (\cf6 $T1\cf0 , \cf6 $T2\cf0 ) = split 
\f2\b /\\s+/
\f0\b0 , &\cf5 get_anchor_times\cf0 (\cf6 $parpath\cf0 ,\\\cf6 @ANCHOR_BEG\cf0 , \\\cf6 @ANCHOR_END\cf0 );\
  \cf2 1732\cf0 	    
\f2\b print
\f0\b0  \cf4 "transition interval = ($T1,$T2)\cf7 \\n\cf4 "\cf0 ;\
  \cf2 1733\cf0 	\
  \cf2 1734\cf0 	       \
  \cf2 1735\cf0 	    
\f2\b my
\f0\b0  \cf6 $pacc\cf0 ;\
  \cf2 1736\cf0 	    
\f2\b my
\f0\b0  \cf6 $rand\cf0 ;\
  \cf2 1737\cf0 	    
\f2\b my
\f0\b0  (\cf6 $g\cf0 , \cf6 $gstate\cf0 , \cf6 $gtime\cf0 );\
  \cf2 1738\cf0 	    
\f2\b my
\f0\b0  \cf6 $awk_col\cf0  = \cf6 $BIAS\cf0 \{PAR\} + \cf2 1\cf0 ;\
  \cf2 1739\cf0 	    
\f2\b my
\f0\b0  \cf6 @lambda\cf0  = split \cf4 "\cf7 \\n\cf4 "\cf0 , `awk \cf7 \\'\cf0 \{
\f2\b print
\f0\b0  \\$\cf6 $awk_col\cf0 \}\cf7 \\'\cf0  \cf6 $OPATH\cf0 \{PAR\}\cf6 $pstep6\cf0 .par`;\
  \cf2 1740\cf0 	    chomp \cf6 @lambda\cf0 ; shift \cf6 @lambda\cf0 ;\
  \cf2 1741\cf0 	    \
  \cf2 1742\cf0 	   \
\
\
  \cf2 1743\cf0 	    
\f2\b do
\f0\b0 \{\
  \cf2 1744\cf0 		
\f1\i \cf3 #first pick any frame between boundaries in a uniform way
\f0\i0 \cf0 \
  \cf2 1745\cf0 		\
  \cf2 1746\cf0 		
\f2\b do
\f0\b0 \{\
  \cf2 1747\cf0 		    
\f2\b my
\f0\b0  \cf6 $bndry\cf0  = \cf5 int\cf0 ( \cf2 0.05\cf0  *\cf6 @zos\cf0  );\
  \cf2 1748\cf0 		    \cf6 $g\cf0    = \cf5 int\cf0 (\cf5 rand\cf0 ()*(\cf6 @zos\cf0 -\cf6 $bndry\cf0 )+\cf2 0.5\cf0 *\cf6 $bndry\cf0 );\
  \cf2 1749\cf0 	
\f1\i \cf3 #	    print "[gro=$g]";
\f0\i0 \cf0 \
  \cf2 1750\cf0 		    
\f2\b my
\f0\b0  \cf6 $gline\cf0  = &\cf5 get_nth_parline\cf0 (\cf4 "$OPATH\{PAR\}$pstep6.par"\cf0 ,\cf6 $g\cf0 );\
  \cf2 1751\cf0 		    \cf6 $gstate\cf0  = &\cf5 get_state\cf0 (\cf6 $gline\cf0 ,\\\cf6 %PARAM\cf0 );\
  \cf2 1752\cf0 	
\f1\i \cf3 #	    print "[state=>$gstate]";
\f0\i0 \cf0 \
  \cf2 1753\cf0 		    \cf6 $gtime\cf0  = (\cf5 split\cf0 (
\f2\b /\\s+/
\f0\b0 , \cf6 $gline\cf0 ))[\cf2 0\cf0 ];\
  \cf2 1754\cf0 	
\f1\i \cf3 #    	    print "[time=$gtime]\\n";
\f0\i0 \cf0 \
  \cf2 1755\cf0 		\}
\f2\b while
\f0\b0 ( &\cf5 get_state_types\cf0 (\cf6 $gstate\cf0 ,\\\cf6 %STATE\cf0 )=~
\f2\b /ini|fin/
\f0\b0  );\
  \cf2 1756\cf0 		\
  \cf2 1757\cf0 		\
  \cf2 1758\cf0 		
\f1\i \cf3 #reject or accept as initial pframe according to Bias B()
\f0\i0 \cf0 \
  \cf2 1759\cf0 	       \
  \cf2 1760\cf0 		\cf6 $pacc\cf0  = &\cf5 B\cf0 (\cf6 $g\cf0 , \\\cf6 @lambda\cf0 );\
  \cf2 1761\cf0 		\cf6 $rand\cf0  = \cf5 rand\cf0 ();\
  \cf2 1762\cf0 	\
  \cf2 1763\cf0 		
\f2\b if
\f0\b0 ( \cf6 $rand\cf0  <= \cf6 $pacc\cf0  ) \
  \cf2 1764\cf0 		\{\
  \cf2 1765\cf0 		    printf \cf4 "[trial gro: gro=%3d, time=%.3f, state=%s, lambda=%.2f] "\cf0 ,\cf6 $g\cf0 ,\cf6 $gtime\cf0 ,\cf6 $gstate\cf0 ,\cf6 $lambda\cf0 [\cf6 $g\cf0 ];\
  \cf2 1766\cf0 		    printf \cf4 "Pacc=%.4f Rand=%.4f "\cf0 , \cf6 $pacc\cf0 , \cf6 $rand\cf0 ;\
  \cf2 1767\cf0 		    printf \cf4 "ACCEPTED\cf7 \\n\cf4 "\cf0 ;\
  \cf2 1768\cf0 		\}\
  \cf2 1769\cf0 	
\f1\i \cf3 #	else \{printf "REJECTED\\n"\}
\f0\i0 \cf0 \
  \cf2 1770\cf0 	\
  \cf2 1771\cf0 	    \}
\f2\b while
\f0\b0 (\cf6 $rand\cf0  > \cf6 $pacc\cf0 );\
\
\
  \cf2 1772\cf0 	    \
  \cf2 1773\cf0 	   \
  \cf2 1774\cf0 	   \
  \cf2 1775\cf0 	    
\f1\i \cf3 ###################################################################################
\f0\i0 \cf0 \
  \cf2 1776\cf0 	    \
  \cf2 1777\cf0 	    \cf6 $SHOOT_FROM_STATE\cf0  = \cf6 $gstate\cf0 ;\
  \cf2 1778\cf0 	    \
  \cf2 1779\cf0 	    
\f2\b my
\f0\b0  \cf6 $g6\cf0   = &\cf5 numtostr\cf0 (\cf6 $g\cf0 ,\cf2 6\cf0 ); \
  \cf2 1780\cf0 	    
\f2\b my
\f0\b0  \cf6 $gro_name\cf0  = &bf_01(\cf6 $zos\cf0 [\cf6 $g\cf0 ]).\cf4 "$g6.gro"\cf0 ;\
  \cf2 1781\cf0 	    \cf6 $CUT_G\cf0  = \cf6 $g\cf0 ;\
  \cf2 1782\cf0 	    
\f2\b my
\f0\b0  \cf6 $gro\cf0  = \cf4 "$PATH\{PREV_GROS\}$gro_name"\cf0 ;\
  \cf2 1783\cf0 	    
\f2\b print
\f0\b0  \cf4 "chosen gro => $gro\cf7 \\n\cf4 "\cf0  
\f2\b if
\f0\b0  \cf6 $DEBUG_ON\cf0 ;\
  \cf2 1784\cf0 	    die \cf4 "this gro file doesn't exist"\cf0  
\f2\b if
\f0\b0  !-e \cf6 $gro\cf0 ;\
  \cf2 1785\cf0 	       \
  \cf2 1786\cf0 	    
\f2\b my
\f0\b0  \cf6 $g_zo\cf0  = \cf6 $zos\cf0 [\cf6 $g\cf0 ];\
  \cf2 1787\cf0 	    
\f2\b print
\f0\b0  \cf4 "THIS IS A "\cf0 .(\cf6 $g_zo\cf0 ==\cf2 1\cf0  ? \cf4 "FORWARD"\cf0  : \cf4 "BACWARD"\cf0 ).\cf4 " FRAME\cf7 \\n\cf4 "\cf0 ;\
  \cf2 1788\cf0 	\
  \cf2 1789\cf0 	        \
  \cf2 1790\cf0 	    
\f1\i \cf3 #BOX_SIZE#####################################
\f0\i0 \cf0 \
  \cf2 1791\cf0 	    &\cf5 ChangeBoxSize\cf0 (\cf6 $gro\cf0 ) 
\f2\b if
\f0\b0  \cf6 $CHANGE_BOX_SIZE_FLAG\cf0 ;\
  \cf2 1792\cf0 	    
\f1\i \cf3 ###############################################
\f0\i0 \cf0 \
  \cf2 1793\cf0 	\
  \cf2 1794\cf0 	    `cp \cf6 $gro $TMP\cf0 \{\cf2 0\cf0 \}`;\
  \cf2 1795\cf0 	    \
  \cf2 1796\cf0 	    
\f1\i \cf3 #always reversing, even if not necessary#######
\f0\i0 \cf0 \
  \cf2 1797\cf0 	    
\f2\b my
\f0\b0  \cf6 $revgro\cf0  = &\cf5 reverse_gro\cf0 (\cf6 $TMP\cf0 \{\cf2 0\cf0 \},\cf4 "$TMP\{0\}$gro_name"\cf0 );\
  \cf2 1798\cf0 	    
\f2\b if
\f0\b0 ( \cf6 $revgro\cf0 =~
\f2\b /ERROR/
\f0\b0  )\
  \cf2 1799\cf0 	    \{\
  \cf2 1800\cf0 		`rm -r \cf6 $TMP\cf0 \{\cf2 0\cf0 \}`;\
  \cf2 1801\cf0 		
\f2\b goto
\f0\b0  \cf5 prepare_gro_BEG\cf0 ;\
  \cf2 1802\cf0 	    \}\
  \cf2 1803\cf0 	    \
  \cf2 1804\cf0 	    
\f1\i \cf3 #copy files to run_forw/run_back respectively##
\f0\i0 \cf0 \
  \cf2 1805\cf0 	    \
  \cf2 1806\cf0 	    
\f2\b print
\f0\b0  \cf4 "RUN FOLDER INITIATED WITH CHOSEN GRO: "\cf0 ;\
  \cf2 1807\cf0 	    
\f2\b if
\f0\b0 (\cf6 $g_zo\cf0  == \cf2 1\cf0 )\
  \cf2 1808\cf0 	    \{\
  \cf2 1809\cf0 		
\f2\b print
\f0\b0  \cf4 "[gro->forw, revgro->back]\cf7 \\n\cf4 "\cf0 ;\
  \cf2 1810\cf0 		`cp \cf6 $gro    $PATH\cf0 \{TPSRUNF\}start.gro`;\
  \cf2 1811\cf0 		`cp \cf6 $revgro $PATH\cf0 \{TPSRUNB\}start.gro`;\
  \cf2 1812\cf0 	    \}\
  \cf2 1813\cf0 	    
\f2\b if
\f0\b0 (\cf6 $g_zo\cf0  == \cf2 0\cf0 )\
  \cf2 1814\cf0 	    \{\
  \cf2 1815\cf0 		
\f2\b print
\f0\b0  \cf4 "[gro->back, revgro->forw]\cf7 \\n\cf4 "\cf0 ;\
  \cf2 1816\cf0 		`cp \cf6 $gro    $PATH\cf0 \{TPSRUNB\}start.gro`;\
  \cf2 1817\cf0 		`cp \cf6 $revgro $PATH\cf0 \{TPSRUNF\}start.gro`;\
  \cf2 1818\cf0 	    \}\
  \cf2 1819\cf0 	   \
  \cf2 1820\cf0 		\
  \cf2 1821\cf0 	\
  \cf2 1822\cf0 	    
\f1\i \cf3 #clean#########################################
\f0\i0 \cf0 \
  \cf2 1823\cf0 	    `rm -r \cf6 $TMP\cf0 \{\cf2 0\cf0 \}`;\
  \cf2 1824\cf0 	    
\f2\b print
\f0\b0  BLUE, \cf4 "\cf7 \\n\cf4 >>>>>>>>>>>>>>>>>> prepare_gro_files: END <<<<<<<<<<<<<<<<<<\cf7 \\n\cf4 "\cf0 , RESET 
\f2\b if
\f0\b0  \cf6 $DEBUG_ON\cf0 ;    \
  \cf2 1825\cf0 	\}\
\
\
  \cf2 1826\cf0 	\
  \cf2 1827\cf0 	\
  \cf2 1828\cf0 	
\f2\b sub
\f0\b0  \cf5 prepare_gro_files_new\cf0 ()\
  \cf2 1829\cf0 	\{\
  \cf2 1830\cf0 	\
  \cf2 1831\cf0 	    
\f2\b my
\f0\b0  \cf6 %TMP\cf0 ; \cf6 $TMP\cf0 \{\cf2 0\cf0 \} = &\cf5 make_temp_dir_in\cf0 (\cf6 $PATH\cf0 \{TEMP\});       \
  \cf2 1832\cf0 	    
\f2\b my
\f0\b0  \cf6 $pstep6\cf0  = &\cf5 numtostr\cf0 (\cf6 $STEP\cf0 -\cf2 1\cf0 ,\cf2 6\cf0 );               \
  \cf2 1833\cf0 	\
  \cf2 1834\cf0 	    
\f2\b my
\f0\b0  \cf6 @pgros\cf0  = `ls -\cf2 1\cf0  \cf6 $PATH\cf0 \{PREV_GROS\} | grep .gro`; chomp \cf6 @pgros\cf0 ; \
  \cf2 1835\cf0 	    die \cf4 "input trajectory too short"\cf0  
\f2\b if
\f0\b0  \cf6 @pgros\cf0 <\cf2 10\cf0 ;\
  \cf2 1836\cf0 	    
\f2\b my
\f0\b0  \cf6 @zos\cf0  = &\cf5 _get_zos_array_from_PREV\cf0 ();\
   \cf2 602\cf0 	
\f2\b sub
\f0\b0  \cf5 _get_zos_array_from_PREV\cf0 () 
\f1\i \cf3 # 
\f0\i0 \cf0 \
   \cf2 603\cf0 	\{\
   \cf2 604\cf0 	    
\f2\b print
\f0\b0  RED, \cf4 "\cf7 \\n\cf4 >>>>get_zos_from_PREV: BEGIN (DEBUG)<<<<<<<<<\cf7 \\n\cf4 "\cf0 , RESET 
\f2\b if
\f0\b0  \cf6 $DEBUG_ON\cf0 ;\
   \cf2 605\cf0 	    \
   \cf2 606\cf0 	    
\f2\b my
\f0\b0  \cf6 $b_frames\cf0  = `ls -\cf2 1\cf0  \cf6 $PATH\cf0 \{PREV_GROS\} | grep gro | grep b | wc -l`;\
   \cf2 607\cf0 	    
\f2\b my
\f0\b0  \cf6 $f_frames\cf0  = `ls -\cf2 1\cf0  \cf6 $PATH\cf0 \{PREV_GROS\} | grep gro | grep f | wc -l`;\
   \cf2 608\cf0 	    chomp \cf6 $b_frames\cf0 ; chomp \cf6 $f_frames\cf0 ;\
   \cf2 609\cf0 	    
\f2\b print
\f0\b0  \cf4 "frames in PREV_GROS: b_frames = $b_frames  f_frames = $f_frames\cf7 \\n\cf4 "\cf0  
\f2\b if
\f0\b0  \cf6 $DEBUG_ON\cf0 ;\
   \cf2 610\cf0 	    
\f2\b my
\f0\b0  \cf6 @zos\cf0 ;\
   \cf2 611\cf0 	    
\f2\b for
\f0\b0 (
\f2\b my
\f0\b0  \cf6 $i\cf0 =\cf2 0\cf0 ; \cf6 $i\cf0 <\cf6 $b_frames\cf0 ; \cf6 $i\cf0 ++) \{push \cf6 @zos\cf0 , \cf2 0\cf0 \}\
   \cf2 612\cf0 	    
\f2\b for
\f0\b0 (
\f2\b my
\f0\b0  \cf6 $i\cf0 =\cf2 0\cf0 ; \cf6 $i\cf0 <\cf6 $f_frames\cf0 ; \cf6 $i\cf0 ++) \{push \cf6 @zos\cf0 , \cf2 1\cf0 \}\
   \cf2 613\cf0 	    
\f2\b print
\f0\b0  RED, \cf4 "\cf7 \\n\cf4 >>>>get_zos_from_PREV: END (DEBUG) <<<<<<<<<<\cf7 \\n\cf4 "\cf0 , RESET 
\f2\b if
\f0\b0  \cf6 $DEBUG_ON\cf0 ;\
   \cf2 614\cf0 	    
\f2\b return
\f0\b0  \cf6 @zos\cf0 ;\
   \cf2 615\cf0 	\}\
\
  \cf2 1837\cf0 	    
\f2\b print
\f0\b0  \cf4 "zos from PREV_GROS --> "\cf0 .\cf5 join\cf0 (\cf4 ""\cf0 ,\cf6 @zos\cf0 ).\cf4 "\cf7 \\n\cf4 "\cf0 ;\
  \cf2 1838\cf0 	\
  \cf2 1839\cf0 	    open PAR, \cf4 "$OPATH\{PAR\}$pstep6.par"\cf0 ;\
  \cf2 1840\cf0 	    
\f2\b my
\f0\b0  \cf6 @par\cf0     = <PAR> ; chomp \cf6 @par\cf0 ; shift \cf6 @par\cf0 ;\
  \cf2 1841\cf0 	    close \cf5 PAR\cf0 ;\
  \cf2 1842\cf0 	\
  \cf2 1843\cf0 	    
\f2\b my
\f0\b0  \cf6 @orig_par\cf0  = \cf6 @par\cf0 ; \
  \cf2 1844\cf0 	    \
  \cf2 1845\cf0 	    
\f2\b my
\f0\b0  \cf6 $awk_col\cf0  = \cf6 $BIAS\cf0 \{PAR\} + \cf2 1\cf0 ;\
  \cf2 1846\cf0 	    
\f2\b my
\f0\b0  \cf6 @lambda\cf0  = split \cf4 "\cf7 \\n\cf4 "\cf0 , `awk \cf7 \\'\cf0 \{
\f2\b print
\f0\b0  \\$\cf6 $awk_col\cf0 \}\cf7 \\'\cf0  \cf6 $OPATH\cf0 \{PAR\}\cf6 $pstep6\cf0 .par`;\
  \cf2 1847\cf0 	    chomp \cf6 @lambda\cf0 ; shift \cf6 @lambda\cf0 ;\
  \cf2 1848\cf0 	    
\f2\b my
\f0\b0  \cf6 $sw\cf0  = &\cf5 SW\cf0 (\\\cf6 @lambda\cf0 );\
  \cf2 1849\cf0 	    \
  \cf2 1850\cf0 	    
\f2\b if
\f0\b0 ( \cf6 $STORED_TIME_DIRECT\cf0  == -\cf2 1\cf0  ) 
\f1\i \cf3 #this means gros in prev_gros are reversed comparing to previous step
\f0\i0 \cf0 \
  \cf2 1851\cf0 	    \{\
  \cf2 1852\cf0 		
\f1\i \cf3 #then we have to revers parameters arrays; 
\f0\i0 \cf0 \
  \cf2 1853\cf0 	     	\cf6 @par\cf0     = reverse \cf6 @par\cf0 ;\
  \cf2 1854\cf0 	     	\cf6 @lambda\cf0  = reverse \cf6 @lambda\cf0 ;\
  \cf2 1855\cf0 	    \}\
  \cf2 1856\cf0 	    \
  \cf2 1857\cf0 	    
\f2\b my
\f0\b0  (\cf6 $g\cf0 , \cf6 $gstate\cf0 , \cf6 $gtime\cf0 , \cf6 $gtimeg\cf0 , \cf6 $rand\cf0 , \cf6 $pacc\cf0 );\
  \cf2 1858\cf0 	    
\f2\b do
\f0\b0 \{\
  \cf2 1859\cf0 		\
  \cf2 1860\cf0 		
\f2\b do
\f0\b0 \{\
  \cf2 1861\cf0 		    
\f2\b my
\f0\b0  \cf6 $bndry\cf0  = \cf5 int\cf0 ( \cf2 0.02\cf0  *\cf6 @pgros\cf0  );\
  \cf2 1862\cf0 		    \cf6 $g\cf0    = \cf5 int\cf0 (\cf5 rand\cf0 ()*(\cf6 @pgros\cf0 -\cf6 $bndry\cf0 )+\cf2 0.5\cf0 *\cf6 $bndry\cf0 );\
  \cf2 1863\cf0 		    
\f2\b print
\f0\b0  \cf4 "[gro=$g]\cf7 \\n\cf4 "\cf0 ;\
  \cf2 1864\cf0 		    
\f2\b my
\f0\b0  \cf6 $gline\cf0  = \cf6 $par\cf0 [\cf6 $g\cf0 ];\
  \cf2 1865\cf0 		    
\f2\b print
\f0\b0  \cf4 "[$gline]\cf7 \\n\cf4 "\cf0 ;\
  \cf2 1866\cf0 		    \cf6 $gstate\cf0  = &\cf5 get_state\cf0 (\cf6 $gline\cf0 ,\\\cf6 %PARAM\cf0 );\
  \cf2 1867\cf0 		    
\f2\b print
\f0\b0  \cf4 "[state=>$gstate]\cf7 \\n\cf4 "\cf0 ;\
  \cf2 1868\cf0 		    \cf6 $gtime\cf0   = (\cf5 split\cf0 (
\f2\b /\\s+/
\f0\b0 , \cf6 $gline\cf0 ))[\cf2 0\cf0 ];\
  \cf2 1869\cf0 	
\f1\i \cf3 #	    $gtimeg = (`head -n1 $PATH\{PREV_GROS\}/$pgros[$g]`=~/t(\\s+)?=(\\s+)?([0-9\\.]+)/g)[2];
\f0\i0 \cf0 \
  \cf2 1870\cf0 	   	    
\f2\b print
\f0\b0  \cf4 "[time from par=$gtime]\cf7 \\n\cf4 "\cf0 ;\
  \cf2 1871\cf0 	
\f1\i \cf3 #	    print "[time from gro=$gtimeg]\\n";
\f0\i0 \cf0 \
  \cf2 1872\cf0 	
\f1\i \cf3 #	    die "problems with reversal time from par!=time from gro" if $gtimeg!=$gtime; 
\f0\i0 \cf0 \
  \cf2 1873\cf0 		\}
\f2\b while
\f0\b0 ( &\cf5 get_state_types\cf0 (\cf6 $gstate\cf0 ,\\\cf6 %STATE\cf0 )=~
\f2\b /ini|fin/
\f0\b0  );\
  \cf2 1874\cf0 		\
  \cf2 1875\cf0 		\
  \cf2 1876\cf0 		
\f1\i \cf3 #reject or accept as initial pframe according to Bias B()
\f0\i0 \cf0 \
  \cf2 1877\cf0 		\cf6 $pacc\cf0  = &\cf5 B\cf0 (\cf6 $g\cf0 , \\\cf6 @lambda\cf0 );\
  \cf2 1878\cf0 		\cf6 $rand\cf0  = \cf5 rand\cf0 ()/\cf6 $sw\cf0 ;\
  \cf2 1879\cf0 	\
  \cf2 1880\cf0 		
\f2\b if
\f0\b0 ( \cf6 $rand\cf0  <= \cf6 $pacc\cf0  ) \
  \cf2 1881\cf0 		\{\
  \cf2 1882\cf0 		    printf \cf4 "[trial gro: gro=%3d, time=%.3f, grotime=%.3f, state=%s, lambda=%.2f] "\cf0 \
  \cf2 1883\cf0 			,\cf6 $g\cf0 ,\cf6 $gtime\cf0 ,\cf6 $gtimeg\cf0 ,\cf6 $gstate\cf0 ,\cf6 $lambda\cf0 [\cf6 $g\cf0 ];\
  \cf2 1884\cf0 		    printf \cf4 "Pacc=%.4f Rand=%.4f "\cf0 , \cf6 $pacc\cf0 , \cf6 $rand\cf0 ;\
  \cf2 1885\cf0 		    printf \cf4 "ACCEPTED\cf7 \\n\cf4 "\cf0 ;\
  \cf2 1886\cf0 		\}\
  \cf2 1887\cf0 	
\f1\i \cf3 #	else \{printf "REJECTED\\n"\}
\f0\i0 \cf0 \
  \cf2 1888\cf0 	\
  \cf2 1889\cf0 	    \}
\f2\b while
\f0\b0 (\cf6 $rand\cf0  > \cf6 $pacc\cf0 );\
  \cf2 1890\cf0 	    \cf6 $SHOOT_FROM_STATE\cf0  = \cf6 $gstate\cf0 ;\
  \cf2 1891\cf0 	    \cf6 $CUT_G\cf0  = \cf6 $g\cf0  
\f2\b if
\f0\b0  \cf6 $STORED_TIME_DIRECT\cf0  == \cf2 1\cf0 ;\
  \cf2 1892\cf0 	    \cf6 $CUT_G\cf0  = \cf6 @pgros\cf0  - \cf6 $g\cf0  -\cf2 1\cf0  
\f2\b if
\f0\b0  \cf6 $STORED_TIME_DIRECT\cf0  == -\cf2 1\cf0 ;\
  \cf2 1893\cf0 	    \
  \cf2 1894\cf0 	
\f1\i \cf3 #    print "orig_par[CUT_G] =  ". $orig_par[$CUT_G]."\\n";
\f0\i0 \cf0 \
  \cf2 1895\cf0 	    \
  \cf2 1896\cf0 	    \
  \cf2 1897\cf0 	    \
  \cf2 1898\cf0 	    
\f2\b my
\f0\b0  \cf6 $g6\cf0   = &\cf5 numtostr\cf0 (\cf6 $g\cf0 ,\cf2 6\cf0 ); \
  \cf2 1899\cf0 	    
\f2\b my
\f0\b0  \cf6 $gro\cf0  = \cf4 "$PATH\{PREV_GROS\}/$pgros[$g]"\cf0 ;\
  \cf2 1900\cf0 	    
\f2\b my
\f0\b0  \cf6 $gro_name\cf0  = \cf6 $pgros\cf0 [\cf6 $g\cf0 ];\
  \cf2 1901\cf0 	  \
  \cf2 1902\cf0 	    
\f2\b print
\f0\b0  \cf4 "chosen gro => $gro\cf7 \\n\cf4 "\cf0  
\f2\b if
\f0\b0  \cf6 $DEBUG_ON\cf0 ;\
  \cf2 1903\cf0 	    die \cf4 "this gro file doesn't exist"\cf0  
\f2\b if
\f0\b0  !-e \cf6 $gro\cf0 ;\
  \cf2 1904\cf0 	    
\f2\b my
\f0\b0  \cf6 $g_zo\cf0  = \cf6 $zos\cf0 [\cf6 $g\cf0 ];\
  \cf2 1905\cf0 	\
  \cf2 1906\cf0 	\
  \cf2 1907\cf0 	    \
  \cf2 1908\cf0 	    \
  \cf2 1909\cf0 	    
\f1\i \cf3 #BOX_SIZE######################################
\f0\i0 \cf0 \
  \cf2 1910\cf0 	    &\cf5 ChangeBoxSize\cf0 (\cf6 $gro\cf0 ) 
\f2\b if
\f0\b0  \cf6 $CHANGE_BOX_SIZE_FLAG\cf0 ;\
  \cf2 1911\cf0 	    
\f1\i \cf3 ###############################################
\f0\i0 \cf0 \
  \cf2 1912\cf0 	\
  \cf2 1913\cf0 	    `cp \cf6 $gro $TMP\cf0 \{\cf2 0\cf0 \}`;\
  \cf2 1914\cf0 	    \
  \cf2 1915\cf0 	    
\f1\i \cf3 #always reversing, even if not necessary#######
\f0\i0 \cf0 \
  \cf2 1916\cf0 	    
\f2\b my
\f0\b0  \cf6 $revgro\cf0  = &\cf5 reverse_gro\cf0 (\cf6 $TMP\cf0 \{\cf2 0\cf0 \},\cf4 "$TMP\{0\}$gro_name"\cf0 );\
  \cf2 1917\cf0 	    
\f2\b if
\f0\b0 ( \cf6 $revgro\cf0 =~
\f2\b /ERROR/
\f0\b0  )\
  \cf2 1918\cf0 	    \{\
  \cf2 1919\cf0 		`rm -r \cf6 $TMP\cf0 \{\cf2 0\cf0 \}`;\
  \cf2 1920\cf0 		
\f2\b goto
\f0\b0  \cf5 prepare_gro_BEG\cf0 ;\
  \cf2 1921\cf0 	    \}\
  \cf2 1922\cf0 	    \
  \cf2 1923\cf0 	    
\f1\i \cf3 #copy files to run_forw/run_back respectively##
\f0\i0 \cf0 \
  \cf2 1924\cf0 	    \
  \cf2 1925\cf0 	    
\f2\b print
\f0\b0  \cf4 "RUN FOLDER INITIATED WITH CHOSEN GRO: "\cf0 ;\
  \cf2 1926\cf0 	    
\f2\b if
\f0\b0 (\cf6 $g_zo\cf0  == \cf2 1\cf0 )\
  \cf2 1927\cf0 	    \{\
  \cf2 1928\cf0 		
\f2\b print
\f0\b0  \cf4 "[gro->forw, revgro->back]\cf7 \\n\cf4 "\cf0 ;\
  \cf2 1929\cf0 		`cp \cf6 $gro    $PATH\cf0 \{TPSRUNF\}start.gro`;\
  \cf2 1930\cf0 		`cp \cf6 $revgro $PATH\cf0 \{TPSRUNB\}start.gro`;\
  \cf2 1931\cf0 	    \}\
  \cf2 1932\cf0 	    
\f2\b if
\f0\b0 (\cf6 $g_zo\cf0  == \cf2 0\cf0 )\
  \cf2 1933\cf0 	    \{\
  \cf2 1934\cf0 		
\f2\b print
\f0\b0  \cf4 "[gro->back, revgro->forw]\cf7 \\n\cf4 "\cf0 ;\
  \cf2 1935\cf0 		`cp \cf6 $gro    $PATH\cf0 \{TPSRUNB\}start.gro`;\
  \cf2 1936\cf0 		`cp \cf6 $revgro $PATH\cf0 \{TPSRUNF\}start.gro`;\
  \cf2 1937\cf0 	    \}\
  \cf2 1938\cf0 	   \
  \cf2 1939\cf0 		\
  \cf2 1940\cf0 	\
  \cf2 1941\cf0 	    
\f1\i \cf3 #clean#########################################
\f0\i0 \cf0 \
  \cf2 1942\cf0 	    `rm -r \cf6 $TMP\cf0 \{\cf2 0\cf0 \}`;\
  \cf2 1943\cf0 	    
\f2\b print
\f0\b0  BLUE, \cf4 "\cf7 \\n\cf4 >>>>>>>>>>>>>>>>>> prepare_gro_files: END <<<<<<<<<<<<<<<<<<\cf7 \\n\cf4 "\cf0 , RESET 
\f2\b if
\f0\b0  \cf6 $DEBUG_ON\cf0 ;    \
  \cf2 1944\cf0 	\}\
  \cf2 1945\cf0 	\
\
\
  \cf2 1967\cf0 	\
  \cf2 2052\cf0 	\
  \cf2 2053\cf0 	\
\
  \cf2 2101\cf0 	\
  \cf2 2102\cf0 	\
  \cf2 2103\cf0 	\
  \cf2 2104\cf0 	\
  \cf2 2105\cf0 	\
  \cf2 2106\cf0 	\
  \cf2 2107\cf0 	\
  \cf2 2108\cf0 	\
  \cf2 2109\cf0 	\
\
\
\
  \cf2 2185\cf0 	\
  \cf2 2186\cf0 	\
  \cf2 2187\cf0 	\
  \cf2 2188\cf0 	
\f1\i \cf3 ###################################################################
\f0\i0 \cf0 \
  \cf2 2189\cf0 	
\f1\i \cf3 # HELP SUBROUTINES
\f0\i0 \cf0 \
  \cf2 2190\cf0 	
\f1\i \cf3 ###################################################################
\f0\i0 \cf0 \
  \cf2 2191\cf0 	\
  \cf2 2192\cf0 	
\f1\i \cf3 #want to export it in future the problem is gropath 
\f0\i0 \cf0 \
  \cf2 2193\cf0 	
\f2\b sub
\f0\b0  \cf5 extract_gros_from_trr\cf0 () 
\f1\i \cf3 #trr, #tpr, #dest, gropattern
\f0\i0 \cf0 \
  \cf2 2194\cf0 	\{\
  \cf2 2195\cf0 	    
\f2\b print
\f0\b0  RED, \cf4 ">>>>extract_gros_from_trr: BEGIN (DEBUG)<<<<<<<<<\cf7 \\n\cf4 "\cf0 , RESET 
\f2\b if
\f0\b0  \cf6 $DEBUG_ON\cf0 ;\
  \cf2 2196\cf0 	    
\f2\b my
\f0\b0  \cf6 $trr\cf0  = \cf5 shift\cf0 ;\
  \cf2 2197\cf0 	    
\f2\b my
\f0\b0  \cf6 $tpr\cf0  = \cf5 shift\cf0 ;\
  \cf2 2198\cf0 	    
\f2\b my
\f0\b0  \cf6 %P\cf0 ; \cf6 $P\cf0 \{\cf2 0\cf0 \} = \cf5 shift\cf0 ; \cf6 $P\cf0 \{\cf2 0\cf0 \} = &\cf5 SL\cf0 ( \cf6 $P\cf0 \{\cf2 0\cf0 \} );\
  \cf2 2199\cf0 	    
\f2\b my
\f0\b0  \cf6 $gr\cf0  = \cf5 shift\cf0 ;\
  \cf2 2200\cf0 	    
\f2\b my
\f0\b0  \cf6 $b\cf0  = 
\f2\b my
\f0\b0  \cf6 $e\cf0  = -\cf2 1\cf0 ;\
  \cf2 2201\cf0 	    
\f2\b if
\f0\b0 (\cf6 $_\cf0 [\cf2 0\cf0 ] && \cf6 $_\cf0 [\cf2 1\cf0 ])\{ \cf6 $b\cf0 =\cf5 shift\cf0 ; \cf6 $e\cf0 =shift \}\
  \cf2 2202\cf0 	\
  \cf2 2203\cf0 	
\f1\i \cf3 #NDEC16    my $input  = "-s $tpr -f $trr -ndec 16 -sep -b $b ";
\f0\i0 \cf0 \
  \cf2 2204\cf0 	    
\f2\b my
\f0\b0  \cf6 $input\cf0   = \cf4 "-s $tpr -f $trr -ndec $GRO_PREC -sep -b $b "\cf0 ;\
  \cf2 2205\cf0 	    \cf6 $input\cf0 .=\cf4 " -e $e"\cf0  
\f2\b if
\f0\b0  \cf6 $e\cf0 !=-\cf2 1\cf0 ;\
  \cf2 2206\cf0 	    
\f2\b my
\f0\b0  \cf6 $output\cf0  = \cf4 "-o $P\{0\}$gr.gro"\cf0 ;\
  \cf2 2207\cf0 	    
\f2\b my
\f0\b0  \cf6 $stream\cf0  = \cf4 "1>$P\{0\}trjconv.out 2>$P\{0\}trjconv.err"\cf0 ;\
  \cf2 2208\cf0 	    system \cf4 "$PATH\{GROMACS\}/trjconv $input $output $stream"\cf0 .\cf4 " <<EOF\cf7 \\n\cf0  \cf4 0\cf7 \\n\cf0  \cf4 EOF"\cf0 ;\
  \cf2 2209\cf0 	    
\f2\b print
\f0\b0  RED, \cf4 ">>>>extract_gros_from_trr: END (DEBUG)<<<<<<<<<<<\cf7 \\n\cf4 "\cf0 , RESET 
\f2\b if
\f0\b0  \cf6 $DEBUG_ON\cf0 ;\
  \cf2 2210\cf0 	\}\
  \cf2 2211\cf0 	\
  \cf2 2212\cf0 	\
  \cf2 2213\cf0 	\
  \cf2 2214\cf0 	\
  \cf2 2215\cf0 	\
  \cf2 2216\cf0 	\
  \cf2 2217\cf0 	\
  \cf2 2218\cf0 	
\f2\b sub
\f0\b0  \cf5 get_numof_frames\cf0 () 
\f1\i \cf3 #trr
\f0\i0 \cf0 \
  \cf2 2219\cf0 	\{\
  \cf2 2220\cf0 	    
\f2\b print
\f0\b0  RED, \cf4 ">>>>get_numof_frames: BEGIN (DEBUG)<<<<<<<<<\cf7 \\n\cf4 "\cf0 , RESET 
\f2\b if
\f0\b0  \cf6 $DEBUG_ON\cf0 ;\
  \cf2 2221\cf0 	    
\f2\b my
\f0\b0  \cf6 $trr\cf0  = \cf6 $_\cf0 [\cf2 0\cf0 ];\
  \cf2 2222\cf0 	    
\f2\b return
\f0\b0  -\cf2 1\cf0  
\f2\b if
\f0\b0  !-e \cf6 $trr\cf0 ;\
  \cf2 2223\cf0 	    
\f2\b my
\f0\b0  \cf6 $FR\cf0  = `\cf6 $SCRIPT\cf0 \{CNT_TRR_FR\} \cf6 $trr $FILE\cf0 \{TPR\} \cf6 $PATH\cf0 \{TEMP\}`; \
  \cf2 2224\cf0 	    
\f2\b print
\f0\b0  RED, \cf4 ">>>>get_numof_frames: END (DEBUG)<<<<<<<<<\cf7 \\n\cf4 "\cf0 , RESET 
\f2\b if
\f0\b0  \cf6 $DEBUG_ON\cf0 ;\
  \cf2 2225\cf0 	    
\f2\b return
\f0\b0  \cf6 $FR\cf0 +\cf2 0\cf0 ;\
  \cf2 2226\cf0 	\
  \cf2 2227\cf0 	\}\
  \cf2 2228\cf0 	\
  \cf2 2229\cf0 	\
  \cf2 2230\cf0 	\
  \cf2 2231\cf0 	\
  \cf2 2232\cf0 	\
  \cf2 2233\cf0 	\
  \cf2 2234\cf0 	
\f2\b sub
\f0\b0  \cf5 truncate_trrs\cf0 ()\
  \cf2 2235\cf0 	\{\
  \cf2 2236\cf0 	    
\f2\b print
\f0\b0  BLUE,\cf4 ">>>>>>>>> truncate_trrs_and_xys: BEGIN <<<<<<<<<<<<<<\cf7 \\n\cf4 "\cf0 ,RESET 
\f2\b if
\f0\b0  \cf6 $DEBUG_ON\cf0 ;    \
  \cf2 2237\cf0 	    
\f2\b print
\f0\b0  \cf4 "TRUNCATING TRRS: "\cf0 ;\
  \cf2 2238\cf0 	    \
  \cf2 2239\cf0 	    
\f1\i \cf3 #truncating forw if accepted#############################
\f0\i0 \cf0 \
  \cf2 2240\cf0 	    
\f2\b my
\f0\b0  \cf6 $TF\cf0   = &\cf5 get_state_arrival_time\cf0 (\cf6 $FILE\cf0 \{XYF\},\\\cf6 %STATE\cf0 ,\\\cf6 %PARAM\cf0 );\
  \cf2 2241\cf0 	    \
  \cf2 2242\cf0 	    
\f2\b if
\f0\b0 ( \cf6 $TF\cf0 > \cf2 0\cf0  )\
  \cf2 2243\cf0 	    \{\
  \cf2 2244\cf0 		\cf6 $TF\cf0 +=\cf6 $TIMESTEP\cf0 ;	\
  \cf2 2245\cf0 		
\f2\b print
\f0\b0  \cf4 "[FORW at $TF] "\cf0 ;\
  \cf2 2246\cf0 		
\f1\i \cf3 #truncating trr####################################
\f0\i0 \cf0 \
  \cf2 2247\cf0 		
\f2\b my
\f0\b0  \cf6 $trr\cf0  = \cf4 "$PATH\{TPSRUNF\}run.trr"\cf0 ;\
  \cf2 2248\cf0 		die \cf4 "truncate_trrs: $trr file does not exist"\cf0  
\f2\b if
\f0\b0  !-e \cf6 $trr\cf0 ;\
  \cf2 2249\cf0 		
\f2\b my
\f0\b0  \cf6 $input\cf0   = \cf4 "-s $FILE\{TPR\} -f $trr -e $TF"\cf0 ;\
  \cf2 2250\cf0 		
\f2\b my
\f0\b0  \cf6 $output\cf0  = \cf4 "-o $PATH\{TPSRUNF\}run_trunc.trr"\cf0 ;\
  \cf2 2251\cf0 		
\f2\b my
\f0\b0  \cf6 $stream\cf0  = \cf4 "1>$OPATH\{LOG\}truncate_trrs[forw].log 2>$OPATH\{LOG\}truncate_trrs[forw].err"\cf0 ;\
  \cf2 2252\cf0 		system \cf4 "$PATH\{GROMACS\}/trjconv $input $output $stream"\cf0 .\cf4 " <<EOF\cf7 \\n\cf0  \cf4 0\cf7 \\n\cf0  \cf4 EOF"\cf0 ;\
  \cf2 2253\cf0 		`mv \cf6 $PATH\cf0 \{TPSRUNF\}run_trunc.trr \cf6 $trr\cf0 `;\
  \cf2 2254\cf0 		\
  \cf2 2255\cf0 	    \}\
  \cf2 2256\cf0 	    \
  \cf2 2257\cf0 	    
\f1\i \cf3 #truncating backward if accepted########################
\f0\i0 \cf0 \
  \cf2 2258\cf0 	    
\f2\b my
\f0\b0  \cf6 $TB\cf0   = &\cf5 get_state_arrival_time\cf0 (\cf6 $FILE\cf0 \{XYB\},\\\cf6 %STATE\cf0 ,\\\cf6 %PARAM\cf0 );\
  \cf2 2259\cf0 	    
\f2\b if
\f0\b0 ( \cf6 $TB\cf0  > \cf2 0\cf0  )\
  \cf2 2260\cf0 	    \{\
  \cf2 2261\cf0 		\cf6 $TB\cf0 +=\cf6 $TIMESTEP\cf0 ;\
  \cf2 2262\cf0 		
\f2\b print
\f0\b0  \cf4 "[BACK at $TB]\cf7 \\n\cf4 "\cf0 ;\
  \cf2 2263\cf0 		
\f1\i \cf3 #truncating trr####################################
\f0\i0 \cf0 \
  \cf2 2264\cf0 		
\f2\b my
\f0\b0  \cf6 $trr\cf0  = \cf4 "$PATH\{TPSRUNB\}run.trr"\cf0 ;\
  \cf2 2265\cf0 		die \cf4 "truncate_trrs: $trr file does not exist"\cf0  
\f2\b if
\f0\b0  !-e \cf6 $trr\cf0 ;\
  \cf2 2266\cf0 		
\f2\b my
\f0\b0  \cf6 $input\cf0   = \cf4 "-s $FILE\{TPR\} -f $trr -e $TB"\cf0 ;\
  \cf2 2267\cf0 		
\f2\b my
\f0\b0  \cf6 $output\cf0  = \cf4 "-o $PATH\{TPSRUNB\}run_trunc.trr"\cf0 ;\
  \cf2 2268\cf0 		
\f2\b my
\f0\b0  \cf6 $stream\cf0  = \cf4 "1>$OPATH\{LOG\}truncate_trrs[back].log 2>$OPATH\{LOG\}truncate_trrs[back].err"\cf0 ;\
  \cf2 2269\cf0 		system \cf4 "$PATH\{GROMACS\}/trjconv $input $output $stream"\cf0 .\cf4 " <<EOF\cf7 \\n\cf0  \cf4 0\cf7 \\n\cf0  \cf4 EOF"\cf0 ;\
  \cf2 2270\cf0 		`mv \cf6 $PATH\cf0 \{TPSRUNB\}run_trunc.trr \cf6 $trr\cf0 `;\
  \cf2 2271\cf0 	\
  \cf2 2272\cf0 	    \}\
  \cf2 2273\cf0 	    
\f2\b print
\f0\b0  \cf4 "\cf7 \\n\cf4 "\cf0 ;\
  \cf2 2274\cf0 	    
\f2\b print
\f0\b0  BLUE,\cf4 ">>>>>>>>> truncate_trrs_and_xys: END <<<<<<<<<<<<<<\cf7 \\n\cf4 "\cf0 ,RESET 
\f2\b if
\f0\b0  \cf6 $DEBUG_ON\cf0 ;  \
  \cf2 2275\cf0 	    \
  \cf2 2276\cf0 	\}\
  \cf2 2277\cf0 	\
  \cf2 2278\cf0 	\
  \cf2 2279\cf0 	\
  \cf2 2280\cf0 	\
  \cf2 2281\cf0 	\
  \cf2 2282\cf0 	\
  \cf2 2283\cf0 	\
  \cf2 2284\cf0 	\
  \cf2 2285\cf0 	\
  \cf2 2286\cf0 	\
  \cf2 2287\cf0 	\
  \cf2 2288\cf0 	\
  \cf2 2289\cf0 	\
  \cf2 2290\cf0 	
\f2\b sub
\f0\b0  \cf5 make_par_file\cf0 ()\
  \cf2 2291\cf0 	\{\
  \cf2 2292\cf0 	    
\f2\b print
\f0\b0  RED, \cf4 ">>>>make_par_file: BEGIN (DEBUG)<<<<<<<\cf7 \\n\cf4 "\cf0 , RESET 
\f2\b if
\f0\b0  \cf6 $DEBUG_ON\cf0 ;\
  \cf2 2293\cf0 	    
\f2\b print
\f0\b0  \cf4 "preparing par file... "\cf0 ;\
  \cf2 2294\cf0 	    
\f2\b my
\f0\b0  \cf6 $step6\cf0  = &\cf5 numtostr\cf0 (\cf6 $STEP\cf0 ,\cf2 6\cf0 );\
  \cf2 2295\cf0 	    
\f2\b my
\f0\b0  \cf6 $trr\cf0  = \cf4 "$OPATH\{TRR\}$step6.trr"\cf0 ;\
  \cf2 2296\cf0 	    
\f2\b my
\f0\b0  \cf6 $out\cf0  = \cf4 "1>$NULL 2>$NULL"\cf0 ;\
  \cf2 2297\cf0 	\
  \cf2 2298\cf0 	    
\f1\i \cf3 #my $dummy = &queue();
\f0\i0 \cf0 \
  \cf2 2299\cf0 	\
  \cf2 2300\cf0 	    
\f1\i \cf3 #`echo 1 > $CURR_UPD_FOLDER/$dummy`;  #add dummy file to the queue folder
\f0\i0 \cf0 \
  \cf2 2301\cf0 	    system \cf4 "$SCRIPT\{UPDATE_XY\} $trr $out"\cf0 ;\
  \cf2 2302\cf0 	    
\f1\i \cf3 #`rm $CURR_UPD_FOLDER/$dummy`;        #remove dummy marker 
\f0\i0 \cf0 \
  \cf2 2303\cf0 	    \
  \cf2 2304\cf0 	    
\f2\b print
\f0\b0  \cf4 "done\cf7 \\n\cf4 "\cf0 ;\
  \cf2 2305\cf0 	    
\f2\b print
\f0\b0  RED, \cf4 ">>>>make_par_file: END (DEBUG)<<<<<<<<<\cf7 \\n\cf4 "\cf0 , RESET 
\f2\b if
\f0\b0  \cf6 $DEBUG_ON\cf0 ;  \
  \cf2 2306\cf0 	\}\
  \cf2 2307\cf0 	\
  \cf2 2308\cf0 	\
  \cf2 2309\cf0 	\
  \cf2 2310\cf0 	\
  \cf2 2311\cf0 	\
  \cf2 2312\cf0 	\
  \cf2 2313\cf0 	\
  \cf2 2314\cf0 	\
  \cf2 2315\cf0 	\
  \cf2 2316\cf0 	\
  \cf2 2317\cf0 	\
  \cf2 2318\cf0 	\
  \cf2 2319\cf0 	\
\
  \cf2 2388\cf0 	\
  \cf2 2389\cf0 	\
  \cf2 2390\cf0 	\
  \cf2 2391\cf0 	\
  \cf2 2392\cf0 	\
  \cf2 2393\cf0 	
\f2\b sub
\f0\b0  \cf5 queue\cf0 ()\
  \cf2 2394\cf0 	\{\
  \cf2 2395\cf0 	    
\f1\i \cf3 #updating queue#################################################################
\f0\i0 \cf0 \
  \cf2 2396\cf0 	    
\f2\b my
\f0\b0  \cf6 $queue\cf0 ;\
  \cf2 2397\cf0 	    
\f2\b print
\f0\b0  \cf4 "currently in update: "\cf0  
\f2\b if
\f0\b0  \cf6 $DEBUG_ON\cf0 ;\
  \cf2 2398\cf0 	    
\f2\b my
\f0\b0  \cf6 $cnt\cf0  = \cf2 1\cf0 ;\
  \cf2 2399\cf0 	    
\f2\b do
\f0\b0 \{\
  \cf2 2400\cf0 	    	\cf6 $queue\cf0  = `ls -\cf2 1\cf0  \cf6 $CURR_UPD_FOLDER\cf0  | wc -l`; chomp \cf6 $queue\cf0 ;\
  \cf2 2401\cf0 		
\f2\b print
\f0\b0  \cf6 $queue\cf0 .\cf4 " "\cf0  
\f2\b if
\f0\b0  \cf6 $DEBUG_ON\cf0 ;\
  \cf2 2402\cf0 		\cf5 sleep\cf0 ( \cf5 int\cf0 ( \cf5 rand\cf0 ()*\cf2 5\cf0 +\cf2 2\cf0  ) );\
  \cf2 2403\cf0 		\cf6 $cnt\cf0 ++;\
  \cf2 2404\cf0 		
\f2\b if
\f0\b0 ( \cf6 $cnt\cf0  >= \cf2 100\cf0 ) \{ 
\f2\b print
\f0\b0  \cf4 "\cf7 \\n\cf4 WARNING: CANNOT UPDATE. IS QUEUE FULL?\cf7 \\n\cf4 "\cf0  \}\
  \cf2 2405\cf0 	    \}
\f2\b while
\f0\b0 (\cf6 $queue\cf0  > \cf6 $MAX_SIMULT_UPDATES\cf0 );\
  \cf2 2406\cf0 	    \
  \cf2 2407\cf0 	    
\f2\b my
\f0\b0  \cf6 $dummy\cf0  = &\cf5 wherewhen\cf0 ();\
  \cf2 2408\cf0 	    
\f2\b return
\f0\b0  \cf6 $dummy\cf0 ;\
  \cf2 2409\cf0 	\}\
  \cf2 2410\cf0 	 \
  \cf2 2411\cf0 	\
  \cf2 2412\cf0 	\
  \cf2 2413\cf0 	\
  \cf2 2414\cf0 	\
  \cf2 2415\cf0 	\
\
  \cf2 2433\cf0 	\
  \cf2 2434\cf0 	\
  \cf2 2435\cf0 	\
  \cf2 2436\cf0 	 \
  \cf2 2437\cf0 	\
}